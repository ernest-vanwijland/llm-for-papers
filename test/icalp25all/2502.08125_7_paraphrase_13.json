{
  "paper": "2502.08125",
  "toprove": 7,
  "validity": 1,
  "comment": "paraphrase",
  "proof": "This proof summarizes the algorithm by van den Brand et al., for which the full details can be found in the proof of Theorem 3.1 in [45]. The process begins by running the algorithm from Corollary 2 on the predicted sequence $\\hat{\\sigma}$, which takes $\\tilde{O}(nm \\log W/\\epsilon)$ time. This preprocessing allows us to find the predicted distance $\\hat{d}^t(i, j)$ for any $t, i, j$ in $O(\\log \\log_{1+\\epsilon}(nW))$ time.\n\nWhen a query is made at time $t$ for the distance between vertices $i$ and $j$, we perform the following steps. We define $t'$ as the latest time for which all edges predicted in $\\hat{\\sigma}$ to appear by time $t'$ have actually appeared in the true sequence $\\sigma$ by time $t$. It is important to note that if $\\hat{\\sigma}$ is a permutation of $\\sigma$, then $t - t' \\le \\eta$, a fact formally proven in the discussion following Theorem 3.1 in [45]. We then define $E'$ as the set of all edges that have arrived by time $t$ excluding those that were predicted to arrive by time $t'$. Consequently, the size of this set is $|E'| = t - t' \\le \\eta$. Next, we construct a complete graph $G'$ whose vertex set includes all vertices that are endpoints of edges in $E'$, in addition to the query vertices $i$ and $j$. For every edge $e = (u, v)$ in $G'$, its weight is assigned the minimum of two values: (1) the weight of any edge between $u$ and $v$ present in $E'$, and (2) the predicted distance $\\hat{d}^{t'}(u, v)$. The query is answered by running Dijkstra's algorithm on $G'$ to find the distance from $i$ to $j$. The construction of $G'$ and the execution of Dijkstra's algorithm can be completed in $O(\\eta^2 \\log \\log_{1+\\epsilon}(nW))$ time.\n\nTo briefly explain the correctness of this method, we first show that the result is at least the true distance $d^t(i, j)$. Consider $P$, the shortest path from $i$ to $j$ in $G'$. Any edge $e = (u, v)$ on this path is of one of two kinds: it is either an edge from $E'$, or it is an edge with weight $\\hat{d}^{t'}(u, v)$. An edge with weight $\\hat{d}^{t'}(u, v)$ provides an upper bound on the shortest path length between $u$ and $v$ using only edges predicted to arrive by $t'$. By the definition of $t'$, all such predicted edges exist in the graph $G_t$. Therefore, by concatenating the edges of $P$ that are in $E'$ with the subpaths corresponding to the edges of $P$ not in $E'$, we can form a path $P'$ in $G_t$ whose weight is at most the weight of $P$.\n\nNext, we show that the computed answer is at most $(1+\\epsilon)d^t(i, j)$. Let $Q$ be the shortest path from $i$ to $j$ in the actual graph $G_t$. We can partition $Q$ into a sequence of segments, where each segment is either a single edge from $E'$ or a subpath composed entirely of edges not in $E'$. By the construction of $G'$, for each such edge and subpath, there is a corresponding edge in $G'$ with a weight that is at most $(1 + \\epsilon)$ times larger. Concatenating these corresponding edges creates a path $Q'$ in $G'$ with a total weight at most $(1 + \\epsilon)$ times that of $Q$.\n\nTo handle updates effectively for queries, two tasks are essential: we need to construct $E'$ efficiently and maintain the value of $t'$. We can achieve this by storing the inserted edges in a balanced binary-search tree, which requires $O(\\log n)$ time per insertion to maintain. At any time $t$, this BST contains the index, index$(e)$, for every edge $e$ that has arrived by time $t$. This structure enables us to find $t'$ in $O(\\log n)$ time and to construct $E'$ in $O(|E'|\\log n) = O(\\eta \\log n)$ time, as discussed in [45, Theorem 3.1].",
  "timestamp": "2025-09-15T12:29:53.268994"
}