{
  "paper": "2502.08125",
  "toprove": 1,
  "validity": 1,
  "comment": "paraphrase",
  "proof": "Let $m_y$ denote the number of edges that are alive in a subproblem $y$. For any given subproblem corresponding to the interval $[l, r]$, the time needed to determine the alive edges and nodes in $G_x$, where $x$ is the midpoint of $[l, r]$, is $O(m_r)$. When considering an alive edge $e = (u, v)$ in $G_x$, if the vertex $u$ is also alive in $G_x$, then adding $e$ to $G'_x$ requires $O(1)$ time. In the case where $u$ is not alive, the algorithm must retrieve $\\tilde{d}^r(u)$ from the lowest ancestor of $x$ within the recursion tree where $u$ is alive. This value is needed to determine the weight of the edge $(s, v)$ in $G'_x$.\n\nTo support this retrieval, each node $y$ in the recursion tree uses a balanced binary search tree to maintain the values of $\\tilde{d}^y(w)$ for all vertices $w$ that are alive in $G_y$. As a result, the algorithm can verify if a vertex is alive in any subproblem in $O(\\log n)$ time. Furthermore, if a vertex $w$ is alive in $G_y$, finding its corresponding value $\\tilde{d}^y(w)$ also takes $O(\\log n)$ time. Since any node $x$ has at most $\\log m$ ancestors, the process of recovering $\\tilde{d}^r(u)$ can be completed in $O(\\log n \\log \\log m)$ time by performing a binary search on the ancestors. Consequently, the total time to construct $G'_x$ is $O(m_x \\log n \\log \\log m)$. The time to execute Dijkstraâ€™s algorithm on $G'_x$ is $O(m_x \\log n)$. Additionally, building the balanced binary search tree for subproblem $x$ takes $O(m_x \\log n)$, since the number of alive nodes in $G_x$ is bounded by its number of alive edges. This implies that the algorithm's total runtime is bounded by the total number of alive edges across all subproblems, multiplied by a factor of $O(\\log n \\log \\log m)$.\n\nFor a given index $i$ and vertex $v$, let $x$ be the time at which $d(v)$ decreases from $(1 + \\epsilon / \\log m)^{i+1}$ to $(1 + \\epsilon / \\log m)^i$. This means $v$ is alive in any subproblem that includes time $x$. In each level of the recursion tree, there can be at most one such subproblem. For each vertex $v$, by summing over all $\\log_{1+\\epsilon/\\log m}(nW) = O(\\log(nW) \\log m/\\epsilon)$ possible values of $i$ and considering the $\\log m$ levels of the recursion tree, we find that there is a total of $O(\\log(nW) \\log^2 m/\\epsilon)$ subproblems in which $v$ is alive. An edge is only alive if its head vertex is alive, so the total number of alive edges across all subproblems is $m \\log(nW) \\log^2 m/\\epsilon$. By substituting $\\log m = O(\\log n)$, we derive an aggregate running time of $O(m \\log(nW) (\\log^3 n) (\\log \\log n)/\\epsilon)$.",
  "timestamp": "2025-09-15T12:29:17.429827"
}