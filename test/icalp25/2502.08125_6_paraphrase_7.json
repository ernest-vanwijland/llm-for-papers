{
  "paper": "2502.08125",
  "toprove": 6,
  "validity": 1,
  "comment": "paraphrase",
  "proof": "A rebuild of a subproblem $[l, r]$ is triggered only when an edge jumps over its midpoint or the midpoint of one of its ancestors. Any given subproblem has at most $\\log m$ ancestors. It follows from Lemma 6 that for any $\\tau$, a subproblem $[l, r]$ is rebuilt no more than $(\\log m)(\\tau + 2|HIGH(\\tau)|)$ times. Furthermore, Lemma 2 establishes that the time to rebuild all subproblems once is $\\tilde{O}(m \\log W/\\epsilon)$. Consequently, the total time for all rebuilds in the online algorithm is $\\tilde{O} (m \\cdot \\min_{\\tau} \\{\\tau + |HIGH(\\tau)|\\} \\cdot \\log W/\\epsilon)$.\n\nWe must also consider the time required for maintaining the distance array $D$. Let's analyze the updates to $D$ at a given time $t$. If no subproblem is rebuilt at time $t$, updating $D$ only requires iterating through the alive vertices in $G_t$. We can charge this cost to the last rebuild of subproblem $t$, since the set of alive vertices at time $t$ is identical to what it was during that last rebuild. On the other hand, if subproblems are rebuilt at time $t$, the update to $D$ involves a single iteration through the alive vertices of a subset of the subproblems being rebuilt. This cost can be charged to the current rebuild of those subproblems. Note that under this charging scheme, each subproblem rebuild throughout the entire process is charged at most once. This means that maintaining the distance array $D$ does not contribute any asymptotic overhead.\n\nFinally, we need to incorporate the time for updating the predicted sequence $\\hat{\\sigma}$. The total number of slots by which an edge $e \\in \\{e_1, ..., e_m\\}$ is shifted, summed over all edges, is equivalent to the total number of times any position $i \\in \\{1, ..., m\\}$ is jumped over. Based on Lemma 6, for any $\\tau$, each position is jumped over at most $\\tau+2|HIGH(\\tau)|$ times. Therefore, the time to update the predicted sequence is $O(m \\cdot (\\tau+|HIGH(\\tau)|))$ for any $\\tau$.\n\nThus, the total runtime of the algorithm is $\\tilde{O} (m \\cdot \\min_{\\tau} \\{\\tau + |HIGH(\\tau)|\\} \\cdot \\log W/\\epsilon)$.",
  "timestamp": "2025-09-15T12:29:04.014462"
}