\documentclass[letterpaper, USenglish, cleveref, autoref, thm-restate, numberwithinsect]{lipics-v2021}


\pdfoutput=1 \hideLIPIcs  



\bibliographystyle{plainurl}

\title{The Trichotomy of Regular Property Testing}

\author{Gabriel {Bathie}}{LaBRI, Université de Bordeaux \and DIENS, Paris, France \and \url{https://perso.ens-lyon.fr/gabriel.bathie}}{gabriel.bathie@labri.fr}{}{Partially funded by the grant ANR-20-CE48-0001 from the French National Research Agency.}

\author{Nathanaël Fijalkow}{LaBRI, CNRS, Université de Bordeaux, France \and \url{https://games-automata-play.com/}}{nathanael.fijalkow@gmail.com}{}{}
\author{Corto Mascle}{LaBRI, Université de Bordeaux, France \and MPI-SWS, Kaiserslautern, Germany \and \url{https://corto-mascle.github.io/}}{corto.mascle@labri.fr}{}{}



\authorrunning{G. Bathie and N. Fijalkow and C. Mascle} 

\Copyright{Gabriel Bathie and Nathanaël Fijalkow and Corto Mascle} 

\ccsdesc[500]{Theory of computation~Regular languages} 

\keywords{property testing, regular languages} 

\category{} 

\relatedversion{} 







\nolinenumbers 



\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}



\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{mathrsfs}
\usepackage{centernot}
\usepackage{todonotes}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{xspace}
\usepackage{ifthen}
\usepackage{tcolorbox}
\usepackage{tikz}
\usetikzlibrary{automata,arrows,arrows.meta,decorations,shapes.geometric,patterns}

\tikzset{
node distance=1cm, every state/.style={thick}, initial text=$ $, }

\theoremstyle{theorem}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{property}[theorem]{Property}
\theoremstyle{definition}
\newtheorem{problem}[theorem]{Problem}

\DeclareMathOperator{\polylog}{polylog}
\DeclareMathOperator{\poly}{poly}
\newcommand{\Aa}{\mathcal{A}}
\newcommand{\Bb}{\mathcal{B}}
\newcommand{\bit}{\{0, 1\}}
\newcommand{\Cc}{\mathcal{C}}
\newcommand{\Ot}{\tilde{O}}
\newcommand{\cO}{\mathcal{O}}
\newcommand{\curly}{\mathrel{\leadsto}}
\newcommand{\dd}{.\,.}
\newcommand{\Dd}{\mathcal{D}}
\newcommand{\EE}{\mathbb{E}}
\newcommand{\emptyw}{\gamma}
\newcommand{\eps}{\varepsilon}
\newcommand{\equivportals}{\simeq}
\newcommand{\factor}{\preccurlyeq}
\newcommand{\Ff}{\mathcal{F}}
\newcommand{\geqportals}{\succeq}
\newcommand{\lang}[1]{\mathcal{L}(#1)}
\newcommand{\lcm}{\mathsf{lcm}}
\newcommand{\lefteffect}[2]{(#1 \gg #2)}
\newcommand{\leqportals}{\preceq}
\newcommand{\Ll}{\mathcal{L}}
\newcommand{\lneqportals}{\prec}
\newcommand{\MBF}{\textsf{MBF}\xspace}
\newcommand{\MBS}{\textsf{MBS}\xspace}
\newcommand{\Mm}{\mathcal{M}}
\newcommand{\nequivportals}{\not\simeq}
\newcommand{\NL}{\textsf{NL}\xspace}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\NP}{\textsf{NP}\xspace}
\newcommand{\pobs}{\trianglelefteq}
\newcommand{\portal}[4]{#1,#2 \curly #3, #4}
\newcommand{\pow}[1]{2^{#1}}
\newcommand{\PP}{\mathbb{P}}
\newcommand{\Pp}{\mathcal{P}}
\newcommand{\PSPACE}{\textsf{PSPACE}\xspace}
\newcommand{\righteffect}[2]{(#2 \ll #1)}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\Ss}{\mathcal{S}}
\newcommand{\SCCpath}{\pi}
\newcommand{\SCCset}{\mathscr{S}}
\newcommand{\set}[1]{\{ #1 \}}
\newcommand{\sigmasize}[1]{|| #1 ||}
\newcommand{\size}[1]{|#1|}
\newcommand{\timedA}{\widehat{\Aa}}
\newcommand{\timedlanguage}[4]{\mathcal{L}(\portal{#1}{#2}{#3}{#4})}
\newcommand{\timedlang}[1]{\mathcal{TL}( #1 )}
\newcommand{\timedword}[2]{(#1:#2)}
\newcommand{\Tt}{\mathcal{T}}
\newcommand{\twu}{\timedword{0}{u}}
\newcommand{\Uu}{\mathcal{U}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\Prob}[2][]{\ifthenelse{\equal{#1}{}}{\PP}{\PP_{ #1 }}\left( #2 \right)}
\newcommand{\epslogeps}[1][]
{\ifthenelse{\equal{#1}{}}{\log(\eps^{-1})/\eps}{\log^{ #1 }(\eps^{-1})/\eps}}



\ifdefined\PhD
\newcommand{\doc}{chapter\xspace}
\else
\newcommand{\doc}{article\xspace}
\fi

\newcommand{\corto}[1]{\todo[color= yellow]{\textbf{C:} #1}}
\newcommand{\cortoinline}[1]{\todo[inline, color= yellow]{\textbf{C:} #1}}

\newcommand{\gabriel}[1]{\todo[color= blue!40]{\textbf{G:} #1}}
\newcommand{\gabrielinline}[1]{\todo[inline, color= blue!40]{\textbf{G:} #1}}

\newcommand{\nathinline}[1]{\todo[inline, color= red!40]{\textbf{N:} #1}}

\begin{document}
	
	
\maketitle
\begin{abstract}
Property testing is concerned with the design of algorithms making a sublinear number of queries to distinguish whether the input satisfies a given property or is far from having this property. A seminal paper of Alon, Krivelevich, Newman, and Szegedy in 2001 introduced property testing of formal languages: the goal is to determine whether an input word belongs to a given language, or is far from any word in that language. They constructed the first property testing algorithm for the class of all regular languages. This opened a line of work with improved complexity results and applications to streaming algorithms. In this work, we show a trichotomy result: the class of regular languages can be divided into three classes, each associated with an optimal query complexity. 
Our analysis yields effective characterizations for all three classes using so-called minimal blocking sequences, reasoning directly and combinatorially on automata.

 \end{abstract}

\section{Introduction}
Property testing was introduced by Goldreich, Goldwasser and Ron~\cite{goldreich1998property} in 1998: it is the study of randomized approximate decision procedures that must distinguishing objects that have a given property from those that are \emph{far} from having it. 
Because of this relaxation on the specification, the field focuses on very efficient decision procedures, typically with sublinear (or even constant) running time -- in particular, the algorithm does not even have the time to read the whole input.

In a seminal paper, Alon et al.~\cite{alon2001regular} introduced property testing of formal languages: given a language $L$ of finite words, the goal is to determine whether an input word $u$ belongs to the language or is $\eps$-far\footnote{Informally, $u$ is $\eps$-far from $L$ means that even by changing an $\eps$-fraction of the letters of $u$, we cannot obtain a word in $L$. See \cref{sec:preliminaries} for a formal definition.} from it, where $\eps$ is the precision parameter.
The model assumes random access to the input word: a \emph{query} specifies a position in the word and asks for the letter at that position, and the \emph{query complexity} of the algorithm is the worst-case number of queries it makes to the input.
Alon et al.~\cite{alon2001regular} showed a surprising result: under the Hamming distance, all regular languages are testable with $\cO(\epslogeps[3])$ queries, where the $\cO(\cdot)$ notation hides constants that depend on the language, but, crucially, not on the length of the input word.
In that paper, they also identified the class of \emph{trivial} regular languages, those for which the answer is always \emph{yes} or always \emph{no} for sufficiently large $n$, e.g. finite languages or the set of words starting with an $a$, and showed that testing membership in a \emph{non-trivial} regular language requires $\Omega(1/\eps)$ queries.

The results of Alon et al.~\cite{alon2001regular} leave a multiplicative gap of $\cO(\log^3(1/\eps))$ between the best upper and lower bounds.
We set out to improve our understanding of property testing of regular languages by closing this gap.
Bathie and Starikovskaya obtained in 2021~\cite{bathie2021property} the first improvement over the result of Alon et al.~\cite{alon2001regular} in more than 20 years:
\begin{fact}[{From \cite[Theorem 5]{bathie2021property}}]
    Under the edit distance, every regular language can be tested with $\cO(\epslogeps)$ queries.
\end{fact}
Testers under the edit distance are weaker than testers under the Hamming distance, hence this result does not exactly improve the result of Alon et al.~\cite{alon2001regular}. We overcome this shortcoming later in this \doc: \cref{thm:gen-ub} extends the above result to the case of the Hamming distance.

Bathie and Starikovskaya~\cite{bathie2021property} also showed that this upper bound is tight, in the sense that there is a regular language $L_0$ for which this complexity cannot be further improved, thereby closing the query complexity gap.
\begin{fact}[{From \cite[Theorem 15]{bathie2021property}}]
    There is a regular language $L_0$ with query complexity $\Omega(\epslogeps)$ under the edit distance\footnote{Note that, as opposed to testers, lower bounds for the edit distance are stronger than lower bounds of the Hamming distance.}, for all small enough $\eps > 0$.
\end{fact}
Furthermore, it is easy to find specific non-trivial regular languages for which there is an algorithm using only $\cO(1/\eps)$ queries, e.g. $L = a^*$ over the alphabet $\{a,b\}$, $L = (ab)^*$ or $L = (aa + bb)^*$.

Hence, these results combined with those of Alon et al.~\cite{alon2001regular} show that there exist trivial languages (that require 0 queries for large enough $n$), \emph{easy} languages (with query complexity $\Theta(1/\eps)$) and \emph{hard} languages (with query complexity $\Theta(\epslogeps)$).
This raises the question of whether there exist languages with a different query complexity (e.g. $\Theta(\log\log(\eps^{-1})/\eps)$), or if every regular is either trivial, easy or hard.
This further asks the question of giving a characterization of the languages that belong to each class, inspired by the recent success of exact characterizations of the complexity of sliding window~\cite{GanardiHL18} recognition and dynamic membership~\cite{amarilli2021dynamic} of regular languages.

In this \doc, we answer both questions: we show a trichotomy of the complexity of testing regular languages under the Hamming distance\footnote{We consider one-sided error testers, also called testing with perfect completeness, see definitions below.}, showing that there are only the three aforementioned complexity classes (trivial, easy and hard), we give a characterization of all three classes using a combinatorial object called \emph{blocking sequences}, and show that this characterization can be decided in polynomial space (and that it is complete for \PSPACE).
This trichotomy theorem closes a line of work on improving query complexity for property testers and identifying easier subclasses of regular languages. 



\subsection{Related work}

A very active branch of property testing focuses on graph properties, for instance one can test whether a given graph appears as a subgraph~\cite{AlonDLRY94} or as an induced subgraph~\cite{alon2000efficient}, and more generally every monotone graph property can be tested with one-sided error~\cite{AlonS08a}. Other families of objects heavily studied under this algorithmic paradigm include probabilistic distributions~\cite{paninski2008coincidence,diakonikolas2016new} combined with privacy constraints~\cite{Aliakbarpour2018DifferentiallyPI},
numerical functions~\cite{blum1990self, rubinfeld1996robust}, and programs~\cite{ergun1998spot,dodis1999improved}.
We refer to the book of Goldreich~\cite{goldreich2017introduction} for an overview of the field of property testing.

\subparagraph*{Testing formal languages.} Building upon the seminal work of Alon et al.~\cite{alon2001regular}, Magniez et al.~\cite{magniez2007property} gave a tester using $\cO(\epslogeps[2])$ queries for regular languages under the edit distance with moves, and François et al.~\cite{francois_et_al:LIPIcs:2016:6355} gave a tester using $\cO(1/\eps^2)$ queries for the case of the weighted edit distance.
Alon et al.~\cite{alon2001regular} also show that context-free languages cannot be tested with a constant number of queries, and subsequent work has considered testing specific context-free languages such as the \textsc{Dyck} languages~\cite{parnas2003testing,fischer2018improved} or regular tree languages~\cite{magniez2007property}.
Property testing of formal languages has been investigated in other settings: Ganardi et al.~\cite{ganardi2019sliding} studied the question of testing regular languages in the so-called ``sliding window model'', while others considered property testing for subclasses of context-free languages in the streaming model: Visibly Pushdown languages~\cite{francois_et_al:LIPIcs:2016:6355}, \textsc{Dyck} languages~\cite{JN14,Krebs,MagniezMN14} or $\mathsf{DLIN}$ and $\mathsf{LL}(k)$~\cite{BabuLRV13}.
A recent application of property testing of regular languages was to detect race conditions in execution traces of distributed systems~\cite{ThokairZMV23}.
 
\subsection{Main result and overview of the paper}
We start with a high-level presentation of the approach, main result, and key ideas. In this section we assume familiarity with standard notions such as finite automata; we will detail notations in \cref{sec:preliminaries}.

Let us start with the notion of a property tester for a language $L$: the goal is to determine whether an input word $u$ belongs to the language $L$, or whether it is $\eps$-far from it. 
We say that $u$ of length $n$ is \emph{$\eps$-far from $L$} with respect to a metric $d$ over words if all words $v \in L$ satisfy $d(u, v) \ge \eps n$, written $d(u,L) \ge \eps n$.
Throughout this work and unless explicitly stated otherwise, we will consider the case where $d$ is the Hamming distance, defined for two words $u$ and $v$ as the number of positions at which they differ if they have the same length, and as $+\infty$ otherwise.
In that case, $d(u,L) \ge \eps n$ means that one cannot change a proportion $\eps$ of the letters in $u$ to obtain a word in $L$.
We assume random access to the input word: a query specifies a position in the word and asks for the letter in this position. 
A \emph{$\eps$-property tester} (or for short, simply a \emph{tester}) $T$ for a language $L$ is a randomized algorithm that, given an input word $u$ of length $n$, always answers ``yes'' if $u\in L$ and answers ``no'' with probability bounded away from 0 when $u$ is $\eps$-far from $L$. 
As in previous works on this topic, we measure the complexity of a tester by its \emph{query complexity}. It is the maximum number of queries that $T$ makes on an input of length $n$, as a function of $n$ and $\eps$, in the worst case over all words of length $n$ and all possible random choices.

We can now formally define the classes of \emph{trivial, easy} and \emph{hard} regular languages.
\begin{definition}[Hard, easy and trivial languages]
	Let $L$ be a regular language. We say that:
	\begin{itemize}
		\item $L$ is \emph{hard} if  the optimal query complexity for a property tester for $L$ is $\Theta(\epslogeps)$.
		
		\item $L$ is \emph{easy} if the optimal query complexity for a property tester for $L$ is $\Theta(1/\eps)$.
		
		\item $L$ is \emph{trivial} if there exists $\eps_0> 0$ such that for all positive $\eps < \eps_0$, there is a property tester and some $n \in \NN$ such that the tester makes $0$ queries on words of length $\geq n$.
	\end{itemize}
\end{definition}


\begin{remark}\label{rmk:finite}
    If $L$ is finite, then it is trivial: since there is a bound~$B$ on the lengths of its words, a tester can reject words of length at least $n_0 = B+1$ without querying them.
    For that reason, we only consider \emph{infinite} languages in the rest of the article.
\end{remark}


Our characterization of those three classes uses the notion of \emph{blocking sequence} of a language $L$. Intuitively, they  are sequences of words such that finding those words as factors of a word $w$ proves that $w$ is not in $L$.
We also define a partial order on them, which gives us a notion of \emph{minimal} blocking sequence.

\begin{restatable}{theorem}{ptestmainthm}\label{thm:general}
	Let $L$ be an infinite regular language recognized by an NFA $\Aa$ and let $\MBS(\Aa)$ denote the set of minimal blocking sequences of $\Aa$.
	The complexity of testing $L$ is characterized by $\MBS(\Aa)$ as follows:
	\begin{enumerate}
		\item $L$ is trivial if and only if $\MBS(\Aa)$ is empty;
		\item $L$ is easy if and only if $\MBS(\Aa)$ is finite and nonempty;
		\item $L$ is hard if and only if $\MBS(\Aa)$ is infinite.
	\end{enumerate}
\end{restatable}
In the case where $L$ is recognised by a strongly connected automaton, blocking sequences can be replaced by \emph{blocking factors}. A blocking factor is a single word that is not a factor of any word in $L$.

\cref{sec:preliminaries} defines the necessary terms and notations.
The rest of the paper is structured as follows.
In Sections~\ref{sec:scc} and~\ref{sec:general}, we delimit the set of hard languages, that is, the ones that require $\Theta(\epslogeps)$ queries.
More precisely, \cref{sec:scc} focuses on the subcase of languages defined by \emph{strongly connected automata}.
First, we combine the ideas of Alon et al.~\cite{alon2001regular} with those presented in~\cite{bathie2021property} to obtain a property tester that uses $\cO(\epslogeps)$ queries for any language with a strongly connected automaton, under the Hamming distance.
Second, we show that if the language of a strongly connected automaton has infinitely many blocking factors then it requires $\Omega(\epslogeps)$ queries.
This result generalizes the result of Bathie and Starikovskaya~\cite{bathie2021property}, which was for a single language, to all regular languages with infinitely many minimal blocking factors. We use Yao's minimax principle~\cite{yao1977probabilistic}: this involves constructing a hard distribution over inputs, and showing that any deterministic property testing algorithms cannot distinguish between positive and negative instances against this distribution.

In \cref{sec:general}, we extends those results to all automata. The interplay with the previous section is different for the upper and the lower bound.For the upper bound of $\cO(\epslogeps)$ queries, we use a natural but technical extension of the proof in the strongly connected case. 
Note that this result is an improvement over the result of Bathie and Starikovskaya~\cite{bathie2021property}, which works under the edit distance, and testers for the Hamming distance are also testers for the edit distance.
For the lower bound of $\Omega(\epslogeps)$ queries for languages with infinitely many minimal blocking sequences, we reduce to the strongly connected case. The main difficulty is that it is not enough to consider strongly connected components in isolation: there exists finite automata that contain a strongly connected component that induces a hard language, yet the language of the whole automaton is easy. We solve this difficulty by carefully defining the notion of minimality for a blocking sequence.

\cref{sec:trivial-easy} completes the trichotomy, by characterising the easy and trivial languages.
We show that languages of automata with finitely many blocking sequences can be tested with $\cO(1/\eps)$ queries.
We also prove that if an automaton has at least one blocking sequence, then it requires $\Omega(1/\eps)$ queries to be tested, by showing that the languages that our notion of trivial language coincides with the one given by Alon et al.~\cite{alon2001regular}.
By contrast, we show that automata without blocking sequences recognize trivial languages.

Once we have the trichotomy, it is natural to ask whether it is effective: given an automaton $\Aa$, can we determine if its language is trivial, easy or hard? 
The answer is yes, and we show in \cref{sec:complexity} that all three decision problems are \PSPACE-complete, even for strongly connected automata.
 
\section{Preliminaries}
\label{sec:preliminaries}
\subparagraph*{Words and automata.}
We write $\Sigma^*$ (resp. $\Sigma^+$) for the set of finite words (resp. non-empty words) over the alphabet $\Sigma$.
The length of a word $u$ is denoted $|u|$, and its $i$th letter is denoted $u[i]$. The empty word is denoted $\emptyw$.
Given $u\in\Sigma^*$ and $0\le i, j \le |u|-1$, define $u[i\dd j]$ as the word $u[i]u[i+1]\ldots u[j]$ if $i\le j$ and $\emptyw$ otherwise.
Further, $u[i\dd j)$ denotes the word $u[i\dd j-1]$.
A word $w$ is a \emph{factor} (resp. \emph{prefix}, \emph{suffix}) of $u$ is there exist indices $i,j$ such that $w = u[i\dd j]$ (resp. with $i = 0, j = |u|-1$). We use $w\factor u$ to denote ``$w$ is a factor of $u$''.
Furthermore, if $w$ is a factor of $u$ and $w \neq u$, we say that $w$ is a \emph{proper factor} of $u$.
 
A \emph{nondeterministic finite automaton} (NFA) $\Aa$ is a transition system defined by a tuple $(Q, \Sigma, \delta, q_0, F)$, with $Q$ a finite set of states, $\Sigma$ a finite alphabet, $\delta : Q \times \Sigma \to \pow{Q}$ the transition function, $q_0 \in Q$ the initial state and $F \subseteq Q$ the set of final states. The semantics is as usual~\cite{Pin2021}.
When there is a path from a state $p$ to a state $q$ in $\Aa$, we say that $q$ is reachable from $p$ and that $p$ is co-reachable from $q$. 
In this work, we assume w.l.o.g. that all NFA $\Aa$ are \emph{trim}, i.e., every state is reachable from the initial state and co-reachable from some final state.

\subparagraph*{Property testing.} 

\begin{definition}\label{def:eps-far}
    Let $L$ be a language, let $u$ be a word of length $n$, let $\eps > 0$ be a precision parameter and let $d : \Sigma^*\times\Sigma^*\rightarrow \NN \cup\{+\infty\}$ be a metric.
	We say that the word $u$ is \emph{$\eps$-far from $L$ w.r.t. $d$} if $d(u, L) \ge \eps n$, where
    \[d(u, L) := \inf_{v\in L} d(u,v).\]  
\end{definition}
We assume random access to the input word: a query specifies a position in the word and asks for the letter in this position. 

Throughout this work and unless explicitly stated otherwise, we will consider the case where $d$ is the Hamming distance, defined for two words $u$ and $v$ as the number of positions at which they differ if they have the same length, and as $+\infty$ otherwise.
In that case, $d(u,L) \ge \eps n$ means that one cannot change an $\eps$-fraction of the letters in $u$ to obtain a word in $L$.

A \emph{$\eps$-property tester} (or simply a \emph{tester}) $T$ for a language $L$ is a randomized algorithm that, given an input word $u$, always answers ``yes'' if $u\in L$ and answers ``no'' with probability bounded away from 0 when $u$ is $\eps$-far from $L$. 

\begin{definition}\label{def:tester}
	A property tester for the language $L$ with precision $\eps > 0$ is a randomized algorithm $T$ that, for any input $u$ of length $n$, given random access to $u$, satisfies the following properties:
    \begin{align*}
        \text{ if } u\in L, & \text{ then } T(u) = 1, \\
        \text{ if $u$ is $\eps$-far from $L$}, & \text{ then } \Prob{T(u) = 0} \ge 2/3.
    \end{align*}
	The query complexity of $T$ is a function of $n$ and $\eps$ that counts the maximum number of queries that $T$ makes over all inputs of length $n$ and over all possible random choices.
\end{definition}


We measure the complexity of a tester by its \emph{query complexity}.
Let us emphasize that throughout this \doc we focus on so-called ``testers with perfect completeness'', or ``one-sided error'': if a word is in the language, the tester answers positively (with probability $1$). In particular our characterization applies to this class. 
Because they are based on the notion of blocking factors that we will discuss below, all known testers for regular languages~\cite{alon2001regular,magniez2007property,francois_et_al:LIPIcs:2016:6355, bathie2021property} have perfect completeness.

In this paper, we assume that the automaton $\Aa$ that describes the tested language $L$ is \emph{fixed}, and not part of the input. Therefore, we consider its number of states $m$ as a constant.

\subparagraph*{Graphs and periodicity.}
We now recall tools introduced by Alon et al.~\cite{alon2001regular} to deal with periodicity in finite automata.

Let $G = (V,E)$ with $E \subseteq V^2$ be a directed graph.
A \emph{strongly connected component} (or SCC) of $G$ is a maximal set of vertices that are all reachable from each other. 
It is \emph{trivial} if it contains a single state with no self-loop on it. 
We say that $G$ is \emph{strongly connected} if its entire set of vertices is an SCC.

 
The period $\lambda = \lambda(G)$ of a non-trivial strongly connected graph $G$ is the greatest common divisor of the length of the cycles in $G$.
Following the work of Alon et al.~\cite{alon2001regular}, we will use the following property of directed graphs.
\begin{fact}[{From \cite[Lemma 2.3]{alon2001regular}}]\label{fact:periodicity}
    Let $G = (V,E)$ be a non-empty, non-trivial, strongly connected graph with finite period $\lambda = \lambda(G)$.
    Then there exists a partition $V = Q_0\sqcup \ldots \sqcup Q_{\lambda-1}$ and a reachability constant $\rho = \rho(G)$ that does not exceed $3|V|^2$ such that:
    \begin{enumerate}
        \item\label{case:path-length} For every $0 \le i,j\le \lambda-1$ and for every $s\in Q_i, t\in Q_j$, the length of any directed path from $s$ to $t$ in $G$ is equal to $(j-i)\mod \lambda$.
        \item For every $0 \le i,j\le \lambda-1$, for every $s\in Q_i, t\in Q_j$ and for every integer $r\ge \rho$, if $r = (j-i) \pmod{\lambda}$, then  there exists a directed path from $u$ to $v$ in $G$ of length $r$.
    \end{enumerate}
\end{fact}
The sets $(Q_i: i = 0,\ldots, \lambda-1)$ are the \emph{periodicity classes} of $G$. In what follows, we will slightly abuse notation and use $Q_i$ even when $i \ge \lambda$ to mean $Q_{i \pmod{\lambda}}$ .

An automaton $\Aa = (Q, \Sigma, \delta, q_0, F)$ defines an underlying graph $G = (Q, E)$ where $E= \{(p,q) \in Q^2 \mid \exists a\in\Sigma: q\in\delta(p, a)\}$. 
In what follows, we naturally extend the notions defined above to finite automata through this graph $G$. 
Note that the numbering of the periodicity classes is defined up to a shift mod $\lambda$: we can thus always assume that $Q_0$ is the class that contains the initial state $q_0$.
The period of $\Aa$ is written $\lambda(\Aa)$.

\subparagraph*{Positional words and positional languages.}

Consider the language $L_3 = (ab)^*$.
The word $v = ab$ can appear as a factor of a word $u \in L_3$ if $v$ occurs at an even position (e.g. position 0, 2, etc.) in $u$. However, if $v$ occurs at an \emph{odd} position in $u$, then $u$ cannot be in $L_3$.
Therefore, $v$ can be used to witness that $u$ is not in $L_3$, but only if we find it at an odd position.
This example leads us to introducing \emph{$p$-positional words}, which additionally encode information about the index of each letter modulo an integer $p$.

More generally, we will associate to each regular language a period $\lambda$, and working with $\lambda$-positional words will allow us to define blocking factors in a position-dependent way without explicitly considering the index at which the factor occurs.

\begin{definition}[Positional words]
    Let $p$ be a positive integer.
    A $p$-\emph{positional word} is a word over the alphabet $\ZZ/p\ZZ\times \Sigma$ of the form $(n\pmod{p}, a_0) ((n+1) \pmod{p}, a_1) \cdots ((n+\ell) \pmod{p}, a_\ell)$ for some non-negative integer~$n$.
    If $u= a_0 \cdots a_\ell$, we write $\timedword{n}{u}$ to denote this word.
\end{definition}

With this definition, if $u = abcd$ and we consider the $2$-positional word $\tau = \timedword{0}{u}$, the factor $bc$ appears at position $1$ in $u$ and is mapped to the factor $\mu = (1, a)(0, b)$.
In this case, even when taking factors of $\mu$, we still retain the (congruence classes of the) indices in the original word $\tau$.

Any strongly connected finite automaton $\Aa = (Q, \Sigma, \delta, q_0, F)$ can naturally be extended into an automaton $\timedA$ over $\lambda(\Aa)$-positional words with $\lambda(\Aa)|Q|$ states. It suffices to keep track in the states of the current state of $\Aa$ and the number of letters read modulo $\lambda(\Aa)$.

We call the language recognized by $\timedA$ the \emph{positional language of $\Aa$},
and denote it $\timedlang{\Aa}$. This definition is motivated by the following property:
\begin{property}
	For any word $u\in\Sigma^*$, we have $u\in\lang{\Aa}$ if and only if $\twu\in\timedlang{\Aa}$.
\end{property}

Positional words make it easier to manipulate factors with positional information, hence we phrase our property testing results in terms of positional languages. Notice that a property tester for $\timedlang{\Aa}$ immediately gives a property tester for $\lang{\Aa}$, as one can simulate queries to $\twu$ with queries to $u$ by simply pairing the index of the query modulo $\lambda(\Aa)$ with its result. 
\section{Hard Languages for Strongly Connected NFAs}
\label{sec:scc}
Before considering the case of arbitrary NFAs, we first study the case of strongly connected NFAs, which are NFAs such that for any pair of states $p,q\in Q$, there exists a word~$w$ such that $p\xrightarrow{w}q$. We will later generalize the results of this section to all NFAs.

We show that the query complexity of the language of such an NFA~$\Aa$ can be characterized by the cardinality of the set of \emph{minimal blocking factors} of~$\Aa$, which are factor-minimal $\lambda(\Aa)$-positional words that witness the fact that a word does not belong to $\timedlang{\Aa}$.
In this section, we consider a fixed NFA~$\Aa$ and simply use ``positional words'' to refer to $\lambda$-positional words, where $\lambda = \lambda(\Aa)$ is the period of~$\Aa$.

\begin{definition}[Blocking factors]\label{def:blocking}
    Let~$\Aa$ be a strongly connected NFA.
    A positional word $\tau$ is a \emph{blocking factor} of~$\Aa$
    if for any other positional word $\mu$
    we have $\tau \factor \mu \Rightarrow \mu \notin \timedlang{\Aa}$.

    Further, we say that $\tau$ is a \emph{minimal} blocking factor of~$\Aa$ 
    if no proper factor of $\tau$ is a blocking factor of~$\Aa$.
    We use $\MBF(\Aa)$ to denote the set of all minimal blocking factors of~$\Aa$.
\end{definition}
Intuitively and in terms of automata, the positional word~$\timedword{i}{u}$ is blocking for~$\Aa$ if it does not label any transition in~$\Aa$ labeled by $u$ starting from a state of $Q_i$. (This property is formally established later in \cref{lemma:intuition-timed-word}.)
The main result of this section is the following:
\begin{theorem}\label{thm:scc}
    Let $L$ be an infinite language recognised by a strongly connected NFA~$\Aa$. If $\MBF(\Aa)$ is infinite, then $L$ is hard, i.e., it has query complexity $\Theta(\epslogeps)$
\end{theorem}
This result gives both an upper bound of $\cO(\epslogeps)$ and a lower bound of $\Omega(\epslogeps)$ on the query complexity of a tester for~$L$:
we prove the upper bound in \cref{sec:scc-ub} and the lower bound in \cref{sec:scc-lb}.

\subsection{Positional words, blocking factors and strongly connected NFAs}\label{sec:scc-tw}

We first establish some properties of positional words that will help us ensure that we are creating well-formed positional words, that is, positional words where the index $i$ of a letter $\timedword{i}{a}$ is equal to $j+1\pmod{\lambda}$, where $j$ is the index of the previous letter. In \cref{sec:scc-ub}, we highlight the connection between property testing and blocking factors in strongly connected NFAs.

We start with the following properties, which are consequences of \cref{fact:periodicity}.
\begin{corollary}\label{corollary:position-length}
    Let~$n$ be a nonnegative integer, let~$w$ be a word of length~$n$.
    If for some states $p\in Q_i, q\in Q_j$ of~$\Aa$ we have $p\xrightarrow{w}q$,
    then the indices $i,j$ satisfy the equation
    \begin{equation*}
        j-i = |w| \pmod{\lambda}
    \end{equation*}
\end{corollary}
\begin{corollary}\label{corollary:position-factor}
    Let $\tau = \timedword{i}{u}$ and $\mu = \timedword{j}{v}$ be positional words.
    If $\tau \factor \mu$, then there exists positional words $\eta, \eta'$ with $|\eta| = i-j \pmod{\lambda}$
    such that $\mu = \eta\tau\eta'$.
    In particular, this implies that there exists words $w,w'$ with $|w| = i-j \pmod{\lambda}$
    such that $v = wuw'$.
\end{corollary}

These properties allows us to formalize the intuition we gave earlier about blocking factors.

\begin{lemma}\label{lemma:intuition-timed-word}
    A positional word $\tau = \timedword{i}{u}$ is a blocking factor for $\Aa$
    iff for every states $p\in Q_i, q\in Q$, we have $p\centernot{\xrightarrow{u}}q$.
\end{lemma}

\begin{proof}\textcolor{red}{TOPROVE 0}\end{proof}

Next, we show that the Hamming distance between~$u$ and $\lang{\Aa}$ is the same as the (Hamming) distance between $\twu$ and $\timedlang{\Aa}$.
\begin{claim}\label{claim:far-equiv}
    For any word $u\in\Sigma^*$, we have $d(u, \lang{\Aa}) = d(\twu, \timedlang{\Aa})$.
\end{claim}
\begin{claimproof}
    The $\le$ part is straightforward.
    For the reverse inequality, if suffices to see that in any minimal substitution sequence from $\twu$
    to a positional word in $\timedlang{\Aa}$, no operation changes only the index of an (index, letter) pair.
\end{claimproof}
The above claim allows us to interchangeably use the statements ``$u$ is $\eps$-far from $\lang{\Aa}$'' and ``$\twu$ is $\eps$-far from $\timedlang{\Aa}$''.

\subsection{An efficient property tester for strongly connected NFAs.}\label{sec:scc-ub}
In this section, we show that for any strongly connected NFA~$\Aa$, there exists an $\eps$-property tester for $\lang{\Aa}$ that uses $\cO(\epslogeps)$ queries.
\begin{theorem}\label{thm:generic-tester-scc}
    Let~$\Aa$ be a strongly connected NFA.
    For any $\eps > 0$, there exists an $\eps$-property tester for $\lang{\Aa}$
    that uses $\cO(\epslogeps)$ queries. 
\end{theorem}

Our proof is similar to the one given in~\cite{bathie2021property}, with one notable technical improvement: we use a new method for sampling factors in~$u$, which greatly simplifies the correctness analysis.

\subsubsection{An efficient sampling algorithm}

We first introduce a sampling algorithm (\cref{alg:generic-sampling}) that uses few queries and has a large probability of finding at least one factor from a large set $\Ss$ of disjoint ``special'' factors.
Using this algorithm on a large set of disjoint blocking factors gives us an efficient property tester for strongly connected NFAs. We will re-use this sampling procedure later in the case of general NFAs (\cref{thm:gen-ub}).  

The procedure is fairly simple: the algorithm samples factors of various lengths in~$u$ at random.
On the other hand, the correctness of the tester is far from trivial.
The lengths and the number of factors of each length are chosen so that the number of queries is minimized and the probability of finding a ``special'' factor is maximized, regardless of their repartition in~$u$. (In what follows, the ``special'' factors are blocking factors.)

\begin{algorithm}[htbp]
\caption{Efficient generic sampling algorithm}\label{alg:generic-sampling}
\begin{algorithmic}[1] \Function{OneSample}{$u, \ell$}
    \State $i\gets \Call{uniform}{0, n-1}$
    \State $l\gets \max(i-\ell, 0), r\gets\min(i+\ell, n-1)$
    \State \Return $u[l\dd  r]$
\EndFunction
\Function{Sampler}{$u, N, L$}
\State $n \gets |u|$
\State $\beta \gets n/N$
\State $T \gets \lceil\log(L)\rceil$
\State $F \gets \emptyset$
\For{$t = 0$ to $T$}
    \State $\ell_t \gets 2^t, r_t \gets \lceil 2\ln(3)\beta/\ell_t \rceil$
    \For{$i = 0$ to $r_t$}
        \State $\Ff \gets \Ff \cup \{\Call{OneSample}{u, \ell_t}\}$
    \EndFor
\EndFor
\State \Return $\Ff$
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{claim}\label{claim:generic-sampling-alg-complexity}
    A call to $\Call{Sampler}{u, N, L}$ (\cref{alg:generic-sampling}) makes $\cO(n\log(L)/N)$ queries to~$u$.
\end{claim}
\begin{claimproof}
    A call to $\Call{OneSample}{u, \ell_t}$ makes at most $2\ell_t$ queries to $u$.
    Furthermore, the function $\Call{Sampler}{u, N, L}$ makes $r_t = 2\ln(3)\cdot \beta/\ell_t = 2\ln(3)\cdot n/(N\ell_t)$ calls to $\Call{OneSample}{u, \ell_t}$ for each $t = 0,\ldots, T$, where $T = \lceil\log(L)\rceil$.
    This adds up to \[\sum_{t=0}^T  r_t \cdot\ell_t = \lceil\log(L)\rceil \cdot2\ln(3)\cdot n/N = \cO(n\log(L)/N)\] queries to $u$.
\end{claimproof}

\begin{lemma}\label{lemma:generic-sampling-alg}
    Let $u$ be a word of length~$n$, and consider a set~$\Ss$ containing at least~$N$ disjoint factors of~$u$, each of length at most~$L$.
    A call to the function $\Call{Sampler}{u, N, L}$ (\cref{alg:generic-sampling}) returns a set $\Ff$ of factors of $u$ such that there exists a word of $\Ss$ that is a factor of some word of $\Ff$, with probability at least $2/3$.
\end{lemma}

\begin{proof}\textcolor{red}{TOPROVE 1}\end{proof}

\subsubsection{The tester}

The algorithm for \cref{thm:generic-tester-scc} is given in \cref{alg:generic-tester-scc}.

\begin{algorithm}[htbp]
\caption{Generic $\eps$-property tester that uses $\cO(\epslogeps)$ queries}\label{alg:generic-tester-scc}
\begin{algorithmic}[1] \Function{Tester}{$u, \eps$}
\State $n \gets |u|, m\gets |Q|$
\State $L \gets 12m^2/\eps$
\If{$\lang{\Aa} \cap \Sigma^n = \emptyset$}
    \State Reject
\ElsIf{$n < L$}
    \State Query all of $u$ and run~$\Aa$ on it
    \State Accept if and only if~$\Aa$ accepts
\Else \label{line:intersting-case}
    \State \label{line:compute-f}$\Ff \gets\Call{Sampler}{\twu, n/L, L}$
    \State Reject if and only if $\Ff$ contains a blocking factor for~$\Aa$.
\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

We now show that \cref{alg:generic-tester-scc} is a property tester for $\lang{\Aa}$ that uses $\cO(\epslogeps)$ queries. In what follows, we use $n$ to denote the length of the input word $u$ and $m$ to denote the number of states of $\Aa$.
\begin{claim}
    The tester given in \cref{alg:generic-tester-scc} makes $\cO(\epslogeps)$ queries to~$u$.
\end{claim}
\begin{proof}\textcolor{red}{TOPROVE 2}\end{proof}

Alon et al.~\cite[Lemma 2.6]{alon2001regular} first noticed that if a word~$u$ is $\eps$-far from $\lang{\Aa}$, then it contains $\Omega(\eps n)$ short factors that witness the fact that~$u$ is not in $\lang{\Aa}$.
We start by translating the lemma of Alon et al. on ``short witnesses'' to the framework of blocking factors.
More precisely, we show that if~$u$ is $\eps$-far from $\lang{\Aa}$, then $\twu$ contains many disjoint (i.e. non-overlapping) blocking factors.

\begin{lemma}\label{lemma:many-blocking}
    Let $\eps> 0$, let~$u$ be a word of length $n \ge 6m^2/\eps$ and assume that $\lang{\Aa}$ contains at least one word of length~$n$.
    If $\tau = \twu$ is $\eps$-far from $\timedlang{\Aa}$, then $\tau$ contains at least $\eps n/(6m^2)$ disjoint blocking factors.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 3}\end{proof}

Next, we show that if~$u$ is $\eps$-far from $\lang{\Aa}$, then $\twu$ contains $\Omega(\eps n)$ blocking factors, each of length $\cO(1/\eps)$.
\begin{lemma}\label{lemma:many-short-blocking} 
    Let $\eps> 0$, let~$u$ be a word of length $n \ge 6m^2/\eps$ and assume that $\lang{\Aa}$ contains at least one word of length~$n$.
    If~$u$ is $\eps$-far from $\lang{\Aa}$, then the positional word $\twu$ contains at least $\eps n/(12m^2)$ disjoint blocking factors of length at most $12m^2/\eps$.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 4}\end{proof}

\begin{proof}\textcolor{red}{TOPROVE 5}\end{proof}

\subsection{Lower bound from infinitely many minimal blocking factors}\label{sec:scc-lb}
We now show that languages with infinitely many \emph{minimal} blocking factors are hard, i.e. any tester for such a language requires $\Omega(\epslogeps)$ queries.

Let us first give an example that will motivate our construction. 
Consider the parity language~$P$ consisting of words that contain an even number of $b$'s, over the alphabet $\set{a,b}$.
Distinguishing $u \in P$ from $u \notin P$ requires $\Omega(n)$ queries, as changing the letter at single position can change membership in~$P$. However, $P$ is trivial to test, as any word is at distance at most~1 from~$P$, for the same reason.
Now, consider language $L_2$ consisting of words over $\set{a,b,c,d}$ such that between a~$c$ and the next~$d$, there is a word in~$P$. Intuitively, this language encodes multiple instances of~$P$, hence we can construct words $\eps$-far from $L_2$, and each instance is hard to recognize for property testers, hence the whole language is.
In~\cite[Theorem 15]{bathie2021property}, Bathie and Starikovskaya proved a lower bound of $\Omega(\epslogeps)$ on the query complexity of any property tester for $L_2$, matching the upper bound in the same paper. 

The minimal blocking factors of $L_2$ include all words for the form $cvd$ where $v\notin P$: there are infinitely many such words.
This is no coincidence: we show that this lower bound can be lifted to any language with infinitely many minimal blocking factors, under the Hamming distance.

\begin{theorem}\label{thm:scc-lb}
    Let~$\Aa$ be a strongly connected NFA.
    If $\MBF(\Aa)$ is infinite, then there exists a constant $\eps_0$ such that for any $\eps <\eps_0$, any $\eps$-property tester for $L = \lang{\Aa}$ uses $\Omega(\epslogeps)$ queries.
\end{theorem}
The proof of this result is full generalization of the lower bound against the ``repeated Parity'' example given above.

Our proof is based on (a consequence of) Yao's Minimax Principle~\cite{yao1977probabilistic}: if there is a distribution $\Dd$ over inputs such that any \emph{deterministic} algorithm that makes at most~$q$ queries errs on $u\sim{} \Dd$ with probability at least~$p$, then any \emph{randomized} algorithm with~$q$ queries errs with probability at least~$p$ on some input~$u$.

To prove \cref{thm:scc-lb}, we first exhibit such a distribution $\Dd$ for $q = \Theta(\epslogeps)$.
We take the following steps:
\begin{enumerate}
    \item we show that with high probability, an input~$u$ sampled w.r.t. $\Dd$ is either in or $\eps$-far from~$L$ (\cref{lemma:far-whp}),
    \item we show that with high probability, any deterministic tester that makes fewer than $c \cdot \epslogeps$ queries (for a suitable constant $c$) cannot distinguish whether the instance~$u$ is positive or $\eps$-far, hence it errs with large probability.
    \item combine the above two results to prove \cref{thm:scc-lb} via Yao's Minimax principle.
\end{enumerate}


\subsubsection{The structure of $\MBF(\Aa)$}
Before diving into the proof of \cref{thm:scc-lb}, we show that if $\MBF(\Aa)$ is infinite, then we can find minimal blocking factors with a ``regular'' structure, a crucial ingredient for our proof.
First, we prove that the set of minimal blocking factors of an automaton is a regular language, recognized by an automaton that is possibly exponentially larger than~$\Aa$.
We first prove the result for blocking factors of the form $\timedword{i}{u}$ for a fixed $i\in\ZZ/\lambda\ZZ$.
\begin{lemma}\label{lemma:blocking-regular}
    Let $\Aa = (Q, \Sigma, \delta, I, F)$ be a strongly connected NFA with~$m$ states and let $\lambda = \lambda(\Aa)$.
    For every $i \in\ZZ/\lambda\ZZ$, the set of minimal blocking factors of~$\Aa$ of the form $\timedword{i}{u}$ is a regular language recognized by a NFA of size $2^{\cO(m)}$.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 6}\end{proof}

It follows that the set of minimal blocking factors of~$\Aa$ is also a regular language.
\begin{corollary}
   Let~$\Aa$ be an NFA with~$m$ states.
   The set of minimal blocking factors of~$\Aa$ is a regular language recognized by an NFA of size $2^{\cO(m)}$.
\end{corollary}

Therefore, if $\MBF(\Aa)$ is infinite, we can use the Pumping Lemma~\cite[Chapter 1, Proposition 2.2]{Pin2021} to find an infinite family of minimal blocking factors with a shared structure $\{\phi \nu^r \chi, r\in\NN\}$, for some non-empty positional words $\phi, \nu$ and~$\chi$. We will use this property later, when proving a lower bound against the language of automata with infinitely many blocking factors.
\begin{restatable}{lemma}{lemmagoodbf}\label{lemma:good-bf}
    If $\MBF(\Aa)$ is infinite, then there exist positional words $\phi,\nu_+,\nu_-,\chi$ such that:
    \begin{enumerate}
        \item the words $\nu_+$ and $\nu_-$ have the same length,
        \item there exists a constant $ S = 2^{\poly(m)}$ such that $|\phi|, |\nu_+|, |\nu_-|, |\chi|\le  S$,
        \item there exists an index $i_*\in\ZZ/ \lambda\ZZ$ and a state $q_*\in Q_{i_*}$ such that for every integer $r \ge 1$,
        the positional word $\tau_{-,r} = \phi(\nu_-)^r\chi$ is blocking for~$\Aa$, and for every $s < r$, we have
        \[q_* \xrightarrow{\tau_{+,r,s}} q_* \text{ where } \tau_{+,r,s} = \phi(\nu_-)^j\nu_+(\nu_-)^{r-1-s}\chi.\]
        In particular, $\tau_{+,r,s}$ is not blocking for~$\Aa$.
    \end{enumerate}
\end{restatable}
Note that here, the state $q_*$ is the same for \emph{every} integers $r, s$.
\begin{proof}\textcolor{red}{TOPROVE 7}\end{proof}

\subsubsection{Constructing a Hard Distribution $\Dd$}
Let $\eps > 0$ be sufficiently small and let~$n$ be a large enough integer.
In what follows, $m$ denotes the number of states of~$\Aa$.
To construct the hard distribution $\Dd$, we will use an infinite family of blocking factors that share a common structure, given by \cref{lemma:good-bf}.

The crucial property here is that $\tau_{-,r}$ and $\tau_{+,r, s}$ are very similar: they have the same length, differ in at most~$S$ letters, yet one of them is blocking and the other is not.

We now use the words $\tau_{-,r}$ and $\tau_{+,r,s}$ and the constant $ S$ to describe how to sample an input $\mu = \twu$ of length~$n$ w.r.t. $\Dd$.

Let $\pi$ be a uniformly random bit. If $\pi = 1$, we will construct a positive instance $\mu \in \timedlang{\Aa}$, and otherwise the instance will be $\eps$-far from $\timedlang{\Aa}$ with high probability.
We divide the interval $[0 \dd n-1]$ into $k = \eps n$ intervals of length $\ell = 1/\eps$, plus small initial and final segments $\mu_i$ and $\mu_f$ of length $\cO(\rho)$ to be specified later.
For the sake of simplicity, we assume that~$k$ and $\ell$ are integers and that $\lambda$ divides $\ell$.
For $j=1,\ldots, k$, let $a_j, b_j$ denote the endpoints of the $j$-th interval.
For each interval, we sample independently at random a variable $\kappa_j$ with the following distribution:
\begin{equation}
    \kappa_j = \begin{cases}
        t, &\text{ with prob. } p_t = 3\cdot 2^t S\eps/\log(( S\eps)^{-1}) \text{ for } t = 1,2,\ldots, \log(( S\eps)^{-1}),\\
        0,&\text{ with prob. } p_0 = 1 - \sum_{t=1}^{{\log(( S\eps)^{-1})}} p_t.
    \end{cases} 
\end{equation}
The event $\kappa_j > 0$ means that the $j$-th interval is filled with $N \approx 2^{-\kappa_j}/\eps$ ``special'' factors.
When $\pi = 0$, these ``special'' factors will be minimal blocking factors $\tau_{-, r}$ for $r = 2^{\kappa_j}$, whereas when $\pi = 1$, they will instead be similar non-blocking factors $\tau_{+, r, s}$ for a uniformly random $s$: they will be hard to distinguish with few queries.
On the other hand, the event $\kappa_j = 0$ means that the $j$-th interval contains no specific information.
More precisely, we choose a positional word $\eta_*$ of length $\ell$ such that $q_* \xrightarrow{\eta_*} q_*$: by \cref{fact:periodicity}, this is possible as $\ell = 0 \pmod\lambda$. Then, if $\kappa_j = 0$, we set $\mu[a_j\dd b_j] = \eta_*$, regardless of the value of $\pi$.

Formally, if $\kappa_j > 0$, let $r = 2^{\kappa_j}$, $N = 2^{-\kappa_j}/( S\eps)$
and let $\eta$ be a word of length $\ell - N\cdot |\tau_{-,r}|$ such that $q_* \xrightarrow{\eta} q_*$: such a word exists as $\lambda$ divides $\ell$ and $|\tau_{-,r}|$.
We construct the $j$-th interval as follows:
\begin{itemize}
     \item if $\pi = 0$, we set $\mu[a_j\dd b_j] = (\tau_{-,r})^N\eta$,
     \item if $\pi = 1$, we select $s\in [0\dd  r-1]$ uniformly at random, and set $\mu[a_j\dd b_j] = (\tau_{+,r,s})^N\eta$.
\end{itemize}
Finally, the initial and final fragments $\mu_i$ and $\mu_f$ of $\mu$ are chosen to be the shortest words that label a transition from $q_0$ to $q_*$ and $q_*$ to a final state, respectively.

\subsubsection{Properties of the distribution $\Dd$}
Next, we establish that the distribution $\Dd$ has the desired properties.
\begin{observation}
    If $\eps$ is small enough, $\Dd$ is well-defined, i.e. for every~$t$ between~$0$ and $\log(( S\eps)^{-1})$, we have $0 \le p_t \le 1$.
\end{observation}

\begin{observation}
    If $\pi = 1$, then $\mu\in \timedlang{\Aa}$.
\end{observation}

\begin{lemma}\label{lemma:far-whp}
    Conditioned on $\pi = 0$, the probability of the event $\Ff = \{ \mu$ is $\eps$-far from $\timedlang{\Aa} \}$ goes to~$1$ as~$n$ goes to infinity.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 8}\end{proof}

\begin{corollary}\label{coro:large-fail-proba}
    For large enough~$n$, we have $\Prob{\Ff} \ge 5/12$.
\end{corollary}

Intuitively, our distribution is hard to test because positive and negative instances are very similar.
Therefore, a tester with few queries will likely not be able to tell them apart: the perfect completeness constraint forces the tester to accept in that case.
Below, we establish this result formally.
\begin{lemma}\label{lemma:must-accept}
    Let~$T$ be a deterministic tester with perfect completeness (i.e. it always accepts $\tau\in \timedlang{\Aa}$) and let $q_j$ denote the number of queries that it makes in the $j$-th interval.
    Conditioned on the event $\Mm = \{\forall j \text{ s.t. }\kappa_j > 0, q_j < 2^{\kappa_j}\}$, the probability that~$T$ accepts~$\mu \sim{}\Dd$ is~$1$.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 9}\end{proof}

Next, we show that if a tester makes few queries, then the event $\Mm$ has large probability.

\begin{lemma}\label{lemma:proba-fail}
    Let~$T$ be a deterministic tester, let $q_j$ denote the number of queries that it makes in the $j$-th interval, and assume that~$T$ makes at most $\frac{1}{72}\cdot \log(S/\eps)/\eps$ queries, i.e. $\sum_j q_j \le \frac{1}{72}\cdot \log(S/\eps)/\eps$.
    The probability of the event $\Mm = \{\forall j \text{ s.t. }\kappa_j > 0, q_j < 2^{\kappa_j}\}$ is at least $11/12$.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 10}\end{proof}

We are now ready to prove \cref{thm:scc-lb}.
\begin{proof}\textcolor{red}{TOPROVE 11}\end{proof}
 
\section{Characterisation of Hard Languages for All NFAs}
\label{sec:general}
In this section we extend the results of the previous section to all finite automata.
This extension is based on a generalization of blocking factors: we introduce \emph{blocking sequences}, which are sequences of factors that witness the fact that we cannot take any path through the strongly connected components of the automaton.
For the lower bound, we define a suitable partial order on blocking sequences, which extends the factor relation on words to those sequences, and allows us to define \emph{minimal} blocking sequences.

\subsection{Blocking sequences}\label{sec:blocking-seq}

\subsubsection{Examples motivating blocking sequences}

Before presenting the technical part of the proof, let us go through two examples, which motivate the notions that we introduce and illustrate some of the main difficulties.

\begin{example}
	Consider the automaton $\Aa_1$ depicted in \cref{fig:aut-ab-bc}: it recognizes the language $L_1$ of words in which all $c$'s appear before the first $b$, over the alphabet $\set{a,b,c}$.

	\begin{figure}[htbp]
	\begin{center}
		\begin{tikzpicture}[shorten >=1pt, node distance=3cm, on grid, auto,
			every initial by arrow/.style={thick}, every accepting by arrow/.style={thick}, >={stealth'}]
\tikzset{
				state/.style={
					circle,
					thick,
					draw,
					minimum size=8mm,
					inner sep=2pt
				},
				accepting/.style={
					state,
					accepting by arrow,
					accepting below
				}
			}
			
\node[state, initial , accepting] (q0) {$q_0$};
			\node[state, accepting] (q1) [right=of q0] {$q_1$};
			\node[state] (q2) [right=of q1] {$q_2$};
			
\path[->, thick, >=stealth']
			(q0) edge[above] node {\textcolor{red}{$b$}} (q1)
			(q1) edge[above] node {\textcolor{red}{$c$}} (q2)
			(q0) edge[loop above] node {$a, c$} ()
			(q1) edge[loop above] node {$a, b$} ()
			(q2) edge[loop above] node {$a, b, c$} ();
			
		\end{tikzpicture}
		\caption{An automaton $\Aa_1$ that recognizes the language $L_1 = (a+c)^* (a+b)^*$.}
		\label{fig:aut-ab-bc}
	\end{center}
	\end{figure}

	The set of minimal blocking factors of $\Aa_1$ is infinite: it is the language $ba^*c$.
	Yet, $L_1$ is easy to test: we sample $\cO(1 / \eps)$ letters at random, answer ``no'' if the sample contains a~$c$ occurring after a~$b$, and ``yes'' otherwise.
	To prove that this yields a property tester, we rely on the following property: 
	\begin{property}
		If $u$ is $\eps$-far from $L_1$, then it can be decomposed into $u = u_1 u_2$ where $u_1$ contains $\Omega(\eps n)$ letters $b$ and $u_2$ contains $\Omega(\eps n)$ letters $c$.
	\end{property}

	The pair of factors $(b, c)$ is an example of blocking sequence: a word that contains an occurrence of the first followed by an occurrence of the second cannot be in $L_1$.
	We can also show that a word $\eps$-far from $L_1$ must contains many disjoint blocking sequences -- this property (\cref{lem:far-from-path-implies-many-blocking}) underpins the algorithm for general regular languages.
	
	What this example shows is that blocking factors are not enough: we need to consider sequences of factors, yielding the notion of \emph{blocking sequences}.
	Intuitively, a blocking sequence for $L$ is a sequence $\sigma = (v_1,\ldots, v_k)$ of (positional) words such that if each word of the sequence appears in $u$, with the occurrences of the $v_i$'s ordered as in $\sigma$, then $u$ is not in $L$.\footnote{This is not quite the definition, but it conveys the right intuition.}
	While $L_1$ has infinitely many minimal blocking factors, it has a single minimal blocking sequence $\sigma = (b, c)$.
\end{example}

Notice that the (unique) blocking sequence $(b,c)$ can be visualized on \cref{fig:aut-ab-bc}:
it is composed of the red letters that label transitions between the different SCCs. This is no coincidence: in many simple cases, blocking sequences are exactly sequences that contain one blocking factors for each SCC.
This fact could lead one to believe that the set of minimal blocking sequences is exactly the set of sequences of minimal blocking factors, one for each SCC. In particular, this would imply that as soon as one SCC has infinitely many minimal blocking factors, the language of the whole automaton is hard to test.
We show in the next example that this is not always the case, because SCCs might share minimal blocking factors.
\begin{example}\label{example:hard-to-easy}
	Consider the automaton in \cref{fig:series}: it has two SCCs and a sink state.
	The minimal blocking factors of the first SCC are given by $B_1 = be^*c + a$, and $B_2 = \set{a}$ for the second SCC.
	This automaton is easy to test: intuitively, a word that is $\varepsilon$-far from this language has to contain many~$a$'s, as otherwise we can make it accepted by deleting all~$a$'s, thanks to the second SCC.
	However,~$a$ is also a blocking factor of the first SCC, therefore, as soon as we find two~$a$'s in the word, we know that it is not in $L_2$.
	\begin{figure}[htbp]
	\begin{center}
	\begin{tikzpicture}[shorten >=1pt, node distance=3cm, on grid, auto,
		every initial by arrow/.style={thick}, every accepting by arrow/.style={thick}, >={stealth'}]
\tikzset{
			state/.style={
				circle,
				thick,
				draw,
				minimum size=8mm,
				inner sep=2pt
			},
			accepting/.style={
				state,
				accepting by arrow
			}
}
		
\node[state , accepting, accepting below] (q1) {$q_1$};
		\node[state , initial, above=of q1] (q0) {$q_0$};
		\node[state, accepting, accepting below] (q2) [right=of q1] {$q_2$};
		\node[state] (q3) [right=of q2] {$q_3$};
		
\path[->, thick, >=stealth']
		(q1) edge[above] node {\textcolor{red}{$a,c$}} (q2)
		(q2) edge[above] node {\textcolor{red}{$a$}} (q3)
		(q0) edge[above right] node {\textcolor{red}{$a$}} (q2)
		(q1) edge[loop above] node {$b,e$} ()
		(q0) edge[loop above] node {$c, d, e$} ()
		(q2) edge[loop above] node {$b, c, d, e$} ()
		(q3) edge[loop above] node {$a, b, c,d,e$} ();
		
		\path[->, thick, >=stealth',bend right]
		(q1) edge[right] node {{$d$}} (q0)
		(q0) edge[left] node {{$b$}} (q1);
		
	\end{tikzpicture}
	\caption{An automaton $\Aa_2$ that recognizes the language $L_2 = [((c+d+e)^* b (b+e)^* d)^* a] (b+c+d+e)^*$.}
	\label{fig:series}
	\end{center}
	\end{figure}


	The crucial facts here are that the set $B_2$ of minimal blocking factors of the second SCC is finite and it is a subset of $B_1$: the infinite nature of $B_1$ is made irrelevant because any word far from the language contains many~$a$'s.
	Therefore, $\Aa_2$ has a \emph{single} minimal blocking sequence, $\sigma = (a)$.
\end{example}

\subsubsection{Portals and SCC-paths}

Intuitively, blocking sequences are sequences of blocking factors of successive strongly connected components. To formalize this intuition, we use \emph{portals}, which describe how a run in the automaton interacts with a strongly connected component, and \emph{SCC-paths}, that describe a succession of portals.

In what follows, we fix an NFA $\Aa = (Q, \Sigma, \delta, q_{0}, \set{q_f})$.
We assume w.l.o.g. that $\Aa$ has a unique final state $q_f$.
Let $\SCCset$ be the set of SCCs of $\Aa$.
We define the partial order relation $\leq_\Aa$ on $\SCCset$ by $S \leq_\Aa T$ if and only if $T$ is reachable from $S$.  We write $<_\Aa$ for its strict part $\leq_\Aa \setminus \geq_\Aa$. These relations can be naturally extended to states through their SCC: if $s\in S$ and $t\in T$, then $s\leq_\Aa t$ if and only if $S\leq_\Aa T$.

We define $p$ as the least common multiple of the lengths of all simple cycles of $\Aa$.
Given a number $k \in \ZZ/p\ZZ$, we say that a state $t$ is $k$-reachable from a state $s$ if there is a path from $s$ to $t$ of length $k$ modulo $p$.
In what follows, we use ``positional words'' for $p$-positional words with this value of $p$.

\begin{remark}
	In the rest of this section we will not try to optimize the constants in the formulas. They will, in fact, become quite large in some of the proofs.
	We make this choice to make the proofs more readable, although some of them are already technical.
	
	For instance, the choice of $p$ as the $\lcm$ of the lengths of simple cycles is not optimal: we could use, for instance, the $\lcm$ of the periods of the SCCs.
\end{remark}


\begin{definition}[Portal]
	A \emph{portal} is a 4-tuple $P = \portal{s}{x}{t}{y} \in (Q \times \ZZ/p\ZZ)^2$, such that $s$ and $t$ are in the same SCC. 
	It describes the first and last states visited by a path in an SCC, and the positions $x,y$ (modulo $p$) at which it first and lasts visits that SCC.
\end{definition}


The positional language of a portal is the set \[\timedlanguage{s}{x}{t}{y} = \set{(x:w) \mid s\xrightarrow{w}t \land x+|w| = y \pmod{p}}.\]
Portals were already defined by Alon et al.~\cite{alon2001regular}, in a slightly different way.
Our definition will allow us to express blocking sequences more naturally.

\begin{definition}
	A positional word $\timedword{n}{u}$ is blocking for a portal $P$ if it is not a factor of any word of $\lang{P}$.
	In other words, there is no path that starts in $s$ and ends in $t$, of length $y-x$ modulo $p$, which reads $u$ after $n-x$ steps modulo $p$.
\end{definition}

The above definition matches the definition of blocking factors for strongly connected automata. This is no coincidence: we show in the next lemma that the language of a portal has a strongly connected automaton.
\begin{lemma}\label{lemma:portal-to-SC}
    Let $\Aa$ be an automaton and $P$ a portal of $\Aa$.
    There is a strongly connected NFA with at most $p|\Aa|$ states that recognizes $L' = \lang{P}$.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 12}\end{proof}

Portals describe the behavior of a run inside a single strongly connected component of the automaton.
Next, we introduce SCC-paths, which describe the interaction of a run with multiple SCCs and between two successive SCCs.
\begin{definition}[SCC-path]
	An \emph{SCC-path} $\pi$ of $\Aa$ is a sequence of portals linked by single-letter transitions
	\(\SCCpath = \portal{s_0}{x_0}{t_0}{y_0} \xrightarrow{a_1} \portal{s_1}{x_1}{t_1}{y_1} \cdots  \xrightarrow{a_{k}} \portal{s_k}{x_k}{t_k}{y_k},\)
	such that for all $i \in \set{1, \ldots, k}$,  $x_i = y_{i-1} +1 \pmod{p}$, $t_{i-1}\xrightarrow{a_i} s_{i}$, and $t_{i-1}  <_{\Aa} s_i$.
\end{definition}
Intuitively, an SCC-path is a description of the states and positions at which a path through the automaton enters and leaves each SCC.

\begin{definition}\label{def:lang-of-sccpath}
	The language $\lang{\SCCpath}$ of an SCC-path $\SCCpath = P_0 \xrightarrow{a_1} P_1 \xrightarrow{a_2}\cdots  P_k$ is the set 
	\[\lang{\SCCpath} = \lang{P_0} a_1 \lang{P_2} a_2 \cdots \lang{P_k}.\]
\end{definition}

We say that $\SCCpath$ is \emph{accepting} if $P_0 = \portal{s_0}{x_0}{t_0}{y_0}$, $P_k = \portal{s_k}{x_k}{t_k}{y_k}$ with $x_0 = 0$, $s_0 = q_{0}$, $t_k = q_{f}$ and $\lang{\SCCpath}$ is non-empty.

\begin{lemma}\label{lemma:lang-path-union}
	We have \(\timedlang{\Aa} = \bigcup_{\SCCpath \text{ accepting}} \lang{\SCCpath}.\)
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 13}\end{proof}

As a consequence the distance between a word $\mu$ and the (positional) language of $\Aa$ is equal to the minimum of the distances between $\mu$ and the languages of the SCC-paths of $\Aa$.
\begin{corollary}\label{coro:dist-to-l-path}
	For any positional word $\mu$, we have \[d(\mu, \timedlang{\Aa}) = \min_{\SCCpath \text{ accepting}} d(\mu,\lang{\SCCpath}).\]
\end{corollary}

Decomposing $\Aa$ as a union of SCC-paths allows us to use them as an intermediate step to define blocking sequences.
We earlier defined blocking factors for portals: we now generalize this definition to blocking sequences for SCC-paths, to finally define blocking sequence of automata.

\begin{definition}[(Strongly) Blocking Sequences for SCC-paths]
	We say that a sequence $\sigma = (\mu_1, \ldots, \mu_\ell)$ of positional factors is blocking for an SCC-path 
	$\SCCpath = P_0 \xrightarrow{a_1} \cdots  P_k$ if there is a sequence of indices $i_0 \leq i_1 \leq \cdots \leq i_k$ 
	such that for every $j, \mu_{i_j}$ is blocking for~$P_j$.

	Furthermore, if there is a sequence of indices $i_0 < i_1 < \cdots < i_k$ with the same property, then~$\sigma$ is said to be \emph{strongly blocking} for~$\SCCpath$.
\end{definition}

Note that, crucially, in the definition of blocking sequences, consecutive indices $i_j$ and $i_{j+1}$ can be equal, i.e. a single factor of the sequence may be blocking for multiple consecutive SCCs in the SCC-path. This choice is motivated by \cref{example:hard-to-easy}, where the language is easy because consecutive SCCs share blocking factors.

We say that two occurrences of blocking sequences in a word $\mu$ are \emph{disjoint} if the occurrences of their factors appear on disjoint sets of positions in $\mu$.

In the strongly connected case, we had the property that if $\mu$ contains an occurrence of a factor blocking for $\Aa$, then $\mu$ is not in the language of $\Aa$.
The following lemma gives an extension of this result to \emph{strongly} blocking sequences and the language of an SCC-path.
\begin{lemma}\label{lem:strongly-blocking-implies-not-in-path}
	Let $\SCCpath$ be an SCC-path.
    If $\mu$ contains a strongly blocking sequence for~$\SCCpath$,
    then $\mu \notin \lang{\SCCpath}$.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 14}\end{proof}

We can now define sequences that are blocking for an automaton: they are sequences that are blocking for \emph{every} accepting SCC-path of the automaton.
\begin{definition}[{Blocking sequence for $\Aa$}]
    Let $\sigma = (\mu_1, \ldots, \mu_\ell)$ be a sequence of positional words.
    We say that $\sigma$ is blocking for $\Aa$ if it is blocking for all accepting SCC-paths of~$\Aa$.
\end{definition}
As an example, observe that the sequences $(\timedword{0}{ab}, \timedword{1}{ab})$ and $(\timedword{0}{aa}, \timedword{0}{b})$ are both blocking for the automaton displayed in \cref{fig:SCCpaths} (see \cref{ex:SCCpath}).

\begin{example}
	\label{ex:SCCpath}
	Consider the automaton displayed in \cref{fig:SCCpaths}.
	The $\lcm$ of the lengths of its simple cycles is $p=2$.
	This automaton has six accepting SCC-paths, including
	\begin{align*}
		\pi_1 &= \portal{q_0}{0}{q_0}{0} \xrightarrow{a} \portal{q_1}{1}{q_1}{1} \xrightarrow{a} \portal{q_3}{0}{q_3}{0} \xrightarrow{b} \portal{q_4}{1}{q_4}{1}\\
		\pi_2 &= \portal{q_0}{0}{q_0}{0} \xrightarrow{a} \portal{q_2}{1}{q_1}{0} \xrightarrow{a} \portal{q_3}{1}{q_3}{0} \xrightarrow{b} \portal{q_4}{1}{q_4}{1}
	\end{align*}

	The language of the portal $\pi_1$ is $a(ba)^*a(a^2)^*b$.
	A blocking sequence for this SCC-path is $(\timedword{0}{aa}, \timedword{0}{b})$, which is in fact blocking for all of the SCC-paths.

	\begin{figure}[htbp]
	\begin{center}
	\begin{tikzpicture}[shorten >=1pt, node distance=3cm, on grid, auto,
		every initial by arrow/.style={thick}, every accepting by arrow/.style={thick}, >={stealth'}]
\tikzset{
			state/.style={
				circle,
				thick,
				draw,
				minimum size=8mm,
				inner sep=2pt
			},
			accepting/.style={
				state,
				accepting by arrow
			}
		}
		
\node[state , initial] (q0) {$q_0$};
		\node[state ,right=of q0] (q1) {$q_1$};
		\node[state] (q2) [above=of q1] {$q_2$};
		\node[state] (q3) [right=of q1] {$q_3$};
		\node[state, accepting, accepting right] (q4) [above=of q3] {$q_4$};
		
\path[->, thick, >=stealth']
		(q0) edge[above] node {\textcolor{red}{$a$}} (q1)
		(q0) edge[above left] node {\textcolor{red}{$a$}} (q2)
		(q1) edge[above] node {\textcolor{red}{$a$}} (q3)
		(q2) edge[above] node {\textcolor{red}{$b$}} (q4)
		(q3) edge[right] node {\textcolor{red}{$b$}} (q4)
		(q3) edge[loop right] node {$a$} ();
		
		\path[->, thick, >=stealth',bend right]
		(q1) edge[right] node {{$b$}} (q2)
		(q2) edge[left] node {{$a$}} (q1);
	\end{tikzpicture}
	\caption{Automaton used for \cref{ex:SCCpath}.}
	\label{fig:SCCpaths}
	\end{center}
	\end{figure}

	On the other hand, $(\timedword{0}{ab})$ is not blocking for $\pi_1$, as $\timedword{0}{ab}$ is not a blocking factor for the portal $\portal{q_1}{1}{q_1}{1}$. It is, however, a blocking sequence for $\pi_2$.
	This is because if we enter the SCC $\set{q_1,q_2}$ through $q_1$, a factor $ab$ can only appear after an even number of steps, while if we enter through $q_2$, it can only appear after an odd number of steps.
\end{example}

\subsection{An efficient property tester}\label{sec:generic-ub}

In this section, we show that for any regular language $L$ and any small enough $\eps > 0$, there is an $\eps$-property tester for $L$ that uses $\cO(\epslogeps)$ queries.

\begin{theorem}\label{thm:gen-ub}
    For any NFA $\Aa$ and any small enough $\eps  >0$, there exists an $\eps$-property tester for $\lang{\Aa}$ that uses $\cO(\epslogeps)$ queries. 
\end{theorem}

As mentioned in the overview, this result supersedes the one  given by Bathie and Starikovskaya~\cite{bathie2021property}:
while both testers use the same number of queries, the tester in~\cite{bathie2021property} works under the edit distance, while that of \cref{thm:gen-ub} is designed for the Hamming distance. As the edit distance never exceeds the Hamming distance, the set of words that are $\eps$-far with respect to the former is contained in the set of words $\eps$-far for the latter. Therefore, an $\eps$-tester for the Hamming distance is also an $\eps$-tester for the edit distance, and this result is stronger.

The property tester behind \cref{thm:gen-ub} uses the property tester for strongly connected NFAs as a subroutine, and its correctness is based on an extension of \cref{lemma:many-short-blocking} to blocking sequences.
We show that we can reduce property testing of $\lang{\Aa}$ to a search for blocking sequences in the word, in the following sense:
\begin{itemize}
	\item If $\mu$ contains a strongly blocking sequence for each of the SCC-paths of $\Aa$, then it is not in the language and we can answer no (\cref{cor:many-strongly-bs-implies-not-A}).
	\item If $\mu$ is $\eps$-far from the language, then for each accepting SCC-path $\SCCpath$ of $\Aa$, $\mu$ is far from for the language of $\SCCpath$ and contains many disjoint strongly blocking sequences for $\SCCpath$ (\cref{lem:far-from-path-implies-many-blocking}), hence random sampling is likely to find at least one of them, and we reject $\mu$ with constant probability.
\end{itemize}

\begin{corollary}
	\label{cor:many-strongly-bs-implies-not-A}
	If $\mu$ contains a strongly blocking sequence for each SCC-path of~$\Aa$, then $\mu \notin \timedlang{\Aa}$.
\end{corollary}
\begin{proof}\textcolor{red}{TOPROVE 15}\end{proof}

The next lemma expresses a partial converse to \cref{cor:many-strongly-bs-implies-not-A} and generalizes \cref{lemma:many-blocking} from the strongly connected case: if a word is far from the language, then it contains many strongly blocking sequences for any SCC-path.
\begin{lemma}
    \label{lem:far-from-path-implies-many-blocking}
    Let $\SCCpath  = P_0 \xrightarrow{a_1} \cdots  P_k$ be an SCC-path, let $L = \lang{\SCCpath}$, and let $\mu$ be a positional word of length $n$ such that $d(\mu, L)$ is finite.
    There is a constant $C$ such that if $n \geq C/\eps$
    and $\mu$ is $\eps$-far from $L$, then $\mu$ can be partitioned into $\mu = \mu_0\mu_1\cdots\mu_k$ such that for every $i = 0,\ldots, k$,
    $\mu_i$ contains at least $\frac{\eps n}{C}$ disjoint blocking factors for~$P_i$, each of length at most $\cO(1/\eps)$.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 16}\end{proof}

\begin{corollary}\label{cor:far-L-many-bs}
	Let $L = \timedlang{\Aa}$ and let $\mu$ be a positional word of length $n$.
	If $L$ contains a word of length $n$ and $\mu$ is $\eps$-far from $L$,
	then $\mu$ contains $\Omega(\eps n)$ disjoint blocking sequences for $\Aa$.
\end{corollary}
\begin{proof}\textcolor{red}{TOPROVE 17}\end{proof}

We are now ready to prove \cref{thm:gen-ub}.
\begin{proof}\textcolor{red}{TOPROVE 18}\end{proof}



\subsection{Lower bound}

In order to characterize hard languages for all automata, we define a partial order $\pobs$ on sequences of positional factors.
It is an extension of the factor partial order on blocking factors. 
It will let us define \emph{minimal blocking sequences}, which we use to characterize the complexity of testing a language. 

\begin{definition}[Minimal blocking sequence]\label{def:MBS}
	Let $\sigma = (\mu_1, \mu_2, \ldots, \mu_k)$ and $\sigma' =  (\mu_1',\ldots, \mu_{t}')$ be sequences of positional words.
	We have $\sigma \pobs \sigma'$ if there exists a sequence of indices $i_1 \leq i_2 \leq \ldots \leq i_k$ such that $\mu_{j}$ is a factor of $\mu_{i_j}'$ for all $j = 1,\ldots, k$.
	
	A blocking sequence $\sigma$ of $\Aa$ (resp. $\SCCpath$) is \emph{minimal} if it is a minimal element of $\pobs$ among blocking sequences of $\Aa$ (resp. $\SCCpath$). The set of minimal blocking sequences of $\Aa$ (resp. $\SCCpath$) is written $\MBS(\Aa)$ (resp. $\MBS(\SCCpath)$).
\end{definition}

\begin{remark}
	If $\sigma \pobs \sigma'$ and $\sigma$ is a blocking sequence for an SCC-path $\pi$ then $\sigma'$ is also a blocking sequence for $\pi$.
\end{remark}

We make the remark that minimal blocking sequences have a bounded number of terms. This is because if we build the sequence from left to right by adding terms one by one, the minimality implies that at each step we should block a previously unblocked portal.
\begin{lemma}
    \label{lem:bound-length-min-blocking}
    A minimal blocking sequence for $\Aa$ contains at most $p^2|Q|^2$ terms.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 19}\end{proof}

\subsubsection{Reducing to the strongly connected case}

To prove a lower bound on the number of queries necessary to test a language when $\MBS(\Aa)$ is infinite, we present a reduction to the strongly connected case.
Under the assumption that $\Aa$ has infinitely many minimal blocking sequences, we exhibit a portal $P$ of $\Aa$ with infinitely many minimal blocking factors and ``isolate it'' by constructing two sequences of positional factors $\sigma_l$ and $\sigma_r$ such that for all $\mu$, $\sigma_l, (\mu), \sigma_r$ is blocking for $\Aa$ if and only if $\mu$ is a blocking factor of $P$.
Then we reduce the problem of testing the language of this portal to the problem of testing the language of $P$.

To define ``isolating $P$'' formally, we define the left (and right) effect of a sequence on an SCC-path.
Informally, the left effect of a sequence $\sigma$ on an SCC-path $\SCCpath$ is related to the index of the first portal in $\SCCpath$ where a run can be after reading $\sigma$, because all previous portals have been blocked. 
The right effect represents the same in reverse, starting from the end of the run.

More formally, the \emph{left effect} of a sequence $\sigma$ on an SCC-path $\SCCpath = P_0 \xrightarrow{a_1} \cdots P_k$ is the largest index $i$ such that the sequence is blocking for $P_0 \xrightarrow{a_1} \cdots P_i$ ($-1$ if there is no such~$i$). We denote it by $\lefteffect{\sigma}{\SCCpath}$.
Similarly, the \emph{right effect} of a sequence on $\pi$ is the smallest index~$i$ such that the sequence is blocking for $P_i \xrightarrow{a_{i+1}} \cdots P_k$  ($k+1$ if there is no such~$i$); we denote it by $\righteffect{\sigma}{\pi}$.

\begin{remark}
	A sequence $\sigma$ is blocking for an SCC-path $\SCCpath = P_0 \xrightarrow{a_1} \cdots  P_k$ if and only if $\lefteffect{\sigma}{\SCCpath} = k$, if and only if $\righteffect{\sigma}{\SCCpath} = 0$.
	
	Also, given two sequences $\sigma_l, \sigma_r$, the sequence $\sigma_l \sigma_r$ is blocking for $\SCCpath$ if and only if $\lefteffect{\sigma_l}{\SCCpath} \ge \righteffect{\sigma_r}{\SCCpath}$.
\end{remark}

For the next lemma we define a partial order on portals:
$P \leqportals P'$ if all blocking factors of $P'$ are also blocking factors of $P$.
We write $\geqportals$ for the reverse relation, $\equivportals$ for the equivalence relation $\leqportals \cap \geqportals$ and $\nequivportals$ for the complement relation of $\equivportals$.

Additionally, given an SCC-path~$\SCCpath = P_0\xrightarrow{x_1} \ldots P_k$ and two sequences of positional words $\sigma_l, \sigma_r$, we say that the portal $P_i$ \emph{survives $(\sigma_l, \sigma_r)$ in $\SCCpath$} if $\lefteffect{\sigma_l}{\SCCpath} < i < \righteffect{\sigma_r}{\SCCpath}$.

\begin{definition}
	Let $P$ be a portal and  $\sigma_l$ and $\sigma_r$ sequences of positional words.
	
	We define three properties that those objects may have:
	\begin{description}\item[P1)] $\sigma_l \sigma_r$ is not blocking for $\Aa$
		\item[P2)] $P$ has infinitely many minimal blocking factors
		\item[P3)] for any accepting SCC-path $\SCCpath$ in $\Aa$, 
		every portal in $\SCCpath$ which survives $(\sigma_l, \sigma_r)$ is $\equivportals$-equivalent to $P$.
	\end{description}
\end{definition}

\begin{restatable}{lemma}{HardAutHardPortal}
	\label{lem:hard-aut-to-hard-portal}
	If $\Aa$ has infinitely many minimal blocking sequences, then there exist a portal $P$ and sequences $\sigma_l$ and $\sigma_r$ satisfying properties P1, P2 and P3.
\end{restatable}
\begin{proof}\textcolor{red}{TOPROVE 20}\end{proof}

\begin{lemma}
	\label{lem:seq-left}
	Let $\SCCpath = P_0 \xrightarrow{a_1} \cdots  P_\ell$ be an accepting SCC-path,
	denote $P_j = \portal{s_j}{x_j}{t_j}{y_j}$ for each $j = 0,\ldots,\ell$,
	let $i \in \set{0, \ldots, \ell}$,
	and let $\sigma_l = (\nu_{1,l}, \ldots, \nu_{k,l})$ be a sequence such that $\lefteffect{\sigma_l}{\SCCpath} < i$.

	Then, for any integer $N \in \NN$, there is a positional word $w_l^*$ of length at most $(3|\Aa|^3+|\Aa|)(k+1)  + N(2p^2+p)k|\Aa| + pN\sum_{t=1}^k|\nu_{t,l}|$ such that $|w_l^*| = x_i-x_0 \pmod{p}$, there is a run reading $w_l^*$ from $s_0$ to $s_i$ in $\Aa$, and $\timedword{x_0}{w_l^*}$ contains $N$ occurrences of $\nu_{1,l}$, followed by $N$ occurrences of $\nu_{2,l}$, etc. up to $\nu_{k,l}$, all disjoint.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 21}\end{proof}

\begin{lemma}
	\label{lem:seq-right}
	Let $\SCCpath = P_0 \xrightarrow{a_1} \cdots  P_\ell$ be an accepting SCC-path,
	denote $P_j = \portal{s_j}{x_j}{t_j}{y_j}$ for each $j = 0,\ldots,\ell$,
	let $i \in \set{0, \ldots, \ell}$,
	and let $\sigma_r = (\nu_{1,r}, \ldots, \nu_{k,r})$ be a sequence such that $\lefteffect{\sigma_l}{\SCCpath} < i$.

	Then, for any integer $N \in \NN$, there is a word $w_r^*$ of length at most $(3|\Aa|^3+|\Aa|)(k+1)  + N(2p^2+p)k|\Aa| + pN\sum_{i=1}^k|\nu_{i,r}|$ such that $|w_r^*| = x_i-x_0 \pmod{p}$, there is a run reading $w_r^*$ from $s_0$ to $s_i$ in $\Aa$, and $\timedword{x_0}{w_r^*}$ contains $N$ occurrences of $\nu_{1,r}$, followed by $N$ occurrence of $\nu_{2,r}$, etc. up to $\nu_{k,r}$, all disjoint.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 22}\end{proof}


Given a sequence $\sigma$, define $\sigmasize{\sigma}$ as the sum of the lengths of the terms of $\sigma$.
\begin{restatable}{lemma}{PropertiesImpliesHard}
	\label{lem:P1-P3-then-hard}
	If there exist a portal $P$ and $\sigma_l$, $\sigma_r$ satisfying properties P1, P2 and P3 then $\lang{\Aa}$  is hard.
\end{restatable}
\begin{proof}\textcolor{red}{TOPROVE 23}\end{proof}

\begin{proposition}
		If $\Aa$ has infinitely many minimal blocking sequences, 
		then $\lang{\Aa}$ is hard.
\end{proposition}
\begin{proof}\textcolor{red}{TOPROVE 24}\end{proof} 
\section{Trivial and Easy languages}
\label{sec:trivial-easy}
\subsection{Upper bound for easy languages}

We first establish that an automaton with finitely many minimal blocking sequences is easy (or trivial) to test.

\begin{lemma}\label{lem:far-bounded-mbs}
	Let $\Aa$ be an NFA with a finite number of minimal blocking sequences,
    let~$\SCCpath  = P_0 \xrightarrow{a_1} \cdots  P_k$ be an SCC-path of $\Aa$, let $L = \lang{\SCCpath}$, and let $\mu$ be a positional word of length $n$ such that $d(\mu, L)$ is finite.
    There are constants $B, D$ such that if $n \geq 2D/\eps$
    and $\mu$ is $\eps$-far from $L$, then $\mu$ can be partitioned into $\mu = \tau_0\tau_1\cdots\tau_k$ such that for every $i = 0,\ldots, k$,
    $\tau_i$ contains at least $\frac{\eps n}{D}$ disjoint blocking factors for~$P_i$, each of length at most~$B$.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 25}\end{proof}

\begin{proposition}
	\label{coro:fin-bs-then-easy}
	If $\Aa$ has finitely many minimal blocking sequences, then there is a tester for $\lang{\Aa}$ that uses $\cO(1/\eps)$ queries.
\end{proposition}
\begin{proof}\textcolor{red}{TOPROVE 26}\end{proof}

This already gives us a clear dichotomy: all languages either require $\Theta(\epslogeps)$ queries to be tested, or can be tested with $\cO(1/\eps)$ queries.


\subsection{Separation between trivial and easy languages}

It remains to show that languages that can be tested with $\cO(1/\eps)$ queries have query complexity either $\Theta(1/\eps)$, or $0$ for large enough $n$.
Our proof uses the class of \emph{trivial} regular languages identified by Alon et al.~\cite{alon2001regular}, which we revisit next.

An example of a trivial language is $L_2$ consisting of words containing at least one $a$ over the alphabet $\set{a,b}$.
For any word $u$, replacing any letter by $a$ yields a word in $L_2$, hence $d(u,L_2) \le 1$.
Therefore, for $n > 1/\eps$, no word of length $n$ is $\eps$-far from $L_2$, and the trivial property tester that answers ``yes'' without sampling any letter is correct.

Alon et al.~\cite{alon2001regular} define non-trivial languages as follows.
\begin{restatable}[{\cite[Definition 3.1]{alon2001regular}}]{definition}{trivialalondef}\label{def:trivial-alon}
	A language~$L$ is non-trivial if there exists a constant $\eps_0 > 0$, so that for infinitely
	many values of $n$ the set $L\cap\Sigma^n$ is non-empty, and there exists a word $w \in \Sigma^n$ so that $d(w, L) \ge \eps_0 n$.
\end{restatable}
It is easy to see that if a language is trivial in the above sense (i.e. not non-trivial), then for large enough input length $n$, the answer to testing membership in~$L$ only depends $n$, and the algorithm does not need to query the input.
Alon et al.~\cite[Property 2]{alon2001regular} show that if a language is non-trivial, then testing it requires $\Omega(1/\eps)$ queries for small enough $\eps > 0$.

To obtain our characterization of \emph{trivial} languages, we show that $\MBS(\Aa)$ is non-empty if and only if $\lang{\Aa}$ is non-trivial (in the above sense).
It follows that if $\MBS(\Aa)$ is empty, then testing $\lang{\Aa}$ requires $0$ queries for large enough $n$.
Furthermore, by the result of Alon et al.~\cite{alon2001regular}, if $\MBS(\Aa)$ is non-empty, then testing $\lang{\Aa}$ requires $\Omega(1/\eps)$ queries.

Recall that we focus on infinite languages, since we know that all finite ones are trivial (Remark~\ref{rmk:finite}). 
\begin{lemma}\label{lem:trivialiffMBSempty}
	$\MBS(\Aa)$ is empty if and only if $L = \lang{\Aa}$ is trivial.
\end{lemma}

We prove the two directions separately.
\begin{lemma}
	If $\MBS(\Aa)$ is empty, then $L = \lang{\Aa}$ is trivial in the sense of \cref{def:trivial-alon}.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 27}\end{proof}

To prove the converse property, we need the following extension of Kleene's Lemma for languages of SCC-paths: for large enough~$\ell$, whether $\lang{\SCCpath}$ contains a word of length~$\ell$ only depends on the value of~$\ell$ modulo~$p$ ($p$ is the $\lcm$ of all the lengths of the simple cycles in $\Aa$).
\begin{lemma}
    Let $\SCCpath = P_0 \xrightarrow{a_1} \cdots P_k$ be an SCC-path.
    There exists a constant $B $ such that, for all $\ell \ge B$, if there is a word $\mu$ of length~$\ell$ in $\lang{\SCCpath}$,
    then there exists a word $\mu'$ of length  $\ell - p$  and a word $\mu''$ of length  $\ell + p$ in $\lang{\SCCpath}$.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 28}\end{proof}
\begin{corollary}\label{lem:fin-dist-iff-modulo}
    Let $\SCCpath$ be an SCC path.
    For large enough $\ell$, whether there is an word of length $\ell$ in $\lang{\SCCpath}$ only depends on the value of $\ell \pmod{p}$.
\end{corollary}

To finish our characterization of trivial languages, we show that if $\MBS(\Aa)$ is not empty, then $L = \lang{\Aa}$ is non-trivial in the sense of Alon et al.~\cite{alon2001regular}.
\begin{lemma}
	\label{lem:charac-trivial}
	Let $\Aa$ be a trim NFA such that $L = \lang{\Aa}$ is infinite.
	If $\Aa$ admits a blocking sequence,
	then there exists $\eps_0 > 0$, such that for infinitely many $n$ there exist words in $\lang{\Aa} \cap \Sigma^n$ and there exists $w \in \Sigma^n$ such that $d(w,\lang{\Aa})\geq \eps_0 n$
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 29}\end{proof}

It is easy to see that if a language is trivial in the above sense, then for large enough input length $n$, membership in~$L$ only depends $n$, and the algorithm does not need to query the input.
Alon et al.~\cite{alon2001regular} show that if a language is non-trivial, then testing it requires $\Omega(1/\eps)$ queries for small enough $\eps > 0$.
As a corollary of that lower bound, we obtain that if $\MBS(\Aa)$ is non-empty, then testing $\lang{\Aa}$ requires $\Omega(1/\eps)$ queries.
 

\section{Hardness of classifying}
\label{sec:complexity}
In the previous sections, we have shown that testing some regular languages (\emph{easy} ones) that requires fewer queries than testing others (\emph{hard} ones).
Therefore, given the task of testing a word for membership in $\lang{\Aa}$,
it is natural to first try to determine if the language of $\Aa$ is easy, and if this is the case, run the appropriate $\eps$-tester, that uses fewer queries.
In this section, we investigate the computational complexity of checking which class of the trichotomy the language of a given automaton belongs to.
We formalize this question as the following decision problems:

\begin{problem}[Triviality problem]
	Given an finite automaton $\Aa$, is $\lang{\Aa}$ trivial?
\end{problem}
\begin{problem}[Easiness problem]
	Given an finite automaton $\Aa$, is $\lang{\Aa}$ easy?
\end{problem}
\begin{problem}[Hardness problem]
	Given an finite automaton $\Aa$, is $\lang{\Aa}$ hard?
\end{problem}

In these problems, the automaton $\Aa$ is the input and is no longer fixed.
We show that, our combinatorial characterization based on minimal blocking sequences is effective, in the sense that all three problems are decidable. However, it does not lead to efficient algorithms, as both problems are \PSPACE-complete.

\begin{theorem}\label{thm:PSPACE-main}
	The triviality and easiness problems are both \PSPACE-complete, even for strongly connected NFAs.
\end{theorem}

In \cref{sec:ppace-ub} we show the \PSPACE upper bounds on the hardness and triviality problems (Propositions~\ref{prop:hard-to-test-PSPACE} and~\ref{prop:trivial-PSPACE}). The upper bound on the easiness problem follows immediately, as the three properties form a trichotomy.

In \cref{sec:pspace-hard}, we show that all three problems are \PSPACE-hard (\cref{lemma:trivial-complexity} and \cref{cor:hardness-easy}).

\subsection{A $\PSPACE$ upper-bound}\label{sec:ppace-ub}

\subsubsection{Testing hardness}

A naive algorithm to check hardness of a language $\lang{\Aa}$ would be to construct an automaton recognising blocking sequences of $\lang{\Aa}$ (exponential in $\Aa$), and use it to get an automaton recognising the minimal ones (which requires complementation and could yield another exponential blow-up). This would a priori not give a \PSPACE algorithm, since we obtain a doubly-exponential state space.
We solve this by providing another characterisation of automata with hard languages, resulting in a recursive \PSPACE algorithm to test it.


\begin{lemma}
	\label{lem:uniformisation-blocking-seq}
	Let $\SCCpath = P_0 \xrightarrow{a_1} \cdots  P_\ell$ be an SCC-path, $i$ an index, $\Pi$ a set of SCC-paths and $(\sigma_{\SCCpath'})_{\SCCpath' \in \Pi}$ a family of sequences of positional words such that $\lefteffect{\sigma_{\SCCpath'}}{\SCCpath} < i$ for all $\SCCpath'$.
	
	There exists a sequence of positional words $\sigma$ such that:
	\begin{itemize}
		\item $\lefteffect{\sigma}{\pi} < i$
		\item $\lefteffect{\sigma_{\SCCpath'}}{\SCCpath'} \leq \lefteffect{\sigma}{\SCCpath'}$ for all $\SCCpath' \in \Pi$.
	\end{itemize}
\end{lemma}

\begin{proof}\textcolor{red}{TOPROVE 30}\end{proof}

\begin{lemma}\label{lem:charac-hard-PSPACE}
	An automaton $\Aa$ is hard if and only if there exists an accepting SCC-path $\SCCpath$ containing a portal $P$ such that:
	\begin{itemize}
		\item $P$ has infinitely many minimal blocking factors.
		\item For any accepting SCC-path $\SCCpath'$ there exist sequences $\sigma_{l, \SCCpath'}, \sigma_{r, \SCCpath'}$ such that: 
		\begin{itemize}
			\item $P$ survives $(\sigma_{l, \SCCpath'}, \sigma_{r, \SCCpath'})$ in $\SCCpath$
			\item All portals surviving $(\sigma_{l, \SCCpath'}, \sigma_{r, \SCCpath'})$ in $\SCCpath'$ are $\equivportals$-equivalent to $P$
		\end{itemize} 
	\end{itemize} 
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 31}\end{proof}

Next, we establish that the items listed in the previous lemma can all be checked in polynomial space in $|\Aa|$.

\begin{lemma}
	\label{lem:aut-block-fact}
	Given a portal $P$, we can check whether it has infinitely many minimal blocking factors in space polynomial in $|\Aa|$.
\end{lemma}

\begin{proof}\textcolor{red}{TOPROVE 32}\end{proof}

\begin{lemma}
	\label{lem:PSPACE-blocking-for-one}
	Given two SCC-paths $\SCCpath$ and $\SCCpath'$, one can check in \PSPACE whether there is a sequence $\sigma$ that is blocking for $\SCCpath$ and not $\SCCpath'$.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 33}\end{proof}

\begin{proposition}
	\label{prop:hard-to-test-PSPACE}
	The hardness problem is in \PSPACE.
\end{proposition}
\begin{proof}\textcolor{red}{TOPROVE 34}\end{proof}


\subsubsection{Testing triviality}

We show the \PSPACE upper bound on the complexity of checking if a language is trivial.
It is based on the characterisation of trivial languages given by \cref{lem:charac-trivial}, and uses the following result.

\begin{lemma}
	\label{lem:exists-blocking-fact}
	Given a portal $P$, we can check whether it has a blocking factor in space polynomial in $|\Aa|$.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 35}\end{proof}


\begin{proposition}\label{prop:trivial-PSPACE}
	The triviality problem is in \PSPACE.
\end{proposition}
\begin{proof}\textcolor{red}{TOPROVE 36}\end{proof}


\subsection{Hardness of classifying automata}\label{sec:pspace-hard}

We prove hardness of the triviality problem and easiness problems, concluding on their \PSPACE-completeness.
We reduce from the universality problem for NFAs, which is well-known to be \PSPACE-complete (see e.g.~\cite[Theorem 10.14]{aho1974design}).

\begin{lemma}\label{lemma:trivial-complexity}
	The triviality and hardness problems are \PSPACE-hard.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 37}\end{proof}

The above proof can be extended to show the \PSPACE-hardness of the easiness problem.
\begin{corollary}\label{cor:hardness-easy}
	The easiness problem is \PSPACE-hard.
\end{corollary}
\begin{proof}\textcolor{red}{TOPROVE 38}\end{proof}

This concludes the proof of \cref{thm:PSPACE-main} 



\section{Conclusion}
We presented an effective classification of regular languages in three classes, each associated with an optimal query complexity for property testing.
We thus close a line of research aiming to determine the optimal complexity of regular languages.
All our results are with respect to the Hamming distance. We conjecture that they can be adapted to the edit distance.
We use non-deterministic automata to represent regular languages. 
A natural open question is the complexity of classifying languages represented by \emph{deterministic} automata.

\bibliography{biblio}


\newpage















\end{document}