\documentclass[letterpaper, USenglish, cleveref, autoref, thm-restate, numberwithinsect]{lipics-v2021}


\pdfoutput=1 \hideLIPIcs  



\bibliographystyle{plainurl}

\title{The Trichotomy of Regular Property Testing}

\author{Gabriel {Bathie}}{LaBRI, Université de Bordeaux \and DIENS, Paris, France \and \url{https://perso.ens-lyon.fr/gabriel.bathie}}{gabriel.bathie@labri.fr}{}{Partially funded by the grant ANR-20-CE48-0001 from the French National Research Agency.}

\author{Nathanaël Fijalkow}{LaBRI, CNRS, Université de Bordeaux, France \and \url{https://games-automata-play.com/}}{nathanael.fijalkow@gmail.com}{}{}
\author{Corto Mascle}{LaBRI, Université de Bordeaux, France \and MPI-SWS, Kaiserslautern, Germany \and \url{https://corto-mascle.github.io/}}{corto.mascle@labri.fr}{}{}



\authorrunning{G. Bathie and N. Fijalkow and C. Mascle} 

\Copyright{Gabriel Bathie and Nathanaël Fijalkow and Corto Mascle} 

\ccsdesc[500]{Theory of computation~Regular languages} 

\keywords{property testing, regular languages} 

\category{} 

\relatedversion{} 







\nolinenumbers 



\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}



\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{mathrsfs}
\usepackage{centernot}
\usepackage{todonotes}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{xspace}
\usepackage{ifthen}
\usepackage{tcolorbox}
\usepackage{tikz}
\usetikzlibrary{automata,arrows,arrows.meta,decorations,shapes.geometric,patterns}

\tikzset{
node distance=1cm, every state/.style={thick}, initial text=$ $, }

\theoremstyle{theorem}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{property}[theorem]{Property}
\theoremstyle{definition}
\newtheorem{problem}[theorem]{Problem}

\DeclareMathOperator{\polylog}{polylog}
\DeclareMathOperator{\poly}{poly}
\newcommand{\Aa}{\mathcal{A}}
\newcommand{\Bb}{\mathcal{B}}
\newcommand{\bit}{\{0, 1\}}
\newcommand{\Cc}{\mathcal{C}}
\newcommand{\Ot}{\tilde{O}}
\newcommand{\cO}{\mathcal{O}}
\newcommand{\curly}{\mathrel{\leadsto}}
\newcommand{\dd}{.\,.}
\newcommand{\Dd}{\mathcal{D}}
\newcommand{\EE}{\mathbb{E}}
\newcommand{\emptyw}{\gamma}
\newcommand{\eps}{\varepsilon}
\newcommand{\equivportals}{\simeq}
\newcommand{\factor}{\preccurlyeq}
\newcommand{\Ff}{\mathcal{F}}
\newcommand{\geqportals}{\succeq}
\newcommand{\lang}[1]{\mathcal{L}(#1)}
\newcommand{\lcm}{\mathsf{lcm}}
\newcommand{\lefteffect}[2]{(#1 \gg #2)}
\newcommand{\leqportals}{\preceq}
\newcommand{\Ll}{\mathcal{L}}
\newcommand{\lneqportals}{\prec}
\newcommand{\MBF}{\textsf{MBF}\xspace}
\newcommand{\MBS}{\textsf{MBS}\xspace}
\newcommand{\Mm}{\mathcal{M}}
\newcommand{\nequivportals}{\not\simeq}
\newcommand{\NL}{\textsf{NL}\xspace}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\NP}{\textsf{NP}\xspace}
\newcommand{\pobs}{\trianglelefteq}
\newcommand{\portal}[4]{#1,#2 \curly #3, #4}
\newcommand{\pow}[1]{2^{#1}}
\newcommand{\PP}{\mathbb{P}}
\newcommand{\Pp}{\mathcal{P}}
\newcommand{\PSPACE}{\textsf{PSPACE}\xspace}
\newcommand{\righteffect}[2]{(#2 \ll #1)}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\Ss}{\mathcal{S}}
\newcommand{\SCCpath}{\pi}
\newcommand{\SCCset}{\mathscr{S}}
\newcommand{\set}[1]{\{ #1 \}}
\newcommand{\sigmasize}[1]{|| #1 ||}
\newcommand{\size}[1]{|#1|}
\newcommand{\timedA}{\widehat{\Aa}}
\newcommand{\timedlanguage}[4]{\mathcal{L}(\portal{#1}{#2}{#3}{#4})}
\newcommand{\timedlang}[1]{\mathcal{TL}( #1 )}
\newcommand{\timedword}[2]{(#1:#2)}
\newcommand{\Tt}{\mathcal{T}}
\newcommand{\twu}{\timedword{0}{u}}
\newcommand{\Uu}{\mathcal{U}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\Prob}[2][]{\ifthenelse{\equal{#1}{}}{\PP}{\PP_{ #1 }}\left( #2 \right)}
\newcommand{\epslogeps}[1][]
{\ifthenelse{\equal{#1}{}}{\log(\eps^{-1})/\eps}{\log^{ #1 }(\eps^{-1})/\eps}}



\ifdefined\PhD
\newcommand{\doc}{chapter\xspace}
\else
\newcommand{\doc}{article\xspace}
\fi

\newcommand{\corto}[1]{\todo[color= yellow]{\textbf{C:} #1}}
\newcommand{\cortoinline}[1]{\todo[inline, color= yellow]{\textbf{C:} #1}}

\newcommand{\gabriel}[1]{\todo[color= blue!40]{\textbf{G:} #1}}
\newcommand{\gabrielinline}[1]{\todo[inline, color= blue!40]{\textbf{G:} #1}}

\newcommand{\nathinline}[1]{\todo[inline, color= red!40]{\textbf{N:} #1}}

\begin{document}
	
	
\maketitle
\begin{abstract}
Property testing is concerned with the design of algorithms making a sublinear number of queries to distinguish whether the input satisfies a given property or is far from having this property. A seminal paper of Alon, Krivelevich, Newman, and Szegedy in 2001 introduced property testing of formal languages: the goal is to determine whether an input word belongs to a given language, or is far from any word in that language. They constructed the first property testing algorithm for the class of all regular languages. This opened a line of work with improved complexity results and applications to streaming algorithms. In this work, we show a trichotomy result: the class of regular languages can be divided into three classes, each associated with an optimal query complexity. 
Our analysis yields effective characterizations for all three classes using so-called minimal blocking sequences, reasoning directly and combinatorially on automata.

 \end{abstract}

\section{Introduction}
Property testing was introduced by Goldreich, Goldwasser and Ron~\cite{goldreich1998property} in 1998: it is the study of randomized approximate decision procedures that must distinguishing objects that have a given property from those that are \emph{far} from having it. 
Because of this relaxation on the specification, the field focuses on very efficient decision procedures, typically with sublinear (or even constant) running time -- in particular, the algorithm does not even have the time to read the whole input.

In a seminal paper, Alon et al.~\cite{alon2001regular} introduced property testing of formal languages: given a language $L$ of finite words, the goal is to determine whether an input word $u$ belongs to the language or is $\eps$-far\footnote{Informally, $u$ is $\eps$-far from $L$ means that even by changing an $\eps$-fraction of the letters of $u$, we cannot obtain a word in $L$. See \cref{sec:preliminaries} for a formal definition.} from it, where $\eps$ is the precision parameter.
The model assumes random access to the input word: a \emph{query} specifies a position in the word and asks for the letter at that position, and the \emph{query complexity} of the algorithm is the worst-case number of queries it makes to the input.
Alon et al.~\cite{alon2001regular} showed a surprising result: under the Hamming distance, all regular languages are testable with $\cO(\epslogeps[3])$ queries, where the $\cO(\cdot)$ notation hides constants that depend on the language, but, crucially, not on the length of the input word.
In that paper, they also identified the class of \emph{trivial} regular languages, those for which the answer is always \emph{yes} or always \emph{no} for sufficiently large $n$, e.g. finite languages or the set of words starting with an $a$, and showed that testing membership in a \emph{non-trivial} regular language requires $\Omega(1/\eps)$ queries.

The results of Alon et al.~\cite{alon2001regular} leave a multiplicative gap of $\cO(\log^3(1/\eps))$ between the best upper and lower bounds.
We set out to improve our understanding of property testing of regular languages by closing this gap.
Bathie and Starikovskaya obtained in 2021~\cite{bathie2021property} the first improvement over the result of Alon et al.~\cite{alon2001regular} in more than 20 years:
\begin{fact}[{From \cite[Theorem 5]{bathie2021property}}]
    Under the edit distance, every regular language can be tested with $\cO(\epslogeps)$ queries.
\end{fact}
Testers under the edit distance are weaker than testers under the Hamming distance, hence this result does not exactly improve the result of Alon et al.~\cite{alon2001regular}. We overcome this shortcoming later in this \doc: \cref{thm:gen-ub} extends the above result to the case of the Hamming distance.

Bathie and Starikovskaya~\cite{bathie2021property} also showed that this upper bound is tight, in the sense that there is a regular language $L_0$ for which this complexity cannot be further improved, thereby closing the query complexity gap.
\begin{fact}[{From \cite[Theorem 15]{bathie2021property}}]
    There is a regular language $L_0$ with query complexity $\Omega(\epslogeps)$ under the edit distance\footnote{Note that, as opposed to testers, lower bounds for the edit distance are stronger than lower bounds of the Hamming distance.}, for all small enough $\eps > 0$.
\end{fact}
Furthermore, it is easy to find specific non-trivial regular languages for which there is an algorithm using only $\cO(1/\eps)$ queries, e.g. $L = a^*$ over the alphabet $\{a,b\}$, $L = (ab)^*$ or $L = (aa + bb)^*$.

Hence, these results combined with those of Alon et al.~\cite{alon2001regular} show that there exist trivial languages (that require 0 queries for large enough $n$), \emph{easy} languages (with query complexity $\Theta(1/\eps)$) and \emph{hard} languages (with query complexity $\Theta(\epslogeps)$).
This raises the question of whether there exist languages with a different query complexity (e.g. $\Theta(\log\log(\eps^{-1})/\eps)$), or if every regular is either trivial, easy or hard.
This further asks the question of giving a characterization of the languages that belong to each class, inspired by the recent success of exact characterizations of the complexity of sliding window~\cite{GanardiHL18} recognition and dynamic membership~\cite{amarilli2021dynamic} of regular languages.

In this \doc, we answer both questions: we show a trichotomy of the complexity of testing regular languages under the Hamming distance\footnote{We consider one-sided error testers, also called testing with perfect completeness, see definitions below.}, showing that there are only the three aforementioned complexity classes (trivial, easy and hard), we give a characterization of all three classes using a combinatorial object called \emph{blocking sequences}, and show that this characterization can be decided in polynomial space (and that it is complete for \PSPACE).
This trichotomy theorem closes a line of work on improving query complexity for property testers and identifying easier subclasses of regular languages. 



\subsection{Related work}

A very active branch of property testing focuses on graph properties, for instance one can test whether a given graph appears as a subgraph~\cite{AlonDLRY94} or as an induced subgraph~\cite{alon2000efficient}, and more generally every monotone graph property can be tested with one-sided error~\cite{AlonS08a}. Other families of objects heavily studied under this algorithmic paradigm include probabilistic distributions~\cite{paninski2008coincidence,diakonikolas2016new} combined with privacy constraints~\cite{Aliakbarpour2018DifferentiallyPI},
numerical functions~\cite{blum1990self, rubinfeld1996robust}, and programs~\cite{ergun1998spot,dodis1999improved}.
We refer to the book of Goldreich~\cite{goldreich2017introduction} for an overview of the field of property testing.

\subparagraph*{Testing formal languages.} Building upon the seminal work of Alon et al.~\cite{alon2001regular}, Magniez et al.~\cite{magniez2007property} gave a tester using $\cO(\epslogeps[2])$ queries for regular languages under the edit distance with moves, and François et al.~\cite{francois_et_al:LIPIcs:2016:6355} gave a tester using $\cO(1/\eps^2)$ queries for the case of the weighted edit distance.
Alon et al.~\cite{alon2001regular} also show that context-free languages cannot be tested with a constant number of queries, and subsequent work has considered testing specific context-free languages such as the \textsc{Dyck} languages~\cite{parnas2003testing,fischer2018improved} or regular tree languages~\cite{magniez2007property}.
Property testing of formal languages has been investigated in other settings: Ganardi et al.~\cite{ganardi2019sliding} studied the question of testing regular languages in the so-called ``sliding window model'', while others considered property testing for subclasses of context-free languages in the streaming model: Visibly Pushdown languages~\cite{francois_et_al:LIPIcs:2016:6355}, \textsc{Dyck} languages~\cite{JN14,Krebs,MagniezMN14} or $\mathsf{DLIN}$ and $\mathsf{LL}(k)$~\cite{BabuLRV13}.
A recent application of property testing of regular languages was to detect race conditions in execution traces of distributed systems~\cite{ThokairZMV23}.
 
\subsection{Main result and overview of the paper}
We start with a high-level presentation of the approach, main result, and key ideas. In this section we assume familiarity with standard notions such as finite automata; we will detail notations in \cref{sec:preliminaries}.

Let us start with the notion of a property tester for a language $L$: the goal is to determine whether an input word $u$ belongs to the language $L$, or whether it is $\eps$-far from it. 
We say that $u$ of length $n$ is \emph{$\eps$-far from $L$} with respect to a metric $d$ over words if all words $v \in L$ satisfy $d(u, v) \ge \eps n$, written $d(u,L) \ge \eps n$.
Throughout this work and unless explicitly stated otherwise, we will consider the case where $d$ is the Hamming distance, defined for two words $u$ and $v$ as the number of positions at which they differ if they have the same length, and as $+\infty$ otherwise.
In that case, $d(u,L) \ge \eps n$ means that one cannot change a proportion $\eps$ of the letters in $u$ to obtain a word in $L$.
We assume random access to the input word: a query specifies a position in the word and asks for the letter in this position. 
A \emph{$\eps$-property tester} (or for short, simply a \emph{tester}) $T$ for a language $L$ is a randomized algorithm that, given an input word $u$ of length $n$, always answers ``yes'' if $u\in L$ and answers ``no'' with probability bounded away from 0 when $u$ is $\eps$-far from $L$. 
As in previous works on this topic, we measure the complexity of a tester by its \emph{query complexity}. It is the maximum number of queries that $T$ makes on an input of length $n$, as a function of $n$ and $\eps$, in the worst case over all words of length $n$ and all possible random choices.

We can now formally define the classes of \emph{trivial, easy} and \emph{hard} regular languages.
\begin{definition}[Hard, easy and trivial languages]
	Let $L$ be a regular language. We say that:
	\begin{itemize}
		\item $L$ is \emph{hard} if  the optimal query complexity for a property tester for $L$ is $\Theta(\epslogeps)$.
		
		\item $L$ is \emph{easy} if the optimal query complexity for a property tester for $L$ is $\Theta(1/\eps)$.
		
		\item $L$ is \emph{trivial} if there exists $\eps_0> 0$ such that for all positive $\eps < \eps_0$, there is a property tester and some $n \in \NN$ such that the tester makes $0$ queries on words of length $\geq n$.
	\end{itemize}
\end{definition}


\begin{remark}\label{rmk:finite}
    If $L$ is finite, then it is trivial: since there is a bound~$B$ on the lengths of its words, a tester can reject words of length at least $n_0 = B+1$ without querying them.
    For that reason, we only consider \emph{infinite} languages in the rest of the article.
\end{remark}


Our characterization of those three classes uses the notion of \emph{blocking sequence} of a language $L$. Intuitively, they  are sequences of words such that finding those words as factors of a word $w$ proves that $w$ is not in $L$.
We also define a partial order on them, which gives us a notion of \emph{minimal} blocking sequence.

\begin{restatable}{theorem}{ptestmainthm}\label{thm:general}
	Let $L$ be an infinite regular language recognized by an NFA $\Aa$ and let $\MBS(\Aa)$ denote the set of minimal blocking sequences of $\Aa$.
	The complexity of testing $L$ is characterized by $\MBS(\Aa)$ as follows:
	\begin{enumerate}
		\item $L$ is trivial if and only if $\MBS(\Aa)$ is empty;
		\item $L$ is easy if and only if $\MBS(\Aa)$ is finite and nonempty;
		\item $L$ is hard if and only if $\MBS(\Aa)$ is infinite.
	\end{enumerate}
\end{restatable}
In the case where $L$ is recognised by a strongly connected automaton, blocking sequences can be replaced by \emph{blocking factors}. A blocking factor is a single word that is not a factor of any word in $L$.

\cref{sec:preliminaries} defines the necessary terms and notations.
The rest of the paper is structured as follows.
In Sections~\ref{sec:scc} and~\ref{sec:general}, we delimit the set of hard languages, that is, the ones that require $\Theta(\epslogeps)$ queries.
More precisely, \cref{sec:scc} focuses on the subcase of languages defined by \emph{strongly connected automata}.
First, we combine the ideas of Alon et al.~\cite{alon2001regular} with those presented in~\cite{bathie2021property} to obtain a property tester that uses $\cO(\epslogeps)$ queries for any language with a strongly connected automaton, under the Hamming distance.
Second, we show that if the language of a strongly connected automaton has infinitely many blocking factors then it requires $\Omega(\epslogeps)$ queries.
This result generalizes the result of Bathie and Starikovskaya~\cite{bathie2021property}, which was for a single language, to all regular languages with infinitely many minimal blocking factors. We use Yao's minimax principle~\cite{yao1977probabilistic}: this involves constructing a hard distribution over inputs, and showing that any deterministic property testing algorithms cannot distinguish between positive and negative instances against this distribution.

In \cref{sec:general}, we extends those results to all automata. The interplay with the previous section is different for the upper and the lower bound.For the upper bound of $\cO(\epslogeps)$ queries, we use a natural but technical extension of the proof in the strongly connected case. 
Note that this result is an improvement over the result of Bathie and Starikovskaya~\cite{bathie2021property}, which works under the edit distance, and testers for the Hamming distance are also testers for the edit distance.
For the lower bound of $\Omega(\epslogeps)$ queries for languages with infinitely many minimal blocking sequences, we reduce to the strongly connected case. The main difficulty is that it is not enough to consider strongly connected components in isolation: there exists finite automata that contain a strongly connected component that induces a hard language, yet the language of the whole automaton is easy. We solve this difficulty by carefully defining the notion of minimality for a blocking sequence.

\cref{sec:trivial-easy} completes the trichotomy, by characterising the easy and trivial languages.
We show that languages of automata with finitely many blocking sequences can be tested with $\cO(1/\eps)$ queries.
We also prove that if an automaton has at least one blocking sequence, then it requires $\Omega(1/\eps)$ queries to be tested, by showing that the languages that our notion of trivial language coincides with the one given by Alon et al.~\cite{alon2001regular}.
By contrast, we show that automata without blocking sequences recognize trivial languages.

Once we have the trichotomy, it is natural to ask whether it is effective: given an automaton $\Aa$, can we determine if its language is trivial, easy or hard? 
The answer is yes, and we show in \cref{sec:complexity} that all three decision problems are \PSPACE-complete, even for strongly connected automata.
 
\section{Preliminaries}
\label{sec:preliminaries}
\subparagraph*{Words and automata.}
We write $\Sigma^*$ (resp. $\Sigma^+$) for the set of finite words (resp. non-empty words) over the alphabet $\Sigma$.
The length of a word $u$ is denoted $|u|$, and its $i$th letter is denoted $u[i]$. The empty word is denoted $\emptyw$.
Given $u\in\Sigma^*$ and $0\le i, j \le |u|-1$, define $u[i\dd j]$ as the word $u[i]u[i+1]\ldots u[j]$ if $i\le j$ and $\emptyw$ otherwise.
Further, $u[i\dd j)$ denotes the word $u[i\dd j-1]$.
A word $w$ is a \emph{factor} (resp. \emph{prefix}, \emph{suffix}) of $u$ is there exist indices $i,j$ such that $w = u[i\dd j]$ (resp. with $i = 0, j = |u|-1$). We use $w\factor u$ to denote ``$w$ is a factor of $u$''.
Furthermore, if $w$ is a factor of $u$ and $w \neq u$, we say that $w$ is a \emph{proper factor} of $u$.
 
A \emph{nondeterministic finite automaton} (NFA) $\Aa$ is a transition system defined by a tuple $(Q, \Sigma, \delta, q_0, F)$, with $Q$ a finite set of states, $\Sigma$ a finite alphabet, $\delta : Q \times \Sigma \to \pow{Q}$ the transition function, $q_0 \in Q$ the initial state and $F \subseteq Q$ the set of final states. The semantics is as usual~\cite{Pin2021}.
When there is a path from a state $p$ to a state $q$ in $\Aa$, we say that $q$ is reachable from $p$ and that $p$ is co-reachable from $q$. 
In this work, we assume w.l.o.g. that all NFA $\Aa$ are \emph{trim}, i.e., every state is reachable from the initial state and co-reachable from some final state.

\subparagraph*{Property testing.} 

\begin{definition}\label{def:eps-far}
    Let $L$ be a language, let $u$ be a word of length $n$, let $\eps > 0$ be a precision parameter and let $d : \Sigma^*\times\Sigma^*\rightarrow \NN \cup\{+\infty\}$ be a metric.
	We say that the word $u$ is \emph{$\eps$-far from $L$ w.r.t. $d$} if $d(u, L) \ge \eps n$, where
    \[d(u, L) := \inf_{v\in L} d(u,v).\]  
\end{definition}
We assume random access to the input word: a query specifies a position in the word and asks for the letter in this position. 

Throughout this work and unless explicitly stated otherwise, we will consider the case where $d$ is the Hamming distance, defined for two words $u$ and $v$ as the number of positions at which they differ if they have the same length, and as $+\infty$ otherwise.
In that case, $d(u,L) \ge \eps n$ means that one cannot change an $\eps$-fraction of the letters in $u$ to obtain a word in $L$.

A \emph{$\eps$-property tester} (or simply a \emph{tester}) $T$ for a language $L$ is a randomized algorithm that, given an input word $u$, always answers ``yes'' if $u\in L$ and answers ``no'' with probability bounded away from 0 when $u$ is $\eps$-far from $L$. 

\begin{definition}\label{def:tester}
	A property tester for the language $L$ with precision $\eps > 0$ is a randomized algorithm $T$ that, for any input $u$ of length $n$, given random access to $u$, satisfies the following properties:
    \begin{align*}
        \text{ if } u\in L, & \text{ then } T(u) = 1, \\
        \text{ if $u$ is $\eps$-far from $L$}, & \text{ then } \Prob{T(u) = 0} \ge 2/3.
    \end{align*}
	The query complexity of $T$ is a function of $n$ and $\eps$ that counts the maximum number of queries that $T$ makes over all inputs of length $n$ and over all possible random choices.
\end{definition}


We measure the complexity of a tester by its \emph{query complexity}.
Let us emphasize that throughout this \doc we focus on so-called ``testers with perfect completeness'', or ``one-sided error'': if a word is in the language, the tester answers positively (with probability $1$). In particular our characterization applies to this class. 
Because they are based on the notion of blocking factors that we will discuss below, all known testers for regular languages~\cite{alon2001regular,magniez2007property,francois_et_al:LIPIcs:2016:6355, bathie2021property} have perfect completeness.

In this paper, we assume that the automaton $\Aa$ that describes the tested language $L$ is \emph{fixed}, and not part of the input. Therefore, we consider its number of states $m$ as a constant.

\subparagraph*{Graphs and periodicity.}
We now recall tools introduced by Alon et al.~\cite{alon2001regular} to deal with periodicity in finite automata.

Let $G = (V,E)$ with $E \subseteq V^2$ be a directed graph.
A \emph{strongly connected component} (or SCC) of $G$ is a maximal set of vertices that are all reachable from each other. 
It is \emph{trivial} if it contains a single state with no self-loop on it. 
We say that $G$ is \emph{strongly connected} if its entire set of vertices is an SCC.

 
The period $\lambda = \lambda(G)$ of a non-trivial strongly connected graph $G$ is the greatest common divisor of the length of the cycles in $G$.
Following the work of Alon et al.~\cite{alon2001regular}, we will use the following property of directed graphs.
\begin{fact}[{From \cite[Lemma 2.3]{alon2001regular}}]\label{fact:periodicity}
    Let $G = (V,E)$ be a non-empty, non-trivial, strongly connected graph with finite period $\lambda = \lambda(G)$.
    Then there exists a partition $V = Q_0\sqcup \ldots \sqcup Q_{\lambda-1}$ and a reachability constant $\rho = \rho(G)$ that does not exceed $3|V|^2$ such that:
    \begin{enumerate}
        \item\label{case:path-length} For every $0 \le i,j\le \lambda-1$ and for every $s\in Q_i, t\in Q_j$, the length of any directed path from $s$ to $t$ in $G$ is equal to $(j-i)\mod \lambda$.
        \item For every $0 \le i,j\le \lambda-1$, for every $s\in Q_i, t\in Q_j$ and for every integer $r\ge \rho$, if $r = (j-i) \pmod{\lambda}$, then  there exists a directed path from $u$ to $v$ in $G$ of length $r$.
    \end{enumerate}
\end{fact}
The sets $(Q_i: i = 0,\ldots, \lambda-1)$ are the \emph{periodicity classes} of $G$. In what follows, we will slightly abuse notation and use $Q_i$ even when $i \ge \lambda$ to mean $Q_{i \pmod{\lambda}}$ .

An automaton $\Aa = (Q, \Sigma, \delta, q_0, F)$ defines an underlying graph $G = (Q, E)$ where $E= \{(p,q) \in Q^2 \mid \exists a\in\Sigma: q\in\delta(p, a)\}$. 
In what follows, we naturally extend the notions defined above to finite automata through this graph $G$. 
Note that the numbering of the periodicity classes is defined up to a shift mod $\lambda$: we can thus always assume that $Q_0$ is the class that contains the initial state $q_0$.
The period of $\Aa$ is written $\lambda(\Aa)$.

\subparagraph*{Positional words and positional languages.}

Consider the language $L_3 = (ab)^*$.
The word $v = ab$ can appear as a factor of a word $u \in L_3$ if $v$ occurs at an even position (e.g. position 0, 2, etc.) in $u$. However, if $v$ occurs at an \emph{odd} position in $u$, then $u$ cannot be in $L_3$.
Therefore, $v$ can be used to witness that $u$ is not in $L_3$, but only if we find it at an odd position.
This example leads us to introducing \emph{$p$-positional words}, which additionally encode information about the index of each letter modulo an integer $p$.

More generally, we will associate to each regular language a period $\lambda$, and working with $\lambda$-positional words will allow us to define blocking factors in a position-dependent way without explicitly considering the index at which the factor occurs.

\begin{definition}[Positional words]
    Let $p$ be a positive integer.
    A $p$-\emph{positional word} is a word over the alphabet $\ZZ/p\ZZ\times \Sigma$ of the form $(n\pmod{p}, a_0) ((n+1) \pmod{p}, a_1) \cdots ((n+\ell) \pmod{p}, a_\ell)$ for some non-negative integer~$n$.
    If $u= a_0 \cdots a_\ell$, we write $\timedword{n}{u}$ to denote this word.
\end{definition}

With this definition, if $u = abcd$ and we consider the $2$-positional word $\tau = \timedword{0}{u}$, the factor $bc$ appears at position $1$ in $u$ and is mapped to the factor $\mu = (1, a)(0, b)$.
In this case, even when taking factors of $\mu$, we still retain the (congruence classes of the) indices in the original word $\tau$.

Any strongly connected finite automaton $\Aa = (Q, \Sigma, \delta, q_0, F)$ can naturally be extended into an automaton $\timedA$ over $\lambda(\Aa)$-positional words with $\lambda(\Aa)|Q|$ states. It suffices to keep track in the states of the current state of $\Aa$ and the number of letters read modulo $\lambda(\Aa)$.

We call the language recognized by $\timedA$ the \emph{positional language of $\Aa$},
and denote it $\timedlang{\Aa}$. This definition is motivated by the following property:
\begin{property}
	For any word $u\in\Sigma^*$, we have $u\in\lang{\Aa}$ if and only if $\twu\in\timedlang{\Aa}$.
\end{property}

Positional words make it easier to manipulate factors with positional information, hence we phrase our property testing results in terms of positional languages. Notice that a property tester for $\timedlang{\Aa}$ immediately gives a property tester for $\lang{\Aa}$, as one can simulate queries to $\twu$ with queries to $u$ by simply pairing the index of the query modulo $\lambda(\Aa)$ with its result. 
\section{Hard Languages for Strongly Connected NFAs}
\label{sec:scc}
Before considering the case of arbitrary NFAs, we first study the case of strongly connected NFAs, which are NFAs such that for any pair of states $p,q\in Q$, there exists a word~$w$ such that $p\xrightarrow{w}q$. We will later generalize the results of this section to all NFAs.

We show that the query complexity of the language of such an NFA~$\Aa$ can be characterized by the cardinality of the set of \emph{minimal blocking factors} of~$\Aa$, which are factor-minimal $\lambda(\Aa)$-positional words that witness the fact that a word does not belong to $\timedlang{\Aa}$.
In this section, we consider a fixed NFA~$\Aa$ and simply use ``positional words'' to refer to $\lambda$-positional words, where $\lambda = \lambda(\Aa)$ is the period of~$\Aa$.

\begin{definition}[Blocking factors]\label{def:blocking}
    Let~$\Aa$ be a strongly connected NFA.
    A positional word $\tau$ is a \emph{blocking factor} of~$\Aa$
    if for any other positional word $\mu$
    we have $\tau \factor \mu \Rightarrow \mu \notin \timedlang{\Aa}$.

    Further, we say that $\tau$ is a \emph{minimal} blocking factor of~$\Aa$ 
    if no proper factor of $\tau$ is a blocking factor of~$\Aa$.
    We use $\MBF(\Aa)$ to denote the set of all minimal blocking factors of~$\Aa$.
\end{definition}
Intuitively and in terms of automata, the positional word~$\timedword{i}{u}$ is blocking for~$\Aa$ if it does not label any transition in~$\Aa$ labeled by $u$ starting from a state of $Q_i$. (This property is formally established later in \cref{lemma:intuition-timed-word}.)
The main result of this section is the following:
\begin{theorem}\label{thm:scc}
    Let $L$ be an infinite language recognised by a strongly connected NFA~$\Aa$. If $\MBF(\Aa)$ is infinite, then $L$ is hard, i.e., it has query complexity $\Theta(\epslogeps)$
\end{theorem}
This result gives both an upper bound of $\cO(\epslogeps)$ and a lower bound of $\Omega(\epslogeps)$ on the query complexity of a tester for~$L$:
we prove the upper bound in \cref{sec:scc-ub} and the lower bound in \cref{sec:scc-lb}.

\subsection{Positional words, blocking factors and strongly connected NFAs}\label{sec:scc-tw}

We first establish some properties of positional words that will help us ensure that we are creating well-formed positional words, that is, positional words where the index $i$ of a letter $\timedword{i}{a}$ is equal to $j+1\pmod{\lambda}$, where $j$ is the index of the previous letter. In \cref{sec:scc-ub}, we highlight the connection between property testing and blocking factors in strongly connected NFAs.

We start with the following properties, which are consequences of \cref{fact:periodicity}.
\begin{corollary}\label{corollary:position-length}
    Let~$n$ be a nonnegative integer, let~$w$ be a word of length~$n$.
    If for some states $p\in Q_i, q\in Q_j$ of~$\Aa$ we have $p\xrightarrow{w}q$,
    then the indices $i,j$ satisfy the equation
    \begin{equation*}
        j-i = |w| \pmod{\lambda}
    \end{equation*}
\end{corollary}
\begin{corollary}\label{corollary:position-factor}
    Let $\tau = \timedword{i}{u}$ and $\mu = \timedword{j}{v}$ be positional words.
    If $\tau \factor \mu$, then there exists positional words $\eta, \eta'$ with $|\eta| = i-j \pmod{\lambda}$
    such that $\mu = \eta\tau\eta'$.
    In particular, this implies that there exists words $w,w'$ with $|w| = i-j \pmod{\lambda}$
    such that $v = wuw'$.
\end{corollary}

These properties allows us to formalize the intuition we gave earlier about blocking factors.

\begin{lemma}\label{lemma:intuition-timed-word}
    A positional word $\tau = \timedword{i}{u}$ is a blocking factor for $\Aa$
    iff for every states $p\in Q_i, q\in Q$, we have $p\centernot{\xrightarrow{u}}q$.
\end{lemma}

\begin{proof}
    We first show that if there exists states $p\in Q_i, q\in Q$ such that $p\xrightarrow{u}q$,
    then $\tau$ is not blocking, i.e. there exists $\mu\in \timedlang{\Aa}$ such that $\tau\factor\mu$.
    As~$\Aa$ is strongly connected, there exist positional words $\eta,\eta'$ such that $q_0 \xrightarrow{\eta} p$
    and $q\xrightarrow{\eta'} q_f$ for some $q_f\in F$.
    By \cref{fact:periodicity}, the positional word $\mu = \eta\tau \eta'$ is well formed.
    Furthermore, it labels a transition from $q_0$ to $q_f$, hence it is in $\timedlang{\Aa}$, and $\tau$ is not blocking.
    
    For the converse, assume that $\tau$ is non-blocking: we show that there exists two states $p\in Q_i, q\in Q$ such that $p\xrightarrow{u}q$.
    As $\tau$ is non-blocking, there exists a positional word $\mu = \timedword{0}{w}$ such that $\tau\factor \mu$
    and there exists a final state~$r$ such that $q_0\xrightarrow{\mu}r$, and equivalently, $q_0\xrightarrow{w}r$.
    By \cref{corollary:position-factor}, since $\tau\factor \mu$, there exists words $v,v'$ such that $w = vuv'$ and the length of~$v$ is equal to~$i$ modulo $\lambda$.
    In particular, the path $q_0\xrightarrow{w}r$ can be decomposed into $q_0\xrightarrow{v}p\xrightarrow{u}q\xrightarrow{w}r$, and we have $p\xrightarrow{u}q$.
    It only remains to show that~$p$ is in $Q_i$: this follows by \cref{corollary:position-length} since $|v| = i\pmod{\lambda}$.
\end{proof}

Next, we show that the Hamming distance between~$u$ and $\lang{\Aa}$ is the same as the (Hamming) distance between $\twu$ and $\timedlang{\Aa}$.
\begin{claim}\label{claim:far-equiv}
    For any word $u\in\Sigma^*$, we have $d(u, \lang{\Aa}) = d(\twu, \timedlang{\Aa})$.
\end{claim}
\begin{claimproof}
    The $\le$ part is straightforward.
    For the reverse inequality, if suffices to see that in any minimal substitution sequence from $\twu$
    to a positional word in $\timedlang{\Aa}$, no operation changes only the index of an (index, letter) pair.
\end{claimproof}
The above claim allows us to interchangeably use the statements ``$u$ is $\eps$-far from $\lang{\Aa}$'' and ``$\twu$ is $\eps$-far from $\timedlang{\Aa}$''.

\subsection{An efficient property tester for strongly connected NFAs.}\label{sec:scc-ub}
In this section, we show that for any strongly connected NFA~$\Aa$, there exists an $\eps$-property tester for $\lang{\Aa}$ that uses $\cO(\epslogeps)$ queries.
\begin{theorem}\label{thm:generic-tester-scc}
    Let~$\Aa$ be a strongly connected NFA.
    For any $\eps > 0$, there exists an $\eps$-property tester for $\lang{\Aa}$
    that uses $\cO(\epslogeps)$ queries. 
\end{theorem}

Our proof is similar to the one given in~\cite{bathie2021property}, with one notable technical improvement: we use a new method for sampling factors in~$u$, which greatly simplifies the correctness analysis.

\subsubsection{An efficient sampling algorithm}

We first introduce a sampling algorithm (\cref{alg:generic-sampling}) that uses few queries and has a large probability of finding at least one factor from a large set $\Ss$ of disjoint ``special'' factors.
Using this algorithm on a large set of disjoint blocking factors gives us an efficient property tester for strongly connected NFAs. We will re-use this sampling procedure later in the case of general NFAs (\cref{thm:gen-ub}).  

The procedure is fairly simple: the algorithm samples factors of various lengths in~$u$ at random.
On the other hand, the correctness of the tester is far from trivial.
The lengths and the number of factors of each length are chosen so that the number of queries is minimized and the probability of finding a ``special'' factor is maximized, regardless of their repartition in~$u$. (In what follows, the ``special'' factors are blocking factors.)

\begin{algorithm}[htbp]
\caption{Efficient generic sampling algorithm}\label{alg:generic-sampling}
\begin{algorithmic}[1] \Function{OneSample}{$u, \ell$}
    \State $i\gets \Call{uniform}{0, n-1}$
    \State $l\gets \max(i-\ell, 0), r\gets\min(i+\ell, n-1)$
    \State \Return $u[l\dd  r]$
\EndFunction
\Function{Sampler}{$u, N, L$}
\State $n \gets |u|$
\State $\beta \gets n/N$
\State $T \gets \lceil\log(L)\rceil$
\State $F \gets \emptyset$
\For{$t = 0$ to $T$}
    \State $\ell_t \gets 2^t, r_t \gets \lceil 2\ln(3)\beta/\ell_t \rceil$
    \For{$i = 0$ to $r_t$}
        \State $\Ff \gets \Ff \cup \{\Call{OneSample}{u, \ell_t}\}$
    \EndFor
\EndFor
\State \Return $\Ff$
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{claim}\label{claim:generic-sampling-alg-complexity}
    A call to $\Call{Sampler}{u, N, L}$ (\cref{alg:generic-sampling}) makes $\cO(n\log(L)/N)$ queries to~$u$.
\end{claim}
\begin{claimproof}
    A call to $\Call{OneSample}{u, \ell_t}$ makes at most $2\ell_t$ queries to $u$.
    Furthermore, the function $\Call{Sampler}{u, N, L}$ makes $r_t = 2\ln(3)\cdot \beta/\ell_t = 2\ln(3)\cdot n/(N\ell_t)$ calls to $\Call{OneSample}{u, \ell_t}$ for each $t = 0,\ldots, T$, where $T = \lceil\log(L)\rceil$.
    This adds up to \[\sum_{t=0}^T  r_t \cdot\ell_t = \lceil\log(L)\rceil \cdot2\ln(3)\cdot n/N = \cO(n\log(L)/N)\] queries to $u$.
\end{claimproof}

\begin{lemma}\label{lemma:generic-sampling-alg}
    Let $u$ be a word of length~$n$, and consider a set~$\Ss$ containing at least~$N$ disjoint factors of~$u$, each of length at most~$L$.
    A call to the function $\Call{Sampler}{u, N, L}$ (\cref{alg:generic-sampling}) returns a set $\Ff$ of factors of $u$ such that there exists a word of $\Ss$ that is a factor of some word of $\Ff$, with probability at least $2/3$.
\end{lemma}

\begin{proof}
    We conceptually divide the blocking factors in $\Ss$ into different categories depending on their length:
    let $T = \lceil\log(L)\rceil$, and for $t= 0,\ldots, T,$ let $S_t$ denote the subset of $\Ss$ which contains factors of length at most $\ell_t = 2^t$.
    We then carefully analyze the probability that randomly sampled factors of length $2\ell_t$ contains a factor
    from $S_{t}$, and show that over all~$t$, at least one sampled factor contains a factor of $\Ss$, with probability at least $2/3$.
    
    \begin{claim}
        If in a call to \textsc{OneSample}, the value~$i$ is such that there exists indices~$l$ and~$r$ such that $l \le i\le r$
        and $u[l, r]$ contains a factor in $\Ss$, then the set $\Ff$ returned by the algorithm has the desired property.
    \end{claim}
    
    As the factors given in $\Ss$ are disjoint,
    the probability $p_t$ that the factor returned by \textsc{OneSample} contains a factor from $\Ss$ is lower bounded by
    \(p_t \ge \frac{1}{n}\sum_{v\in S_t} |v|.\)
    The \textsc{OneSample} function is called $r_t = 2\ln(3)\beta/\ell_t$ times independently for each~$t$,
    hence the probability~$p$ that the algorithm samples a factor containing a factor from $\Ss$ satisfies the following:
    \begin{align*}
        (1-p) 
        &= \prod_{t=0}^T (1-p_t)^{r_t} \le \exp\left(-\sum_{t=0}^T p_t r_t\right)\\
        &\le \exp\left(-\frac{2\ln(3)\beta}{n} \sum_{t=0}^T \frac{1}{\ell_t} \sum_{v\in S_t} |v|\right)\\
        &= \exp\left(-\frac{2\ln(3)\beta}{n} \sum_{v\in \Ss}|v| \sum_{t=\lceil\log|v|\rceil}^T 2^{-t}\right).
    \end{align*}
    Now, inverting the order of summation, and lower bounding the sum of powers of $2$ by its first term,
    we obtain:
    \begin{align*}
        (1-p) &\le \exp\left(-\frac{2\ln(3)\beta}{n} \sum_{v\in \Ss}|v| \cdot 2^{-\lceil\log|v|\rceil}\right)\\
        &\le \exp\left(-\frac{2\ln(3)\beta}{n} \sum_{v\in \Ss}|v| \frac{1}{2|v|}\right)\\
        &= \exp\left(-\frac{2\ln(3)\beta}{n} \cdot\frac{|\Ss|}{2}\right) 
         \le \exp\left(-\frac{\ln(3)\beta N}{n}\right)\\
        &= \exp\left(-\ln(3) \right) = 1/3
    \end{align*}
    It follows that $p \ge 2/3$, which concludes the proof.
\end{proof}

\subsubsection{The tester}

The algorithm for \cref{thm:generic-tester-scc} is given in \cref{alg:generic-tester-scc}.

\begin{algorithm}[htbp]
\caption{Generic $\eps$-property tester that uses $\cO(\epslogeps)$ queries}\label{alg:generic-tester-scc}
\begin{algorithmic}[1] \Function{Tester}{$u, \eps$}
\State $n \gets |u|, m\gets |Q|$
\State $L \gets 12m^2/\eps$
\If{$\lang{\Aa} \cap \Sigma^n = \emptyset$}
    \State Reject
\ElsIf{$n < L$}
    \State Query all of $u$ and run~$\Aa$ on it
    \State Accept if and only if~$\Aa$ accepts
\Else \label{line:intersting-case}
    \State \label{line:compute-f}$\Ff \gets\Call{Sampler}{\twu, n/L, L}$
    \State Reject if and only if $\Ff$ contains a blocking factor for~$\Aa$.
\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

We now show that \cref{alg:generic-tester-scc} is a property tester for $\lang{\Aa}$ that uses $\cO(\epslogeps)$ queries. In what follows, we use $n$ to denote the length of the input word $u$ and $m$ to denote the number of states of $\Aa$.
\begin{claim}
    The tester given in \cref{alg:generic-tester-scc} makes $\cO(\epslogeps)$ queries to~$u$.
\end{claim}
\begin{proof}
    If $n \le L$, then the tester makes $n \le L =\cO(1/\eps)$ queries, and the claim holds.
    Otherwise, the number of queries is given by the call to $\Call{Sampler}{u, n/L, L}$:
    by \cref{claim:generic-sampling-alg-complexity}, this uses $\cO(\frac{n \log L}{n/L}) = \cO(L \log L) = \cO(\epslogeps)$ queries.
\end{proof}

Alon et al.~\cite[Lemma 2.6]{alon2001regular} first noticed that if a word~$u$ is $\eps$-far from $\lang{\Aa}$, then it contains $\Omega(\eps n)$ short factors that witness the fact that~$u$ is not in $\lang{\Aa}$.
We start by translating the lemma of Alon et al. on ``short witnesses'' to the framework of blocking factors.
More precisely, we show that if~$u$ is $\eps$-far from $\lang{\Aa}$, then $\twu$ contains many disjoint (i.e. non-overlapping) blocking factors.

\begin{lemma}\label{lemma:many-blocking}
    Let $\eps> 0$, let~$u$ be a word of length $n \ge 6m^2/\eps$ and assume that $\lang{\Aa}$ contains at least one word of length~$n$.
    If $\tau = \twu$ is $\eps$-far from $\timedlang{\Aa}$, then $\tau$ contains at least $\eps n/(6m^2)$ disjoint blocking factors.
\end{lemma}
\begin{proof}
    We build a set $\Pp$ of disjoint blocking factors of $\tau$ as follows: we process~$u$ from left to right, starting at index $i_1 = \rho$, where~$\rho$ is the reachability constant of $\Aa$ (see \cref{fact:periodicity}).
    Next, at iteration~$t$, set~$j_t$ to be the smallest integer greater than or equal to~$i_t$ and smaller than $n-\rho$ such that $\tau[i_t\dd  j_t]$ is a blocking factor. If there is no such integer, we stop the process.
    Otherwise, we add $\tau[i_t\dd  j_t+\rho-1]$ to the set~$\Pp$, and iterate starting from the index $i_{t+1} = j_t+\rho$.

    Let~$k$ denote the size of~$\Pp$. 
    We will show that we can substitute at most $3(k+1)m^2$ positions in $\tau$ to obtain a word in $\timedlang{\Aa}$. (See \cref{fig:many-blocking} for an illustration of this construction.)
    Using the assumption that $\tau$ is $\eps$-far from $\timedlang{\Aa}$ (which follows from \cref{claim:far-equiv}) will give us the desired bound on~$k$.

    \begin{figure}[htbp]
    \begin{center}
        \begin{tikzpicture}[scale=0.9]
            \node (label) at (-.5, .25) {\textbf{a)}};
            \draw (0, 0) rectangle ++(14, .5);
            \draw[pattern=crosshatch,pattern color=red!40] (0, 0) rectangle ++(1, .5);
            \draw[pattern=north west lines,pattern color=gray!40] (1, 0) rectangle ++(2.8, .5) node[midway] {$\tau[i_1\dd  j_1]$};
            \draw[pattern=crosshatch,pattern color=red!40] (3.8, 0) rectangle ++(1, .5);
            \draw[pattern=north west lines,pattern color=gray!40] (4.8, 0) rectangle ++(2.8, .5) node[midway] {$\tau[i_2\dd  j_2]$};
            \draw[pattern=crosshatch,pattern color=red!40] (7.6, 0) rectangle ++(1, .5);
            \node (dots) at (9.3, .25) {$\ldots$};
            \draw[pattern=north west lines,pattern color=gray!40] (10, 0) rectangle ++(3, .5) node[midway] {$\tau[i_k\dd  j_k]$};
            \draw[pattern=crosshatch,pattern color=red!40] (13, 0) rectangle ++(1, .5);
            \node[white] (p1) at (1, -.3) {$p_1$};
            \node[white] (qf) at (14, -.3) {$q_f$};
        \end{tikzpicture}
        \begin{tikzpicture}[scale=0.9]
            \node (label) at (-.5, .25) {\textbf{b)}};
            \draw (0, 0) rectangle ++(14, .5);
            \draw[pattern=north west lines,pattern color=gray!40] (1, 0) rectangle ++(2.5, .5) node[midway] {$\tau[i_1\dd  j_1-1]$};
            \node (p1) at (1, -.3) {$p_1$};
            \node (q1) at (3.5, -.3) {$q_1$};
            \draw[->] (p1) -> (q1);
            \draw[pattern=north west lines,pattern color=gray!40] (4.8, 0) rectangle ++(2.5, .5) node[midway] {$\tau[i_2\dd  j_2-1]$};
            \node (p2) at (4.8, -.3) {$p_2$};
            \node (q2) at (7.3, -.3) {$q_2$};
            \draw[->] (p2) -> (q2);

            \node (p3) at (8.8, -.3) {$p_3\ldots$};
            \node (dots) at (9.3, .25) {$\ldots$};
            \draw[pattern=north west lines,pattern color=gray!40] (10, 0) rectangle ++(2.6, .5) node[midway] {$\tau[i_k\dd  j_k-1]$};
            \node (pk) at (10, -.3) {$p_k$};
            \node (qk) at (12.6, -.3) {$q_k$};
            \draw[->] (pk) -> (qk);
            \node[white] (qf) at (14, -.3) {$q_f$};
        \end{tikzpicture}
        \begin{tikzpicture}[scale=0.9]
            \node (label) at (-.5, .25) {\textbf{c)}};
            \draw (0, 0) rectangle ++(14, .5);
            \draw[pattern=north west lines,pattern color=gray!40] (1, 0) rectangle ++(2.5, .5) node[midway] {$\tau[i_1\dd  j_1-1]$};
            \node (p1) at (1, -.3) {$p_1$};
            \node (q1) at (3.5, -.3) {$q_1$};
            \draw[pattern=north west lines,pattern color=gray!40] (4.8, 0) rectangle ++(2.5, .5) node[midway] {$\tau[i_2\dd  j_2-1]$};
            \node (p2) at (4.8, -.3) {$p_2$};
            \node (q2) at (7.3, -.3) {$q_2$};

            \node (p3) at (8.8, -.3) {$p_3\ldots$};
            \node (dots) at (9.3, .25) {$\ldots$};
            \draw[pattern=north west lines,pattern color=gray!40] (10, 0) rectangle ++(2.6, .5) node[midway] {$\tau[i_k\dd  j_k-1]$};
            \node (pk) at (10, -.3) {$p_k$};
            \node (qk) at (12.6, -.3) {$q_k$};

            \node (q0) at (0, -.3) {$q_0$};
            \node (qf) at (14, -.3) {$q_f$};
            \draw[->] (q0) -> (p1);
            \draw[->] (p1) -> (q1);
            \draw[->] (q1) -> (p2);
            \draw[->] (p2) -> (q2);
            \draw[->] (q2) -> (p3);
            \draw[->] (p3) -> (pk);
            \draw[->] (pk) -> (qk);
            \draw[->] (qk) -> (qf);
        \end{tikzpicture}

        \caption[Decomposition process for finding many blocking factors in $\eps$-far words]{\textbf{a)} The decomposition process returns~$k$ factors $\tau[i_1, j_t], \ldots, \tau[i_k,j_k]$ (represented as diagonally hatched in gray regions), separated together and with the start of the text by padding regions of $\rho-1$ letters (red crosshatched regions).
        \textbf{b)} If we exclude the last letter of each blocking factor, we obtain factors that label transitions between some pair of states $p_t, q_t$ for each $t = 1,\ldots, k$.
        \textbf{c)} We use the padding regions to bridge between consecutive factors as well as the start and end of the word.}
        \label{fig:many-blocking}
    \end{center}
    \end{figure}

    For every~$t$, we chose $j_t$ to be minimal so that $\tau[i_t\dd j_t]$ is blocking, hence $\tau[i_t\dd j_t-1]$ is not blocking, and therefore $\tau[i_t\dd j_t-1]$ labels a run from some state $p_t \in Q_{i_t}$ to some state $q_t \in Q_{j_t}$.
    Therefore, using the strong connectivity of~$\Aa$ and \cref{fact:periodicity}, we can substitute  the letters in $\tau[j_t\dd  j_t+\rho-1]$ to obtain a factor that labels a transition from~$q_t$ to~$p_{t+1}$. After this transformation, the word $\tau[i_t\dd  j_t+\rho-1]$ labels a transition from~$p_t$ to~$p_{t+1}$.
    Using the $\rho$ letters at the start and the end of the word, we add transitions from an initial state to $p_1$ and from $q_k$ to a final state: the assumption that $\lang{\Aa}$ contains a word of length~$n$ ensures that $Q_n$ contains a final state, hence this is always possible.
    The resulting word is in $\timedlang{\Aa}$ and was obtained from $\tau$ using $(k+1)\rho \le 3(k+1)m^2$ substitutions.
    As $\tau$ is $\eps$-far from $\timedlang{\Aa}$, we obtain the following bound on $k$:
    \begin{align*}
        3(k+1)m^2 \ge \eps n
&\Longrightarrow k \ge \frac{\eps n}{3m^2}-1\\
            &\Longrightarrow k \ge \frac{\eps n}{6m^2}
    \end{align*}
    The last implication uses the assumption that $n \ge 6m^2 / \eps$.
\end{proof}

Next, we show that if~$u$ is $\eps$-far from $\lang{\Aa}$, then $\twu$ contains $\Omega(\eps n)$ blocking factors, each of length $\cO(1/\eps)$.
\begin{lemma}\label{lemma:many-short-blocking} 
    Let $\eps> 0$, let~$u$ be a word of length $n \ge 6m^2/\eps$ and assume that $\lang{\Aa}$ contains at least one word of length~$n$.
    If~$u$ is $\eps$-far from $\lang{\Aa}$, then the positional word $\twu$ contains at least $\eps n/(12m^2)$ disjoint blocking factors of length at most $12m^2/\eps$.
\end{lemma}
\begin{proof}
    Let $u, \Aa$ be a word and an automaton satisfying the above hypotheses.
    By \cref{lemma:many-blocking}, $\twu$ contains at least $\eps n/(6m^2)$ \emph{disjoint} blocking factors.
    As these factors are disjoint, at most half of them (that is, $\eps n/(12m^2)$ of them) can have length greater than $12m^2/\eps$, as the sum of their lengths cannot exceed~$n$.
\end{proof}

\begin{proof}[Proof of \cref{thm:generic-tester-scc}]
    First, note that if $u\in\lang{\Aa}$, $\twu$ cannot contain a blocking factor for $\Aa$, hence \cref{alg:generic-tester-scc} always accepts $u$.
    Next, if $\lang{\Aa} \cap \Sigma^n$ is empty or if $|u| \le L = 12m^2/\eps$, the tester has the same output as $\Aa$, hence it is correct.

    In the remaining case, $u$ is long enough and $\eps$-far from $\lang{\Aa}$, hence \cref{lemma:many-short-blocking} gives us a large set of short blocking factors in $\twu$: this is exactly what the \textsc{Sampler} function needs to find at least one factor containing a blocking factor with probability at least $2/3$.
    More precisely, by \cref{lemma:many-short-blocking}, $\twu$ contains at least $\eps n/(12m^2)= n/L$ blocking factors of length at most $L = 12m^2/\eps$, hence the conditions of \cref{lemma:generic-sampling-alg} are satisfied.

    As a factor containing a blocking factor is also a blocking factor, the set $\Ff$ computed on line~\ref{line:compute-f} of \cref{alg:generic-tester-scc} contains at least one blocking factor with probability at least~$2/3$, and \cref{alg:generic-tester-scc} satisfies \cref{def:tester}.
\end{proof}

\subsection{Lower bound from infinitely many minimal blocking factors}\label{sec:scc-lb}
We now show that languages with infinitely many \emph{minimal} blocking factors are hard, i.e. any tester for such a language requires $\Omega(\epslogeps)$ queries.

Let us first give an example that will motivate our construction. 
Consider the parity language~$P$ consisting of words that contain an even number of $b$'s, over the alphabet $\set{a,b}$.
Distinguishing $u \in P$ from $u \notin P$ requires $\Omega(n)$ queries, as changing the letter at single position can change membership in~$P$. However, $P$ is trivial to test, as any word is at distance at most~1 from~$P$, for the same reason.
Now, consider language $L_2$ consisting of words over $\set{a,b,c,d}$ such that between a~$c$ and the next~$d$, there is a word in~$P$. Intuitively, this language encodes multiple instances of~$P$, hence we can construct words $\eps$-far from $L_2$, and each instance is hard to recognize for property testers, hence the whole language is.
In~\cite[Theorem 15]{bathie2021property}, Bathie and Starikovskaya proved a lower bound of $\Omega(\epslogeps)$ on the query complexity of any property tester for $L_2$, matching the upper bound in the same paper. 

The minimal blocking factors of $L_2$ include all words for the form $cvd$ where $v\notin P$: there are infinitely many such words.
This is no coincidence: we show that this lower bound can be lifted to any language with infinitely many minimal blocking factors, under the Hamming distance.

\begin{theorem}\label{thm:scc-lb}
    Let~$\Aa$ be a strongly connected NFA.
    If $\MBF(\Aa)$ is infinite, then there exists a constant $\eps_0$ such that for any $\eps <\eps_0$, any $\eps$-property tester for $L = \lang{\Aa}$ uses $\Omega(\epslogeps)$ queries.
\end{theorem}
The proof of this result is full generalization of the lower bound against the ``repeated Parity'' example given above.

Our proof is based on (a consequence of) Yao's Minimax Principle~\cite{yao1977probabilistic}: if there is a distribution $\Dd$ over inputs such that any \emph{deterministic} algorithm that makes at most~$q$ queries errs on $u\sim{} \Dd$ with probability at least~$p$, then any \emph{randomized} algorithm with~$q$ queries errs with probability at least~$p$ on some input~$u$.

To prove \cref{thm:scc-lb}, we first exhibit such a distribution $\Dd$ for $q = \Theta(\epslogeps)$.
We take the following steps:
\begin{enumerate}
    \item we show that with high probability, an input~$u$ sampled w.r.t. $\Dd$ is either in or $\eps$-far from~$L$ (\cref{lemma:far-whp}),
    \item we show that with high probability, any deterministic tester that makes fewer than $c \cdot \epslogeps$ queries (for a suitable constant $c$) cannot distinguish whether the instance~$u$ is positive or $\eps$-far, hence it errs with large probability.
    \item combine the above two results to prove \cref{thm:scc-lb} via Yao's Minimax principle.
\end{enumerate}


\subsubsection{The structure of $\MBF(\Aa)$}
Before diving into the proof of \cref{thm:scc-lb}, we show that if $\MBF(\Aa)$ is infinite, then we can find minimal blocking factors with a ``regular'' structure, a crucial ingredient for our proof.
First, we prove that the set of minimal blocking factors of an automaton is a regular language, recognized by an automaton that is possibly exponentially larger than~$\Aa$.
We first prove the result for blocking factors of the form $\timedword{i}{u}$ for a fixed $i\in\ZZ/\lambda\ZZ$.
\begin{lemma}\label{lemma:blocking-regular}
    Let $\Aa = (Q, \Sigma, \delta, I, F)$ be a strongly connected NFA with~$m$ states and let $\lambda = \lambda(\Aa)$.
    For every $i \in\ZZ/\lambda\ZZ$, the set of minimal blocking factors of~$\Aa$ of the form $\timedword{i}{u}$ is a regular language recognized by a NFA of size $2^{\cO(m)}$.
\end{lemma}
\begin{proof}
    We call blocking factors of~$\Aa$ of the form $\timedword{i}{u}$ its \emph{$i$-blocking factors}.
    
    We first show that the set of $i$-blocking factors of~$\Aa$, but not necessarily minimal ones, is a regular language recognized by an NFA $\Aa_i$ with $m+1$ states. The result follows by using standard constructions for complement and intersection of automata~\cite[Chapter 1, Section 3]{Pin2021}: these constructions give an automaton of size $2^{\cO(m)}$ that recognizes words in~$L$ that have no proper factor in $L$.

    Consider the NFA $\Aa_i$ obtained by adding a new sink state $\bot$ to~$\Aa$,
    making it the only accepting state, with set of initial states $Q_i$.
    Formally, $\Aa_i$ is defined as $\Aa_i = (Q \cup \{\bot\}, \Sigma, \delta', Q_i, \{\bot\})$,
    where $\delta'$ is defined as follows:
    \[
        \forall p\in Q, \forall a\in\Sigma: \delta'(p, a) = \begin{cases}
            \{\bot\}& \text{ if } \delta(p,a) = \emptyset, \\
            \delta(p,a) & \text{ otherwise.}
        \end{cases}
    \]
    This automaton\footnote{Our definition of NFAs does not allow for multiple initial states. As there is no constraint of strong connectivity for $\Aa_i$, this can be solved using a simple construction that adds a new initial state.} recognizes the set of $i$-blocking factors of~$\Aa$ and has size $\cO(m)$.
    Applying the aforementioned construction to $L = \lang{\Aa_i}$ yields the desired automaton, of size $2^{\cO(m)}$.
\end{proof}

It follows that the set of minimal blocking factors of~$\Aa$ is also a regular language.
\begin{corollary}
   Let~$\Aa$ be an NFA with~$m$ states.
   The set of minimal blocking factors of~$\Aa$ is a regular language recognized by an NFA of size $2^{\cO(m)}$.
\end{corollary}

Therefore, if $\MBF(\Aa)$ is infinite, we can use the Pumping Lemma~\cite[Chapter 1, Proposition 2.2]{Pin2021} to find an infinite family of minimal blocking factors with a shared structure $\{\phi \nu^r \chi, r\in\NN\}$, for some non-empty positional words $\phi, \nu$ and~$\chi$. We will use this property later, when proving a lower bound against the language of automata with infinitely many blocking factors.
\begin{restatable}{lemma}{lemmagoodbf}\label{lemma:good-bf}
    If $\MBF(\Aa)$ is infinite, then there exist positional words $\phi,\nu_+,\nu_-,\chi$ such that:
    \begin{enumerate}
        \item the words $\nu_+$ and $\nu_-$ have the same length,
        \item there exists a constant $ S = 2^{\poly(m)}$ such that $|\phi|, |\nu_+|, |\nu_-|, |\chi|\le  S$,
        \item there exists an index $i_*\in\ZZ/ \lambda\ZZ$ and a state $q_*\in Q_{i_*}$ such that for every integer $r \ge 1$,
        the positional word $\tau_{-,r} = \phi(\nu_-)^r\chi$ is blocking for~$\Aa$, and for every $s < r$, we have
        \[q_* \xrightarrow{\tau_{+,r,s}} q_* \text{ where } \tau_{+,r,s} = \phi(\nu_-)^j\nu_+(\nu_-)^{r-1-s}\chi.\]
        In particular, $\tau_{+,r,s}$ is not blocking for~$\Aa$.
    \end{enumerate}
\end{restatable}
Note that here, the state $q_*$ is the same for \emph{every} integers $r, s$.
\begin{proof}
    As $\MBF(\Aa)$ is infinite, there must exist an integer $i_*$ such that $\Aa$ has infinitely many minimal $i_*$-blocking factors; we fix such $i_*$ in what follows.

    Let us recall the Pumping Lemma~\cite[Chapter 1, Proposition 2.2]{Pin2021}, with a formulation adapted to our purpose.
    \begin{fact}[Pumping Lemma]
        Let $L$ be a regular language recognized by an automaton of size $T$.
        There exists an integer $S = \cO(T)$ such that any word $u$ of $L$ of length at least $S$ can be factorized as $u=xyz$
        such that $|xy| \le S, |y| \ge 1$ and, for all $k \ge 0$, $xy^kz \in L$.
    \end{fact}
    As the set of minimal $i_*$-blocking factors is an infinite regular language recognized by an NFA of size $T = 2^{\cO(m)}$.
    Let $S = 2^{\cO(m)}$ be the constant given by the Pumping Lemma: since the language is infinite, it contains at least one positional word of length greater than $S$.
    Hence, there exist positional words $\tau, \mu$ and~$\eta$, with $|\mu|\ge 1$, such that for any non-negative integer $k, \tau\mu^k\eta$ is a minimal $i_*$-blocking factor.
    By removing factors that label loops in the automaton, we can assume that each of them has length at most~$S$.
    Furthermore, we can assume w.l.o.g. that neither $\tau$ nor $\eta$ is empty, otherwise we set their value to $\mu$: after this modification, $\tau\mu^k\eta$ is still a minimal $i_*$-blocking factor for every $k\ge 0$.

    Notice that the word $\tau\mu^{m}$ is not a blocking factor, as a proper factor of the minimal blocking factor $\tau\mu^{m}\eta$. Therefore, by the pigeonhole principle, there exist integers ${k_0}, k_1 \ge 1$ with ${k_0} + k_1 = m$ and states $p, p_1$ such that we have 
    \[p \xrightarrow{\tau\mu^{k_0}} p_1 \xrightarrow{\mu^{k_1}} p_1.\]
    Note that, by \cref{fact:periodicity}, $p_1 \xrightarrow{\mu^{k_1}} p_1$ implies that $k_1 \cdot |\mu| = 0\pmod{\lambda}$.

    Similarly, the word $\mu^{m}\eta$ is not a blocking factor, since it is a proper factor of the minimal $i_*$-blocking factor $\tau \mu^{m}\eta$.
    Again, there exist integers $k_2 \ge 1, {k_3}$ summing to $m$ and states $p_2 $ and $q$ such that
    \[p_2 \xrightarrow{\mu^{k_2}} p_2 \xrightarrow{\mu^{k_3}\eta} q.\]

    Now, define $\phi = \tau\mu^{k_0}, \chi = \mu^{k_3} \eta$ and $\nu_- = \mu^{K}$, where $K = \rho\cdot k_1\cdot k_2$.
    As there are transitions starting from $p_1$ and $p_2$ labeled by $\mu$, $p_1$ and $p_2$ belong to the same periodicity class.
    Therefore, by \cref{fact:periodicity}, as $K\ge \rho$ and $K\cdot|\mu|= 0\pmod{\lambda}$, 
    there exists a word $\nu_+$ of length $K\cdot|\mu|$ such that $p_1\xrightarrow{\nu_+}p_2$.
    This choice of $\phi,\nu_+,\nu_-$ and $\chi$ satisfies all the conditions of the lemma.
\end{proof}

\subsubsection{Constructing a Hard Distribution $\Dd$}
Let $\eps > 0$ be sufficiently small and let~$n$ be a large enough integer.
In what follows, $m$ denotes the number of states of~$\Aa$.
To construct the hard distribution $\Dd$, we will use an infinite family of blocking factors that share a common structure, given by \cref{lemma:good-bf}.

The crucial property here is that $\tau_{-,r}$ and $\tau_{+,r, s}$ are very similar: they have the same length, differ in at most~$S$ letters, yet one of them is blocking and the other is not.

We now use the words $\tau_{-,r}$ and $\tau_{+,r,s}$ and the constant $ S$ to describe how to sample an input $\mu = \twu$ of length~$n$ w.r.t. $\Dd$.

Let $\pi$ be a uniformly random bit. If $\pi = 1$, we will construct a positive instance $\mu \in \timedlang{\Aa}$, and otherwise the instance will be $\eps$-far from $\timedlang{\Aa}$ with high probability.
We divide the interval $[0 \dd n-1]$ into $k = \eps n$ intervals of length $\ell = 1/\eps$, plus small initial and final segments $\mu_i$ and $\mu_f$ of length $\cO(\rho)$ to be specified later.
For the sake of simplicity, we assume that~$k$ and $\ell$ are integers and that $\lambda$ divides $\ell$.
For $j=1,\ldots, k$, let $a_j, b_j$ denote the endpoints of the $j$-th interval.
For each interval, we sample independently at random a variable $\kappa_j$ with the following distribution:
\begin{equation}
    \kappa_j = \begin{cases}
        t, &\text{ with prob. } p_t = 3\cdot 2^t S\eps/\log(( S\eps)^{-1}) \text{ for } t = 1,2,\ldots, \log(( S\eps)^{-1}),\\
        0,&\text{ with prob. } p_0 = 1 - \sum_{t=1}^{{\log(( S\eps)^{-1})}} p_t.
    \end{cases} 
\end{equation}
The event $\kappa_j > 0$ means that the $j$-th interval is filled with $N \approx 2^{-\kappa_j}/\eps$ ``special'' factors.
When $\pi = 0$, these ``special'' factors will be minimal blocking factors $\tau_{-, r}$ for $r = 2^{\kappa_j}$, whereas when $\pi = 1$, they will instead be similar non-blocking factors $\tau_{+, r, s}$ for a uniformly random $s$: they will be hard to distinguish with few queries.
On the other hand, the event $\kappa_j = 0$ means that the $j$-th interval contains no specific information.
More precisely, we choose a positional word $\eta_*$ of length $\ell$ such that $q_* \xrightarrow{\eta_*} q_*$: by \cref{fact:periodicity}, this is possible as $\ell = 0 \pmod\lambda$. Then, if $\kappa_j = 0$, we set $\mu[a_j\dd b_j] = \eta_*$, regardless of the value of $\pi$.

Formally, if $\kappa_j > 0$, let $r = 2^{\kappa_j}$, $N = 2^{-\kappa_j}/( S\eps)$
and let $\eta$ be a word of length $\ell - N\cdot |\tau_{-,r}|$ such that $q_* \xrightarrow{\eta} q_*$: such a word exists as $\lambda$ divides $\ell$ and $|\tau_{-,r}|$.
We construct the $j$-th interval as follows:
\begin{itemize}
     \item if $\pi = 0$, we set $\mu[a_j\dd b_j] = (\tau_{-,r})^N\eta$,
     \item if $\pi = 1$, we select $s\in [0\dd  r-1]$ uniformly at random, and set $\mu[a_j\dd b_j] = (\tau_{+,r,s})^N\eta$.
\end{itemize}
Finally, the initial and final fragments $\mu_i$ and $\mu_f$ of $\mu$ are chosen to be the shortest words that label a transition from $q_0$ to $q_*$ and $q_*$ to a final state, respectively.

\subsubsection{Properties of the distribution $\Dd$}
Next, we establish that the distribution $\Dd$ has the desired properties.
\begin{observation}
    If $\eps$ is small enough, $\Dd$ is well-defined, i.e. for every~$t$ between~$0$ and $\log(( S\eps)^{-1})$, we have $0 \le p_t \le 1$.
\end{observation}

\begin{observation}
    If $\pi = 1$, then $\mu\in \timedlang{\Aa}$.
\end{observation}

\begin{lemma}\label{lemma:far-whp}
    Conditioned on $\pi = 0$, the probability of the event $\Ff = \{ \mu$ is $\eps$-far from $\timedlang{\Aa} \}$ goes to~$1$ as~$n$ goes to infinity.
\end{lemma}
\begin{proof}
    When $\pi = 0$, the procedure for sampling $\mu$ puts blocking factors of the form $\timedword{i_*}{x}$ at positions equal to $i_* \mod \lambda$. Any word containing such a factor at such a position is not in $\timedlang{\Aa}$, therefore any sequence of substitutions that transforms $\mu$ into a word of $\timedlang{\Aa}$ must make at least one substitution in every such factor.
    Consequently, the distance between $\mu$ and $\timedlang{\Aa}$ is at least the number of blocking factors in $\mu$. To prove the lemma, we show that this number is at least $\eps n$ with high probability, by showing that it is larger than $\eps n$ by a constant factor in expectation and using a concentration argument.

    Let $B_j$ denote the number of blocking factors in the $j$-th interval: it is equal to $2^{-\kappa_j}/( S\eps)$ when $\kappa_j>0$ and to~$0$ otherwise.
    
    \begin{claim}\label{claim:expe}
        Let $B = \sum_{j=1}^{k} B_j$, and let $E = \EE\left[B\right]$.
        We have $E \ge 2\eps n$.
    \end{claim}
    \begin{proof}[Claim proof]
        By direct calculation:
        \begin{align*}
            E &= \sum_{j=1}^{k}\EE\left[ B_j\right]= \sum_{j=1}^{k}\sum_{t= 1}^{\log( S/\eps)} 2^{-t}/( S\eps) \cdot p_t\\
                &= \sum_{j=1}^{k}\sum_{t= 1}^{\log( S/\eps)} 2^{-t}/( S\eps)\cdot  3\cdot2^t\eps S/\log( S/\eps) = \sum_{j=1}^{k}\sum_{t= 1}^{\log( S/\eps)} 3/\log( S/\eps)\\
                &= 3k \ge 2\eps n\qedhere
        \end{align*}
    \end{proof}

    We will now show that $\PP(B <\eps n)$ goes to~$0$ as~$n$ goes to infinity. We use Hoeffding's inequality, which we recall here:
    \begin{fact}[{\cite[Theorem 2]{hoeffding1994probability}}]\label{fact:hoeffding}
        Let $X_1,\ldots, X_k$ be independent random variables such that for every $i = 1,\ldots, k$, we have $a_i \le X_i \le b_i$, and let $S= \sum_{i=1}^k X_i$. Then, for any $t> 0$, we have \[\Prob{\EE[S] -S \ge t} \le \exp\left(-\frac{2t^2}{\sum_{i=1}^k (b_i-a_i)^2}\right).\]
    \end{fact}
    By \cref{claim:expe}, we have $B < \eps n \Rightarrow E-B\ge \eps n$, and therefore $\PP(B <\eps n) \le \PP(E-B\ge \eps n)$.
    The random variable~$B$ is the sum of~$k$ independent random variables, each taking values between~$0$ and $1/( S\eps)$.
    Therefore, by Hoeffding's inequality (\cref{fact:hoeffding}), we have
    \begin{flalign*}
        \PP(E - B <\eps n) 
            &\le \exp\left(-\frac{2\eps^2n^2}{k/( S\eps)^2}\right)\\
            &\le \exp\left(-\frac{2 S^2\eps^4n^2}{\eps n}\right) \text{ as } k \le \eps n\\
            &\le \exp\left(-2 S^2\eps^3n\right)
    \end{flalign*}
    This probability goes to~$0$ as~$n$ goes to infinity, which concludes the proof.
\end{proof}

\begin{corollary}\label{coro:large-fail-proba}
    For large enough~$n$, we have $\Prob{\Ff} \ge 5/12$.
\end{corollary}

Intuitively, our distribution is hard to test because positive and negative instances are very similar.
Therefore, a tester with few queries will likely not be able to tell them apart: the perfect completeness constraint forces the tester to accept in that case.
Below, we establish this result formally.
\begin{lemma}\label{lemma:must-accept}
    Let~$T$ be a deterministic tester with perfect completeness (i.e. it always accepts $\tau\in \timedlang{\Aa}$) and let $q_j$ denote the number of queries that it makes in the $j$-th interval.
    Conditioned on the event $\Mm = \{\forall j \text{ s.t. }\kappa_j > 0, q_j < 2^{\kappa_j}\}$, the probability that~$T$ accepts~$\mu \sim{}\Dd$ is~$1$.
\end{lemma}
\begin{proof}
    We proceed by contradiction, and show that if there exists a word $\tau$ with non-zero probability w.r.t. $\Dd$ under $\Mm$ that~$T$ rejects,
    then there exists a word $\tau'\in \timedlang{\Aa}$ that~$T$ rejects that also has non-zero probability, contradicting the fact that~$T$ has perfect completeness.

    Let $\tau$ be the word rejected by $T$: as~$T$ has perfect completeness, $\tau$ is not in $\timedlang{\Aa}$, and there must be at least one interval with $\kappa_j > 0$. Consider every interval~$j$ such that $\kappa_j > 0$: it is of the form $(\tau_{-,r})^N\eta$ where $r = 2^{\kappa_j}$ and $\tau_{-,r} = \phi(\nu_-)^r\chi$.
    Therefore, if $q_j < 2^{\kappa_j}$, then there is a copy of $\nu_-$ that has not been queried by~$T$ across all copies of $\tau_{-,r}$. Consider the word $\tau'$ obtained by replacing this copy of $\nu_-$ with $\nu_+$ in all~$N$ copies of $\tau_{-,r}$ in the block.
    The result block is of the form $(\tau_{+,r,s})^N\eta$ for some $s < r$, and by construction it is not blocking.
    Applying this operation to all blocks results in a word $\tau'$ that is in $\timedlang{\Aa}$.
    Furthermore, $\tau'$ has non-zero probability under $\Dd$ conditioned on $\Mm$: it can be obtained by flipping the random bit $\pi$ and choosing the right index~$s$ in every block.
\end{proof}

Next, we show that if a tester makes few queries, then the event $\Mm$ has large probability.

\begin{lemma}\label{lemma:proba-fail}
    Let~$T$ be a deterministic tester, let $q_j$ denote the number of queries that it makes in the $j$-th interval, and assume that~$T$ makes at most $\frac{1}{72}\cdot \log(S/\eps)/\eps$ queries, i.e. $\sum_j q_j \le \frac{1}{72}\cdot \log(S/\eps)/\eps$.
    The probability of the event $\Mm = \{\forall j \text{ s.t. }\kappa_j > 0, q_j < 2^{\kappa_j}\}$ is at least $11/12$.
\end{lemma}
\begin{proof}
    We show that the probability of $\overline{\Mm}$, the complement of $\Mm$, is at most $1/12$.
    We have:
    \begin{align*}
        \Prob{\overline{\Mm}} &=\Prob{\exists j: \kappa_j > 0 \land q_j \ge 2^{\kappa_j}}&\\
        &\le \sum_{j} \Prob{\kappa_j > 0 \land q_j \ge 2^{\kappa_j}} &\text{ by union bound}\\
        &\le \sum_{j} \sum_{t=1}^{\lfloor \log q_j \rfloor} p_t = \sum_{j} \sum_{t=1}^{\lfloor \log q_j \rfloor} \frac{3\cdot 2^t\eps}{\log( S/\eps)}&\text{ by def. of } p_t\\
        &\le \frac{3\eps}{\log( S/\eps)} \sum_{j} \sum_{t=1}^{\lfloor \log q_j \rfloor}  2^t&
    \end{align*}
    By upper bounding the sum of power of $2$ up to $k = \lfloor \log q_j \rfloor$ by $2^{k+1}$, we obtain:
    \begin{align*}
        \Prob{\overline{\Mm}} 
        &\le \frac{3\eps}{\log( S/\eps)} \sum_{j} 2q_j\\
        &= \frac{3\eps}{\log( S/\eps)} \cdot \frac{2}{72}\cdot \frac{\log(S/\eps)}{\eps}\\
        &\le 1/12\qedhere
    \end{align*}
\end{proof}

We are now ready to prove \cref{thm:scc-lb}.
\begin{proof}[Proof of \cref{thm:scc-lb}]
    We want to show that any tester with perfect completeness for $\lang{\Aa}$ requires at least $\frac{1}{72}\cdot \log(S/\eps)/\eps$ queries, by showing that any tester with fewer queries errs with probability at least $1/3$.
    We show that any \textbf{deterministic} algorithm~$T$ with perfect completeness that makes less than $\frac{1}{72}\cdot \log(S/\eps)/\eps$ queries errs on~$u$ when $\twu\sim{}\Dd$ with probability at least $1/3$, and conclude using Yao's Minimax principle.

    Consider such an algorithm~$T$.
    The probability that~$T$ makes an error on~$u$ is lower-bounded by the probability that~$u$ is $\eps$-far from $\lang{\Aa}$ and~$T$ accepts, which in turn is larger than the probability of $\Mm\cap \Ff$.
    By \cref{coro:large-fail-proba}, we have $\Prob{\Ff}\ge 5/12$, and by \cref{lemma:proba-fail}, $\Prob{\Mm}$ is at least $11/12$.
    Therefore, we have
     \[ \Prob{T \text{ errs}} \ge \Prob{\Mm\cap \Ff} \ge 1 - 7/12 - 1/12 = 4/12 = 1/3.\]
    This concludes the proof of \cref{thm:scc-lb}, and consequently of \cref{thm:scc}.
\end{proof}
 
\section{Characterisation of Hard Languages for All NFAs}
\label{sec:general}
In this section we extend the results of the previous section to all finite automata.
This extension is based on a generalization of blocking factors: we introduce \emph{blocking sequences}, which are sequences of factors that witness the fact that we cannot take any path through the strongly connected components of the automaton.
For the lower bound, we define a suitable partial order on blocking sequences, which extends the factor relation on words to those sequences, and allows us to define \emph{minimal} blocking sequences.

\subsection{Blocking sequences}\label{sec:blocking-seq}

\subsubsection{Examples motivating blocking sequences}

Before presenting the technical part of the proof, let us go through two examples, which motivate the notions that we introduce and illustrate some of the main difficulties.

\begin{example}
	Consider the automaton $\Aa_1$ depicted in \cref{fig:aut-ab-bc}: it recognizes the language $L_1$ of words in which all $c$'s appear before the first $b$, over the alphabet $\set{a,b,c}$.

	\begin{figure}[htbp]
	\begin{center}
		\begin{tikzpicture}[shorten >=1pt, node distance=3cm, on grid, auto,
			every initial by arrow/.style={thick}, every accepting by arrow/.style={thick}, >={stealth'}]
\tikzset{
				state/.style={
					circle,
					thick,
					draw,
					minimum size=8mm,
					inner sep=2pt
				},
				accepting/.style={
					state,
					accepting by arrow,
					accepting below
				}
			}
			
\node[state, initial , accepting] (q0) {$q_0$};
			\node[state, accepting] (q1) [right=of q0] {$q_1$};
			\node[state] (q2) [right=of q1] {$q_2$};
			
\path[->, thick, >=stealth']
			(q0) edge[above] node {\textcolor{red}{$b$}} (q1)
			(q1) edge[above] node {\textcolor{red}{$c$}} (q2)
			(q0) edge[loop above] node {$a, c$} ()
			(q1) edge[loop above] node {$a, b$} ()
			(q2) edge[loop above] node {$a, b, c$} ();
			
		\end{tikzpicture}
		\caption{An automaton $\Aa_1$ that recognizes the language $L_1 = (a+c)^* (a+b)^*$.}
		\label{fig:aut-ab-bc}
	\end{center}
	\end{figure}

	The set of minimal blocking factors of $\Aa_1$ is infinite: it is the language $ba^*c$.
	Yet, $L_1$ is easy to test: we sample $\cO(1 / \eps)$ letters at random, answer ``no'' if the sample contains a~$c$ occurring after a~$b$, and ``yes'' otherwise.
	To prove that this yields a property tester, we rely on the following property: 
	\begin{property}
		If $u$ is $\eps$-far from $L_1$, then it can be decomposed into $u = u_1 u_2$ where $u_1$ contains $\Omega(\eps n)$ letters $b$ and $u_2$ contains $\Omega(\eps n)$ letters $c$.
	\end{property}

	The pair of factors $(b, c)$ is an example of blocking sequence: a word that contains an occurrence of the first followed by an occurrence of the second cannot be in $L_1$.
	We can also show that a word $\eps$-far from $L_1$ must contains many disjoint blocking sequences -- this property (\cref{lem:far-from-path-implies-many-blocking}) underpins the algorithm for general regular languages.
	
	What this example shows is that blocking factors are not enough: we need to consider sequences of factors, yielding the notion of \emph{blocking sequences}.
	Intuitively, a blocking sequence for $L$ is a sequence $\sigma = (v_1,\ldots, v_k)$ of (positional) words such that if each word of the sequence appears in $u$, with the occurrences of the $v_i$'s ordered as in $\sigma$, then $u$ is not in $L$.\footnote{This is not quite the definition, but it conveys the right intuition.}
	While $L_1$ has infinitely many minimal blocking factors, it has a single minimal blocking sequence $\sigma = (b, c)$.
\end{example}

Notice that the (unique) blocking sequence $(b,c)$ can be visualized on \cref{fig:aut-ab-bc}:
it is composed of the red letters that label transitions between the different SCCs. This is no coincidence: in many simple cases, blocking sequences are exactly sequences that contain one blocking factors for each SCC.
This fact could lead one to believe that the set of minimal blocking sequences is exactly the set of sequences of minimal blocking factors, one for each SCC. In particular, this would imply that as soon as one SCC has infinitely many minimal blocking factors, the language of the whole automaton is hard to test.
We show in the next example that this is not always the case, because SCCs might share minimal blocking factors.
\begin{example}\label{example:hard-to-easy}
	Consider the automaton in \cref{fig:series}: it has two SCCs and a sink state.
	The minimal blocking factors of the first SCC are given by $B_1 = be^*c + a$, and $B_2 = \set{a}$ for the second SCC.
	This automaton is easy to test: intuitively, a word that is $\varepsilon$-far from this language has to contain many~$a$'s, as otherwise we can make it accepted by deleting all~$a$'s, thanks to the second SCC.
	However,~$a$ is also a blocking factor of the first SCC, therefore, as soon as we find two~$a$'s in the word, we know that it is not in $L_2$.
	\begin{figure}[htbp]
	\begin{center}
	\begin{tikzpicture}[shorten >=1pt, node distance=3cm, on grid, auto,
		every initial by arrow/.style={thick}, every accepting by arrow/.style={thick}, >={stealth'}]
\tikzset{
			state/.style={
				circle,
				thick,
				draw,
				minimum size=8mm,
				inner sep=2pt
			},
			accepting/.style={
				state,
				accepting by arrow
			}
}
		
\node[state , accepting, accepting below] (q1) {$q_1$};
		\node[state , initial, above=of q1] (q0) {$q_0$};
		\node[state, accepting, accepting below] (q2) [right=of q1] {$q_2$};
		\node[state] (q3) [right=of q2] {$q_3$};
		
\path[->, thick, >=stealth']
		(q1) edge[above] node {\textcolor{red}{$a,c$}} (q2)
		(q2) edge[above] node {\textcolor{red}{$a$}} (q3)
		(q0) edge[above right] node {\textcolor{red}{$a$}} (q2)
		(q1) edge[loop above] node {$b,e$} ()
		(q0) edge[loop above] node {$c, d, e$} ()
		(q2) edge[loop above] node {$b, c, d, e$} ()
		(q3) edge[loop above] node {$a, b, c,d,e$} ();
		
		\path[->, thick, >=stealth',bend right]
		(q1) edge[right] node {{$d$}} (q0)
		(q0) edge[left] node {{$b$}} (q1);
		
	\end{tikzpicture}
	\caption{An automaton $\Aa_2$ that recognizes the language $L_2 = [((c+d+e)^* b (b+e)^* d)^* a] (b+c+d+e)^*$.}
	\label{fig:series}
	\end{center}
	\end{figure}


	The crucial facts here are that the set $B_2$ of minimal blocking factors of the second SCC is finite and it is a subset of $B_1$: the infinite nature of $B_1$ is made irrelevant because any word far from the language contains many~$a$'s.
	Therefore, $\Aa_2$ has a \emph{single} minimal blocking sequence, $\sigma = (a)$.
\end{example}

\subsubsection{Portals and SCC-paths}

Intuitively, blocking sequences are sequences of blocking factors of successive strongly connected components. To formalize this intuition, we use \emph{portals}, which describe how a run in the automaton interacts with a strongly connected component, and \emph{SCC-paths}, that describe a succession of portals.

In what follows, we fix an NFA $\Aa = (Q, \Sigma, \delta, q_{0}, \set{q_f})$.
We assume w.l.o.g. that $\Aa$ has a unique final state $q_f$.
Let $\SCCset$ be the set of SCCs of $\Aa$.
We define the partial order relation $\leq_\Aa$ on $\SCCset$ by $S \leq_\Aa T$ if and only if $T$ is reachable from $S$.  We write $<_\Aa$ for its strict part $\leq_\Aa \setminus \geq_\Aa$. These relations can be naturally extended to states through their SCC: if $s\in S$ and $t\in T$, then $s\leq_\Aa t$ if and only if $S\leq_\Aa T$.

We define $p$ as the least common multiple of the lengths of all simple cycles of $\Aa$.
Given a number $k \in \ZZ/p\ZZ$, we say that a state $t$ is $k$-reachable from a state $s$ if there is a path from $s$ to $t$ of length $k$ modulo $p$.
In what follows, we use ``positional words'' for $p$-positional words with this value of $p$.

\begin{remark}
	In the rest of this section we will not try to optimize the constants in the formulas. They will, in fact, become quite large in some of the proofs.
	We make this choice to make the proofs more readable, although some of them are already technical.
	
	For instance, the choice of $p$ as the $\lcm$ of the lengths of simple cycles is not optimal: we could use, for instance, the $\lcm$ of the periods of the SCCs.
\end{remark}


\begin{definition}[Portal]
	A \emph{portal} is a 4-tuple $P = \portal{s}{x}{t}{y} \in (Q \times \ZZ/p\ZZ)^2$, such that $s$ and $t$ are in the same SCC. 
	It describes the first and last states visited by a path in an SCC, and the positions $x,y$ (modulo $p$) at which it first and lasts visits that SCC.
\end{definition}


The positional language of a portal is the set \[\timedlanguage{s}{x}{t}{y} = \set{(x:w) \mid s\xrightarrow{w}t \land x+|w| = y \pmod{p}}.\]
Portals were already defined by Alon et al.~\cite{alon2001regular}, in a slightly different way.
Our definition will allow us to express blocking sequences more naturally.

\begin{definition}
	A positional word $\timedword{n}{u}$ is blocking for a portal $P$ if it is not a factor of any word of $\lang{P}$.
	In other words, there is no path that starts in $s$ and ends in $t$, of length $y-x$ modulo $p$, which reads $u$ after $n-x$ steps modulo $p$.
\end{definition}

The above definition matches the definition of blocking factors for strongly connected automata. This is no coincidence: we show in the next lemma that the language of a portal has a strongly connected automaton.
\begin{lemma}\label{lemma:portal-to-SC}
    Let $\Aa$ be an automaton and $P$ a portal of $\Aa$.
    There is a strongly connected NFA with at most $p|\Aa|$ states that recognizes $L' = \lang{P}$.
\end{lemma}
\begin{proof}
    Let $S$ denote the SCC of $s$ and $t$ in $\Aa$, and let $\lambda$ denote its period. By definition of $p$, $\lambda$ divides $p$: let $k$ be the integer such that $p = \lambda k$.
    The automaton $\Aa'$ for $L'$ simulates the behavior of $\Aa$ restricted to $S$ starting from the state $s$, while keeping track of the number of letters read modulo $p$, starting from $x$.
    More precisely, let $Q_0,\ldots Q_{\lambda-1}$ be the partition of the states of $S$ given by \cref{fact:periodicity}.
    The set of states of $\Aa'$ is given by
    \[Q' = \set{(s', i + j\lambda) \mid s'\in Q_i \land i=0\ldots,\lambda-1 \land j = 0,\ldots, k-1}.\]
    It is a subset of $Q \times \ZZ/p\ZZ$, hence it has cardinality at most $p|\Aa|$.
    The transitions in $\Aa'$ are of the form $(s_1, i+j\lambda)\xrightarrow{(i,a)} (s_2, i+j\lambda+1\pmod{p})$
    for any $s_1,s_2$ such that $s_1\xrightarrow{a}s_2$ in $\Aa$. 
    
    Furthermore, $\Aa'$ is strongly connected.
    Let $i_1,i_2$ be indices of periodicity classes of $S$, and let $s_1\in Q_{i_1}, s_2\in Q_{i_2}$ be states of $S$.
    We show that for any $j_1,j_2 < k$, there is a path from $\sigma_1 = (s_1, i_1+j_1\lambda)$ to $\sigma_2 = (s_2, i_2+j_2\lambda)$ in $\Aa'$.
    Let $\ell$ be a sufficiently large integer equal to $(i_2-i_1)+(j_2-j_1)\lambda \pmod{p}$.
    As $\lambda$ divides $p$, $\ell$ is equal to $(i_2-i_1)\pmod{\lambda}$.
    By taking $\ell$ larger than the reachability constant of $S$, \cref{fact:periodicity} gives us that there is a path of length $\ell$ from $s_1$ to $s_2$ in $S$, labeled by some word $u$.
    The positional word $\timedword{x}{u}$ labels a transition from $\sigma_1$ to $\sigma_2$ in $\Aa'$, hence it is strongly connected.
    
    Note that the period of $\Aa'$ is $p$, hence we can apply the results we obtained on strongly connected NFAs in \cref{sec:scc} to portals, with $p |\Aa|$ as the number of states and $p$ as the period.
\end{proof}

Portals describe the behavior of a run inside a single strongly connected component of the automaton.
Next, we introduce SCC-paths, which describe the interaction of a run with multiple SCCs and between two successive SCCs.
\begin{definition}[SCC-path]
	An \emph{SCC-path} $\pi$ of $\Aa$ is a sequence of portals linked by single-letter transitions
	\(\SCCpath = \portal{s_0}{x_0}{t_0}{y_0} \xrightarrow{a_1} \portal{s_1}{x_1}{t_1}{y_1} \cdots  \xrightarrow{a_{k}} \portal{s_k}{x_k}{t_k}{y_k},\)
	such that for all $i \in \set{1, \ldots, k}$,  $x_i = y_{i-1} +1 \pmod{p}$, $t_{i-1}\xrightarrow{a_i} s_{i}$, and $t_{i-1}  <_{\Aa} s_i$.
\end{definition}
Intuitively, an SCC-path is a description of the states and positions at which a path through the automaton enters and leaves each SCC.

\begin{definition}\label{def:lang-of-sccpath}
	The language $\lang{\SCCpath}$ of an SCC-path $\SCCpath = P_0 \xrightarrow{a_1} P_1 \xrightarrow{a_2}\cdots  P_k$ is the set 
	\[\lang{\SCCpath} = \lang{P_0} a_1 \lang{P_2} a_2 \cdots \lang{P_k}.\]
\end{definition}

We say that $\SCCpath$ is \emph{accepting} if $P_0 = \portal{s_0}{x_0}{t_0}{y_0}$, $P_k = \portal{s_k}{x_k}{t_k}{y_k}$ with $x_0 = 0$, $s_0 = q_{0}$, $t_k = q_{f}$ and $\lang{\SCCpath}$ is non-empty.

\begin{lemma}\label{lemma:lang-path-union}
	We have \(\timedlang{\Aa} = \bigcup_{\SCCpath \text{ accepting}} \lang{\SCCpath}.\)
\end{lemma}
\begin{proof}
	We show that for any word $\mu$ in $\timedlang{\Aa}$, there is an accepting SCC-path $\SCCpath$ whose language contains $\mu$.
	Let $\mu = a_1 \cdots a_n$ be a word of length $n$ in $\timedlang{\Aa}$: there exists an accepting run $\rho = q_0 \xrightarrow{a_1} q_1 \cdots \xrightarrow{a_n} q_n = q_f$ in $\Aa$.
	
	We define the sequence of indices $i_0 < i_1 < \ldots < i_k <i_{k+1}$ as follows:
	\begin{itemize}
		\item $i_0 = 0, i_{k+1} = n+1$,
		\item for every $j=1,\ldots, k$, $i_j$ is the smallest index such that $q_{i_j-1} <_\Aa q_{i_j}$, i.e.~$q_{i_j-1}$ and~$q_{i_j}$ belong to distinct SCCs.
	\end{itemize}
	In other words, those are the indices at which $\rho$ enters a new SCC.
	We then define the SCC-path $\SCCpath(\rho)$ as follows:
	\[\SCCpath(\rho) = 
	\portal{q_0}{0}{q_{i_1-1}}{y_0} \xrightarrow{a_{i_1}} \portal{q_{i_1}}{x_1}{q_{i_2-1}}{y_1} \cdots  \xrightarrow{a_{i_k}} \portal{q_{i_k}}{x_k}{q_n}{y_k} \]
	where $x_j = i_j \pmod{p}$ and $y_j = x_{j+1}-1 \pmod{p}$ for all $j = 0, \ldots, k+1$.
	
	By construction, $\mu \in \lang{\SCCpath(\rho)}$ and $\SCCpath(\rho)$ is an accepting SCC-path.
	
	The converse inclusion follows by definition of (accepting) SCC-paths.
\end{proof}

As a consequence the distance between a word $\mu$ and the (positional) language of $\Aa$ is equal to the minimum of the distances between $\mu$ and the languages of the SCC-paths of $\Aa$.
\begin{corollary}\label{coro:dist-to-l-path}
	For any positional word $\mu$, we have \[d(\mu, \timedlang{\Aa}) = \min_{\SCCpath \text{ accepting}} d(\mu,\lang{\SCCpath}).\]
\end{corollary}

Decomposing $\Aa$ as a union of SCC-paths allows us to use them as an intermediate step to define blocking sequences.
We earlier defined blocking factors for portals: we now generalize this definition to blocking sequences for SCC-paths, to finally define blocking sequence of automata.

\begin{definition}[(Strongly) Blocking Sequences for SCC-paths]
	We say that a sequence $\sigma = (\mu_1, \ldots, \mu_\ell)$ of positional factors is blocking for an SCC-path 
	$\SCCpath = P_0 \xrightarrow{a_1} \cdots  P_k$ if there is a sequence of indices $i_0 \leq i_1 \leq \cdots \leq i_k$ 
	such that for every $j, \mu_{i_j}$ is blocking for~$P_j$.

	Furthermore, if there is a sequence of indices $i_0 < i_1 < \cdots < i_k$ with the same property, then~$\sigma$ is said to be \emph{strongly blocking} for~$\SCCpath$.
\end{definition}

Note that, crucially, in the definition of blocking sequences, consecutive indices $i_j$ and $i_{j+1}$ can be equal, i.e. a single factor of the sequence may be blocking for multiple consecutive SCCs in the SCC-path. This choice is motivated by \cref{example:hard-to-easy}, where the language is easy because consecutive SCCs share blocking factors.

We say that two occurrences of blocking sequences in a word $\mu$ are \emph{disjoint} if the occurrences of their factors appear on disjoint sets of positions in $\mu$.

In the strongly connected case, we had the property that if $\mu$ contains an occurrence of a factor blocking for $\Aa$, then $\mu$ is not in the language of $\Aa$.
The following lemma gives an extension of this result to \emph{strongly} blocking sequences and the language of an SCC-path.
\begin{lemma}\label{lem:strongly-blocking-implies-not-in-path}
	Let $\SCCpath$ be an SCC-path.
    If $\mu$ contains a strongly blocking sequence for~$\SCCpath$,
    then $\mu \notin \lang{\SCCpath}$.
\end{lemma}
\begin{proof}
	We proceed by induction on the length $k$ of the SCC-path $\SCCpath =  P_0 \xrightarrow{a_1} P_1 \cdots \xrightarrow{a_k} P_k$.
	Let $\sigma = (\nu_0,\ldots, \nu_k)$ be a strongly blocking sequence for $\SCCpath$ that occurs in $\mu$.
	If $k = 0$, then~$\sigma$ consists only of a blocking factor for $P_0$, hence $\mu$ is not in $\lang{P_0}$, which is equal to $\lang{\SCCpath}$.

	For $k > 0$, assume for the sake of contradiction that $\mu\in\lang{\SCCpath}$. By definition of $\lang{\SCCpath}$,
	$\mu$ can then be written as $\mu_0a_1\mu'$, with $\mu_0\in \lang{P_0}$ and $\mu' \in\lang{\SCCpath'}$, where $\SCCpath' = P_1 \xrightarrow{a_2}\cdots \xrightarrow{a_k} P_k$.
	As $\nu_0$ is blocking for $P_0$, the prefix $\mu_0$ of $\mu$ must end before the occurrence of~$\nu_0$ in~$\mu$, and the sequence $\sigma' = (\nu_1,\ldots, \nu_k)$ occurs in $\mu'$. 
	Furthermore, because $\sigma$ is \emph{strongly} blocking for~$\SCCpath$, $\sigma'$ is strongly blocking for~$\SCCpath'$.
	Using the induction hypothesis on~$\mu'$ and the path~$\SCCpath'$ of length $k-1$, this implies that $\mu' \notin\lang{\SCCpath'}$, a contradiction.
\end{proof}

We can now define sequences that are blocking for an automaton: they are sequences that are blocking for \emph{every} accepting SCC-path of the automaton.
\begin{definition}[{Blocking sequence for $\Aa$}]
    Let $\sigma = (\mu_1, \ldots, \mu_\ell)$ be a sequence of positional words.
    We say that $\sigma$ is blocking for $\Aa$ if it is blocking for all accepting SCC-paths of~$\Aa$.
\end{definition}
As an example, observe that the sequences $(\timedword{0}{ab}, \timedword{1}{ab})$ and $(\timedword{0}{aa}, \timedword{0}{b})$ are both blocking for the automaton displayed in \cref{fig:SCCpaths} (see \cref{ex:SCCpath}).

\begin{example}
	\label{ex:SCCpath}
	Consider the automaton displayed in \cref{fig:SCCpaths}.
	The $\lcm$ of the lengths of its simple cycles is $p=2$.
	This automaton has six accepting SCC-paths, including
	\begin{align*}
		\pi_1 &= \portal{q_0}{0}{q_0}{0} \xrightarrow{a} \portal{q_1}{1}{q_1}{1} \xrightarrow{a} \portal{q_3}{0}{q_3}{0} \xrightarrow{b} \portal{q_4}{1}{q_4}{1}\\
		\pi_2 &= \portal{q_0}{0}{q_0}{0} \xrightarrow{a} \portal{q_2}{1}{q_1}{0} \xrightarrow{a} \portal{q_3}{1}{q_3}{0} \xrightarrow{b} \portal{q_4}{1}{q_4}{1}
	\end{align*}

	The language of the portal $\pi_1$ is $a(ba)^*a(a^2)^*b$.
	A blocking sequence for this SCC-path is $(\timedword{0}{aa}, \timedword{0}{b})$, which is in fact blocking for all of the SCC-paths.

	\begin{figure}[htbp]
	\begin{center}
	\begin{tikzpicture}[shorten >=1pt, node distance=3cm, on grid, auto,
		every initial by arrow/.style={thick}, every accepting by arrow/.style={thick}, >={stealth'}]
\tikzset{
			state/.style={
				circle,
				thick,
				draw,
				minimum size=8mm,
				inner sep=2pt
			},
			accepting/.style={
				state,
				accepting by arrow
			}
		}
		
\node[state , initial] (q0) {$q_0$};
		\node[state ,right=of q0] (q1) {$q_1$};
		\node[state] (q2) [above=of q1] {$q_2$};
		\node[state] (q3) [right=of q1] {$q_3$};
		\node[state, accepting, accepting right] (q4) [above=of q3] {$q_4$};
		
\path[->, thick, >=stealth']
		(q0) edge[above] node {\textcolor{red}{$a$}} (q1)
		(q0) edge[above left] node {\textcolor{red}{$a$}} (q2)
		(q1) edge[above] node {\textcolor{red}{$a$}} (q3)
		(q2) edge[above] node {\textcolor{red}{$b$}} (q4)
		(q3) edge[right] node {\textcolor{red}{$b$}} (q4)
		(q3) edge[loop right] node {$a$} ();
		
		\path[->, thick, >=stealth',bend right]
		(q1) edge[right] node {{$b$}} (q2)
		(q2) edge[left] node {{$a$}} (q1);
	\end{tikzpicture}
	\caption{Automaton used for \cref{ex:SCCpath}.}
	\label{fig:SCCpaths}
	\end{center}
	\end{figure}

	On the other hand, $(\timedword{0}{ab})$ is not blocking for $\pi_1$, as $\timedword{0}{ab}$ is not a blocking factor for the portal $\portal{q_1}{1}{q_1}{1}$. It is, however, a blocking sequence for $\pi_2$.
	This is because if we enter the SCC $\set{q_1,q_2}$ through $q_1$, a factor $ab$ can only appear after an even number of steps, while if we enter through $q_2$, it can only appear after an odd number of steps.
\end{example}

\subsection{An efficient property tester}\label{sec:generic-ub}

In this section, we show that for any regular language $L$ and any small enough $\eps > 0$, there is an $\eps$-property tester for $L$ that uses $\cO(\epslogeps)$ queries.

\begin{theorem}\label{thm:gen-ub}
    For any NFA $\Aa$ and any small enough $\eps  >0$, there exists an $\eps$-property tester for $\lang{\Aa}$ that uses $\cO(\epslogeps)$ queries. 
\end{theorem}

As mentioned in the overview, this result supersedes the one  given by Bathie and Starikovskaya~\cite{bathie2021property}:
while both testers use the same number of queries, the tester in~\cite{bathie2021property} works under the edit distance, while that of \cref{thm:gen-ub} is designed for the Hamming distance. As the edit distance never exceeds the Hamming distance, the set of words that are $\eps$-far with respect to the former is contained in the set of words $\eps$-far for the latter. Therefore, an $\eps$-tester for the Hamming distance is also an $\eps$-tester for the edit distance, and this result is stronger.

The property tester behind \cref{thm:gen-ub} uses the property tester for strongly connected NFAs as a subroutine, and its correctness is based on an extension of \cref{lemma:many-short-blocking} to blocking sequences.
We show that we can reduce property testing of $\lang{\Aa}$ to a search for blocking sequences in the word, in the following sense:
\begin{itemize}
	\item If $\mu$ contains a strongly blocking sequence for each of the SCC-paths of $\Aa$, then it is not in the language and we can answer no (\cref{cor:many-strongly-bs-implies-not-A}).
	\item If $\mu$ is $\eps$-far from the language, then for each accepting SCC-path $\SCCpath$ of $\Aa$, $\mu$ is far from for the language of $\SCCpath$ and contains many disjoint strongly blocking sequences for $\SCCpath$ (\cref{lem:far-from-path-implies-many-blocking}), hence random sampling is likely to find at least one of them, and we reject $\mu$ with constant probability.
\end{itemize}

\begin{corollary}
	\label{cor:many-strongly-bs-implies-not-A}
	If $\mu$ contains a strongly blocking sequence for each SCC-path of~$\Aa$, then $\mu \notin \timedlang{\Aa}$.
\end{corollary}
\begin{proof}
	This follows from \cref{lemma:lang-path-union}.
\end{proof}

The next lemma expresses a partial converse to \cref{cor:many-strongly-bs-implies-not-A} and generalizes \cref{lemma:many-blocking} from the strongly connected case: if a word is far from the language, then it contains many strongly blocking sequences for any SCC-path.
\begin{lemma}
    \label{lem:far-from-path-implies-many-blocking}
    Let $\SCCpath  = P_0 \xrightarrow{a_1} \cdots  P_k$ be an SCC-path, let $L = \lang{\SCCpath}$, and let $\mu$ be a positional word of length $n$ such that $d(\mu, L)$ is finite.
    There is a constant $C$ such that if $n \geq C/\eps$
    and $\mu$ is $\eps$-far from $L$, then $\mu$ can be partitioned into $\mu = \mu_0\mu_1\cdots\mu_k$ such that for every $i = 0,\ldots, k$,
    $\mu_i$ contains at least $\frac{\eps n}{C}$ disjoint blocking factors for~$P_i$, each of length at most $\cO(1/\eps)$.
\end{lemma}
\begin{proof}
    We proceed similarly to the proof of \cref{lemma:many-blocking}, and only sketch this proof.
    Starting from the left end of $\mu$, we accumulate letters until we find a factor blocking for~$P_0$, and iterate again starting from~$p$ positions later, where~$p$ is the~$\lcm$ of the length of all cycles in~$\Aa$; notably, it is a multiple of the reachability constant of a strongly connected automaton recognizing $\lang{P_0}$. When we have found at least $K = \frac{\eps n}{C}$ blocking factors ($C$ is to be determined later) for $\lang{P_i}$, this position marks the end of~$\mu_i$, and we iterate with the next portal in $\SCCpath$.

    Let us assume that the process ends (i.e. we reach the right end of~$\mu$) before finding enough blocking factors for all portals. We show that in this case, the distance between~$\mu$ and $L$ is at most $\eps n$.
    Assume that we stop before finding enough blocking factors for the $i$-th portal, $P_i$.
    As in the proof of \cref{lemma:many-blocking}, we replace the last letter of each blocking factor and use the padding between them to make the run accepted by the SCC-path: this uses at most $((i+1)\cdot (K+1) + 2)p$ substitutions.
    If we set $C = 4(k+3)p$, this is less than $\eps n$ when $n \geq C/\eps$.
    Therefore, if $\mu$ is $\eps$-far from $\lang{\SCCpath}$, then the decomposition process finds at least $K$ blocking factors for $P_i$ in $\mu_i$ for each $i$.

    Then, since all of these factors are disjoint, we can use the same technique as in \cref{lemma:many-short-blocking} to show that at least half of these factors have length $\cO(1/\eps)$, and the result holds, up to doubling~$C$. 
\end{proof}

\begin{corollary}\label{cor:far-L-many-bs}
	Let $L = \timedlang{\Aa}$ and let $\mu$ be a positional word of length $n$.
	If $L$ contains a word of length $n$ and $\mu$ is $\eps$-far from $L$,
	then $\mu$ contains $\Omega(\eps n)$ disjoint blocking sequences for $\Aa$.
\end{corollary}
\begin{proof}
	We use a proof identical to that of \cref{lem:far-from-path-implies-many-blocking}, except that we consider a linear ordering of all the portals of $\Aa$ given by topological ordering, instead of the linear given by an SCC-path.
	The graph used for the topological ordering is the graph of all portals of $\Aa$, with an edge from $P$ to $P'$ when $P$ and $P'$ appear consecutively in some SCC-path of $\Aa$.
	Since any two portals in an SCC-path are from different SCCs of $\Aa$, this graph is acyclic, and its vertices can be topologically ordered.
\end{proof}

We are now ready to prove \cref{thm:gen-ub}.
\begin{proof}[Proof of \cref{thm:gen-ub}]
	Our algorithm iterates over all $K$ accepting SCC-paths~$\SCCpath = P_0\xrightarrow{a_1}\ldots\xrightarrow{a_k} P_k$ of~$\Aa$, and for each~$\SCCpath$, searches for blocking sequences for~$\SCCpath$ in $\mu = \twu$.
	If we find a strongly blocking sequence for $\SCCpath$ in $\mu$, then by \cref{lem:strongly-blocking-implies-not-in-path}, $\mu$ is not in $\timedlang{\Aa}$ and we can reject.
	Note that if $\mu\in\timedlang{\Aa}$, then the algorithm will not reject, hence the perfect completeness property is satisfied.

	Next, we show that if $\mu$ is $\eps$-far from $\timedlang{\Aa}$, then we can find a strongly blocking sequence for $\SCCpath$ with probability at least $1 - 1/(3K)$ using $\cO(\epslogeps)$ queries.
	Our algorithm is based on the following observation:
	\begin{observation}\label{obs:sbs-from-disj-factors}
		Let $\SCCpath  = P_0 \xrightarrow{a_1} \cdots  P_k$ be an SCC-path.
		Let $\nu_0, \ldots, \nu_k$ be positional words such that $\nu_i$ is blocking for $P_i$.
		Then, $\sigma = (\nu_0, \ldots, \nu_k)$ is a strongly blocking sequence of $\SCCpath$.
	\end{observation}

	We can assume w.l.o.g. that $\mu$ has length at least $2C/\eps$, where $C$ is the constant defined in \cref{lem:far-from-path-implies-many-blocking}, otherwise we can read all of $\mu$ using $\cO(1/\eps)$ queries.
	Therefore, we can apply \cref{lem:far-from-path-implies-many-blocking}, and $\mu$ can be partitioned into $k+1$ words $\mu_0,\ldots,\mu_k$ such that each $\mu_i$ contains at least $\eps n/C$ disjoint blocking factors for $C$, each of length $L = \cO(1/\eps)$.

	For each $i$, we can use the algorithm of \cref{lemma:generic-sampling-alg} to sample from $\mu$ a set $\Ff$ that contains a factor that contains a $\nu_i$ with probability at least $2/3$.
	By repeating the procedure $\cO(\ln(3K\cdot (k+1)))$ times and taking the union of all returned sets $\Ff$, we can increase this probability to $1 - \frac{1}{3K\cdot (k+1)}$.
	Then, by the union bound, we find a blocking factor~$\nu_i$ for each~$P_i$ in the corresponding~$\mu_i$ with probability at least $1 - 1/(3K)$. As observed above, the sequence $\sigma= (\nu_0, \ldots, \nu_k)$ is strongly blocking for $\pi$.

	By union bound again, this algorithm finds a strongly blocking sequence for each of the $K$ SCC-paths in $\Aa$, and therefore rejects $\mu$, with probability at least $2/3$.

	For a single $\mu_i$ of a given SCC-path, the sampling procedure uses $\cO(\epslogeps)$ queries (by \cref{claim:generic-sampling-alg-complexity}).
	As the lengths and number of SCC-paths in $\Aa$ does not depend on the input length, this algorithm uses $\cO(\epslogeps)$ queries in total.
\end{proof}



\subsection{Lower bound}

In order to characterize hard languages for all automata, we define a partial order $\pobs$ on sequences of positional factors.
It is an extension of the factor partial order on blocking factors. 
It will let us define \emph{minimal blocking sequences}, which we use to characterize the complexity of testing a language. 

\begin{definition}[Minimal blocking sequence]\label{def:MBS}
	Let $\sigma = (\mu_1, \mu_2, \ldots, \mu_k)$ and $\sigma' =  (\mu_1',\ldots, \mu_{t}')$ be sequences of positional words.
	We have $\sigma \pobs \sigma'$ if there exists a sequence of indices $i_1 \leq i_2 \leq \ldots \leq i_k$ such that $\mu_{j}$ is a factor of $\mu_{i_j}'$ for all $j = 1,\ldots, k$.
	
	A blocking sequence $\sigma$ of $\Aa$ (resp. $\SCCpath$) is \emph{minimal} if it is a minimal element of $\pobs$ among blocking sequences of $\Aa$ (resp. $\SCCpath$). The set of minimal blocking sequences of $\Aa$ (resp. $\SCCpath$) is written $\MBS(\Aa)$ (resp. $\MBS(\SCCpath)$).
\end{definition}

\begin{remark}
	If $\sigma \pobs \sigma'$ and $\sigma$ is a blocking sequence for an SCC-path $\pi$ then $\sigma'$ is also a blocking sequence for $\pi$.
\end{remark}

We make the remark that minimal blocking sequences have a bounded number of terms. This is because if we build the sequence from left to right by adding terms one by one, the minimality implies that at each step we should block a previously unblocked portal.
\begin{lemma}
    \label{lem:bound-length-min-blocking}
    A minimal blocking sequence for $\Aa$ contains at most $p^2|Q|^2$ terms.
\end{lemma}
\begin{proof}
    First, remark that there at most $p^2|Q|^2$ portals in $\Aa$.
    Let $\sigma = (\mu_1, \ldots, \mu_\ell)$ be a minimal blocking sequence for $\Aa$.
    For all $i = 1,\ldots, \ell$, we define $\sigma_i = (\mu_1, \ldots, \mu_i)$, and $\sigma_0$ is the empty sequence.
    
    Then, for each $i$, we consider the set $\Ss_i$ of portals $P$ such that for all accepting SCC-path $\SCCpath$ of $\Aa$ containing $P$, the prefix of $\SCCpath$ ending at $P$ is blocked by $\sigma_i$.
    We have $\Ss_0 = \emptyset$, and $\Ss_\ell$ is the set of all portals of $\Aa$.
    
    We claim that for every $i <\ell$, $\Ss_i$ is a proper subset of $\Ss_{i+1}$.
    Otherwise, if $\Ss_i = \Ss_{i+1}$, then removing $\mu_{i+1}$ from $\sigma$ gives a blocking sequence $\sigma'$ of $\Aa$, such that $\sigma'\pobs \sigma$, contradicting the minimality of $\sigma$.
    Therefore, it follows that $\ell \le p^2|Q|^2$.
\end{proof}

\subsubsection{Reducing to the strongly connected case}

To prove a lower bound on the number of queries necessary to test a language when $\MBS(\Aa)$ is infinite, we present a reduction to the strongly connected case.
Under the assumption that $\Aa$ has infinitely many minimal blocking sequences, we exhibit a portal $P$ of $\Aa$ with infinitely many minimal blocking factors and ``isolate it'' by constructing two sequences of positional factors $\sigma_l$ and $\sigma_r$ such that for all $\mu$, $\sigma_l, (\mu), \sigma_r$ is blocking for $\Aa$ if and only if $\mu$ is a blocking factor of $P$.
Then we reduce the problem of testing the language of this portal to the problem of testing the language of $P$.

To define ``isolating $P$'' formally, we define the left (and right) effect of a sequence on an SCC-path.
Informally, the left effect of a sequence $\sigma$ on an SCC-path $\SCCpath$ is related to the index of the first portal in $\SCCpath$ where a run can be after reading $\sigma$, because all previous portals have been blocked. 
The right effect represents the same in reverse, starting from the end of the run.

More formally, the \emph{left effect} of a sequence $\sigma$ on an SCC-path $\SCCpath = P_0 \xrightarrow{a_1} \cdots P_k$ is the largest index $i$ such that the sequence is blocking for $P_0 \xrightarrow{a_1} \cdots P_i$ ($-1$ if there is no such~$i$). We denote it by $\lefteffect{\sigma}{\SCCpath}$.
Similarly, the \emph{right effect} of a sequence on $\pi$ is the smallest index~$i$ such that the sequence is blocking for $P_i \xrightarrow{a_{i+1}} \cdots P_k$  ($k+1$ if there is no such~$i$); we denote it by $\righteffect{\sigma}{\pi}$.

\begin{remark}
	A sequence $\sigma$ is blocking for an SCC-path $\SCCpath = P_0 \xrightarrow{a_1} \cdots  P_k$ if and only if $\lefteffect{\sigma}{\SCCpath} = k$, if and only if $\righteffect{\sigma}{\SCCpath} = 0$.
	
	Also, given two sequences $\sigma_l, \sigma_r$, the sequence $\sigma_l \sigma_r$ is blocking for $\SCCpath$ if and only if $\lefteffect{\sigma_l}{\SCCpath} \ge \righteffect{\sigma_r}{\SCCpath}$.
\end{remark}

For the next lemma we define a partial order on portals:
$P \leqportals P'$ if all blocking factors of $P'$ are also blocking factors of $P$.
We write $\geqportals$ for the reverse relation, $\equivportals$ for the equivalence relation $\leqportals \cap \geqportals$ and $\nequivportals$ for the complement relation of $\equivportals$.

Additionally, given an SCC-path~$\SCCpath = P_0\xrightarrow{x_1} \ldots P_k$ and two sequences of positional words $\sigma_l, \sigma_r$, we say that the portal $P_i$ \emph{survives $(\sigma_l, \sigma_r)$ in $\SCCpath$} if $\lefteffect{\sigma_l}{\SCCpath} < i < \righteffect{\sigma_r}{\SCCpath}$.

\begin{definition}
	Let $P$ be a portal and  $\sigma_l$ and $\sigma_r$ sequences of positional words.
	
	We define three properties that those objects may have:
	\begin{description}\item[P1)] $\sigma_l \sigma_r$ is not blocking for $\Aa$
		\item[P2)] $P$ has infinitely many minimal blocking factors
		\item[P3)] for any accepting SCC-path $\SCCpath$ in $\Aa$, 
		every portal in $\SCCpath$ which survives $(\sigma_l, \sigma_r)$ is $\equivportals$-equivalent to $P$.
	\end{description}
\end{definition}

\begin{restatable}{lemma}{HardAutHardPortal}
	\label{lem:hard-aut-to-hard-portal}
	If $\Aa$ has infinitely many minimal blocking sequences, then there exist a portal $P$ and sequences $\sigma_l$ and $\sigma_r$ satisfying properties P1, P2 and P3.
\end{restatable}
\begin{proof}
	By \cref{lem:bound-length-min-blocking}, a minimal blocking sequence has a bounded number of elements.
	Therefore, if $\Aa$ as an infinite number of minimal blocking sequences, there exists an integer~$i_*$ and an infinite family $(\sigma_j)_{j\in\NN}$ of minimal blocking sequences of $\Aa$ such that the length of~$i_*$-th term of $\sigma_j$ is at least $j$, for every $j$. 
	For each $j$, let $\sigma_{j, l}$ denote the sequence containing the elements of $\sigma_j$, up to index $i_*-1$,
	and let $\sigma_{j, r}$ denote the sequence with the elements starting from index $i_* + 1$.
	As there is a finite number of SCC-paths in $\Aa$, we can extract from the sequence $(\sigma_j)_j$ an infinite subsequence $(\sigma_j')_{j\in \NN}$ such that for all SCC-paths $\SCCpath$ of $\Aa$,  all of the $\sigma_{j, l}$ have the same left effect as $\sigma_l = \sigma_{0, l}$ on $\SCCpath$, and symmetrically for the right effect of the $(\sigma_{j, r})_j$ and $\sigma_r = \sigma_{0, r}$.

	Then, we can replace $\sigma_{j, l}$ with $\sigma_{l}$ and $\sigma_{j, r}$ with $\sigma_{r}$ in each $\sigma_j'$, to obtain an infinite sequence of minimal blocking sequences of the form $(\sigma_l, \nu_j, \sigma_r)$, where each $\nu_j$ is a positional word of length at least $j$.
	As these blocking sequences are minimal, the pair $(\sigma_{l}, \sigma_{r})$ is not blocking for $\Aa$, there is an accepting SCC-path~$\SCCpath_*$ and a portal~$P_*$ that survives $(\sigma_{l}, \sigma_{r})$ in that~$\SCCpath_*$.
	If there are multiple possible choices for~$\SCCpath_*$ and~$P_*$, we choose them so that~$P_*$ is $\leqportals$-minimal among the possible choices.
	The following claim shows that we can choose such a $P_*$ with infinitely many minimal blocking factors.

	\begin{claim}
		There exists such a $P_*$ with infinitely many minimal blocking factors.
	\end{claim}
	\begin{claimproof}
		The word $\nu_j$ is blocking for all portals that survive $(\sigma_{l}, \sigma_{r})$, and there are arbitrarily long~$\nu_j$ such that $(\sigma_l, \nu_j, \sigma_r)$ is a minimal blocking sequence.
		Therefore, all letters in each $\nu_j$ must belong to a minimal blocking factor of some $\leqportals$-minimal portal, hence one of them has infinitely many minimal blocking factors.
	\end{claimproof}

	So far, properties P1 and P2 are satisfied.
	Next, we extend the sequences $\sigma_l$ and $\sigma_r$ until the property P3 is satisfied, while preserving properties P1 and P2.

	\begin{claim}
		There exist $\sigma_l, \sigma_r$ such that
		$\sigma_l \sigma_r$ is not a blocking sequence for $\Aa$, and
		for any accepting SCC-path $\pi$ in $\Aa$, 
		every surviving portal in $\pi$ is $\equivportals$-equivalent to $P_*$.
	\end{claim}
	\begin{claimproof}
		Note that for each $P \nequivportals P_*$, we can pick a positional word~$\tau_{P}$ that is blocking for~$P$ but not for~$P_*$, since~$P_*$ is $\leqportals$-minimal.
		
		We extend $\sigma_l$ and $\sigma_r$ as follows.
		While there is a surviving portal $P$ that is not $\equivportals$-equivalent to $P_*$:
		\begin{itemize}
			\item We pick an SCC-path $\SCCpath = P_0 \xrightarrow{a_1}\ldots P_k$ such that $P$ survives in $\SCCpath$.
			
			\item Let $i_\ell = \lefteffect{\sigma_l}{\SCCpath}$ and $i_r = \righteffect{\sigma_r}{\SCCpath}$
			
			\item If for all $i \in \set{i_\ell+1,\ldots,i_r-1}$, $P_i \nequivportals P_*$ then we append at the end of $\sigma_l$ the sequence $\tau_{P_{i_\ell+1}}, \ldots, \tau_{P_{i_r-1}}$.
			The sequence $\sigma_l \sigma_r$ is now blocking for $\SCCpath$.
			On the other hand, since we did not add any blocking factor for $P_*$, there must still be a surviving portal that is $\equivportals$-equivalent to it.
			
			\item If there is an $i \in \set{i_\ell+1,\ldots,i_r-1}$ such that $P_i \equivportals P_*$ then let $c$ be the maximal index in $\set{i_\ell+1, \ldots, i}$ such that $P_c$ is not equivalent to $P_*$ for $\equivportals$, or $i_\ell$ if there is no such index. 
			Symmetrically, let $d$ the minimal index in $\set{i, \ldots, i_r-1}$ such that $P_d \nequivportals P_*$, or $i_r$ if there is no such index.
			We append at the end of $\sigma_l$ the sequence $\tau_{P_{i_\ell+1}}, \ldots, \tau_{P_{c}}$.
			We append at the beginning of $\sigma_r$ the sequence $\tau_{P_d}, \ldots, \tau_{P_{i_r-1}}$.
			Now all surviving portals in $\SCCpath$ are $\equivportals$-equivalent to $P_*$, and $P_i$ still survives.
		\end{itemize}
		
		We iterate this step until all surviving portals are $\equivportals$-equivalent to $P_*$.
		We made sure that at least one portal was still surviving after each step, hence in the end the sequence~$\sigma_l \sigma_r$ is not blocking for $\Aa$.
	\end{claimproof}
\end{proof}

\begin{lemma}
	\label{lem:seq-left}
	Let $\SCCpath = P_0 \xrightarrow{a_1} \cdots  P_\ell$ be an accepting SCC-path,
	denote $P_j = \portal{s_j}{x_j}{t_j}{y_j}$ for each $j = 0,\ldots,\ell$,
	let $i \in \set{0, \ldots, \ell}$,
	and let $\sigma_l = (\nu_{1,l}, \ldots, \nu_{k,l})$ be a sequence such that $\lefteffect{\sigma_l}{\SCCpath} < i$.

	Then, for any integer $N \in \NN$, there is a positional word $w_l^*$ of length at most $(3|\Aa|^3+|\Aa|)(k+1)  + N(2p^2+p)k|\Aa| + pN\sum_{t=1}^k|\nu_{t,l}|$ such that $|w_l^*| = x_i-x_0 \pmod{p}$, there is a run reading $w_l^*$ from $s_0$ to $s_i$ in $\Aa$, and $\timedword{x_0}{w_l^*}$ contains $N$ occurrences of $\nu_{1,l}$, followed by $N$ occurrences of $\nu_{2,l}$, etc. up to $\nu_{k,l}$, all disjoint.
\end{lemma}
\begin{proof}	
	We define $w_l^*$ by induction on $k$, the length of $\sigma_l$.
	As $\SCCpath$ is accepting, by definition its language $\lang{\SCCpath}$ is nonempty, and thus for all $j \in \set{0, \ldots, \ell}$, there exists a word $u_j$ of length $y_j-x_j \pmod{p}$ that labels a path from $s_j$ to $t_j$.
	By \cref{fact:periodicity}, there is such a word $u_j$ of length at most $3|\Aa|^2$.
	As a result, for all $z \in \set{0, \ldots, \ell}$ we can form a word $w_z = u_0 a_1 u_1 \cdots a_{z}$, of length at most $3 |\Aa|^3 + |\Aa|$, that labels a path of length $x_z-x_0 \pmod{p}$ from $q_{0}$ to $s_z$ in $\Aa$.
	If $k=0$, we can simply set $w_l^* = w_i$.
	
	Let $k> 0$, and assume that the lemma holds for $k-1$.
	Let $j = \lefteffect{\nu_{1,l}}{\SCCpath}$.
	As $\lefteffect{\nu_{1,l}}{\SCCpath} \leq \lefteffect{\sigma_l}{\SCCpath} < i$, we have $j<i$, hence $\nu_{1,l}$ is not blocking for $P_{j+1}$.
	As a consequence, there is a word $v_j$ that labels a path from $s_j$ to $t_j$ such that $\tau_j = \timedword{x_j}{v_j}$ has $\nu_{1,l}$ as a factor.
	We can remove cycles of length $0 \pmod{p}$ in that path, before and after reading $\tau_j$, so we can assume that $|v_j| \leq |\nu_{1,l}| + 2p|\Aa|$. 
	As $s_j$ and $t_j$ are in the same SCC, we can extend $v_j$ into a word $v'_j$ of length at most $|v_j| + |\Aa| \leq |\nu_{1,l}| + (2p+1)|\Aa|$ that labels a cycle from $s_j$ to itself.
	
	Let $\sigma' = (\nu_{2,l}, \ldots, \nu_{k,l})$ and $\SCCpath' = P_{j+1} \xrightarrow{a_{j+2}} \cdots  P_\ell$.
	As $\sigma_l$ is the concatenation of $\nu_{1,l}$ and $\sigma'$, and $j = \lefteffect{\nu_{1,l}}{\SCCpath}$, we have $\lefteffect{\sigma'}{\SCCpath'} < i-j-1$.
	By induction hypothesis, there is a word $w'$ of length at most $(3|\Aa|^3+|\Aa|)k  + N(2p^2+p)(k-1)|\Aa| + pN\sum_{t=2}^{k}|\nu_{t,l}|$ such that $|w'| = x_i-x_{j+1} \pmod{p}$, there is a run reading $w'$ from $s_{j+1}$ to $s_i$ in $\Aa$, and $\timedword{x_{j+1}}{w'}$ contains $N$ occurrences of $\nu_{t,l}$, all disjoint, for each $t = 2,\ldots, k$.

	We set $w_l^* = w_{j+1} (v'_j)^{pN} w'$. This word has length $x_i-x_0 \pmod{p}$, and satisfies:
	\begin{align*}
		|w_l^*| 
			&\le|w_{j+1}|+pN|v'_j|+ |w'|\\
			&\le 3|\Aa|^3+|\Aa| + pN(|\nu_{1,l}| + (2p+1)|\Aa|) +|w'|\\
			&\le (3|\Aa|^3+|\Aa|)(k+1)  + N(2p^2+p)k|\Aa| + pN\sum_{t=1}^k|\nu_{t,l}|.
	\end{align*}
	By construction, the word $\timedword{x_0}{w_l^*}$ labels a path from $s_0$ to $s_i$, and contains $N$ occurrences of $\nu_{1,l}$, followed by $N$ occurrence of $\nu_{2,l}$, etc. up to $\nu_{k,l}$, all disjoint, which concludes the proof.
\end{proof}

\begin{lemma}
	\label{lem:seq-right}
	Let $\SCCpath = P_0 \xrightarrow{a_1} \cdots  P_\ell$ be an accepting SCC-path,
	denote $P_j = \portal{s_j}{x_j}{t_j}{y_j}$ for each $j = 0,\ldots,\ell$,
	let $i \in \set{0, \ldots, \ell}$,
	and let $\sigma_r = (\nu_{1,r}, \ldots, \nu_{k,r})$ be a sequence such that $\lefteffect{\sigma_l}{\SCCpath} < i$.

	Then, for any integer $N \in \NN$, there is a word $w_r^*$ of length at most $(3|\Aa|^3+|\Aa|)(k+1)  + N(2p^2+p)k|\Aa| + pN\sum_{i=1}^k|\nu_{i,r}|$ such that $|w_r^*| = x_i-x_0 \pmod{p}$, there is a run reading $w_r^*$ from $s_0$ to $s_i$ in $\Aa$, and $\timedword{x_0}{w_r^*}$ contains $N$ occurrences of $\nu_{1,r}$, followed by $N$ occurrence of $\nu_{2,r}$, etc. up to $\nu_{k,r}$, all disjoint.
\end{lemma}
\begin{proof}
	By a proof symmetric to the one of the previous lemma.
\end{proof}


Given a sequence $\sigma$, define $\sigmasize{\sigma}$ as the sum of the lengths of the terms of $\sigma$.
\begin{restatable}{lemma}{PropertiesImpliesHard}
	\label{lem:P1-P3-then-hard}
	If there exist a portal $P$ and $\sigma_l$, $\sigma_r$ satisfying properties P1, P2 and P3 then $\lang{\Aa}$  is hard.
\end{restatable}
\begin{proof}[Proof of \cref{lem:P1-P3-then-hard}]
	A direct consequence of properties P1 and P3 is that for all $\nu'$, then $\sigma_l \nu' \sigma_r$ is blocking for $\Aa$ if and only if $\nu'$ is blocking for $P$.
	
	The proof goes as follows: we show that we can turn an algorithm testing $\lang{\Aa}$ with~$f(\eps)$ samples into an algorithm testing $\lang{P}$ with $f(\eps/X)$ samples with $X$ a constant.
	We then apply \cref{thm:scc-lb} from the strongly connected case to obtain the lower bound.
	
	Consider an algorithm testing $\lang{\Aa}$ with $f(\eps)$ samples for some function $f$.
	We describe an algorithm for testing $\lang{P}$.
	Say we are given a threshold $\eps$ and a word $v$ of length $n$.
	First of all we can apply Lemmas~\ref{lem:seq-left} and~\ref{lem:seq-right} to compute two words $w_l^*$ and $w_r^*$ of length at most $E + \eps n F$ for some constants $E$ and $F$ such that we can read~$w_l^*$ from $q_{0}$ to $s$ and $w_r^*$ from $t$ to $q_f$ and $w_l^*$ contains occurrences of each element of $\sigma_l$ at least $\eps n$ times, all disjoint, with all occurrences of the $i$-th of $\sigma_l$ appearing before element~$j$ for $i<j$, and similarly for $w_r^*$ and $\sigma_r$.
	Let $w = w_l^* v w_r^*$, and assume that $|v| \geq \frac{6p^2|\Aa|^2}{\eps}$ and that~$d(v, \lang{P}) < + \infty$.
	
	\begin{itemize}
		\item If $v \in \lang{P}$ then clearly $w \in \lang{\Aa}$.
		\item If $d(v, \lang{P}) \geq \eps n$ then by \cref{lemma:many-blocking} (in light of \cref{lemma:portal-to-SC}), $\timedword{x}{v}$ contains at least $\frac{\eps n}{6p^2|\Aa|^2}$ blocking factors for $P$. 
		Then we have that $w$ contains at least $\frac{\eps n}{6p^2|\Aa|^2}$ disjoint blocking sequences for $\Aa$.
		As a result, $d(w, \lang{\Aa}) \geq \frac{\eps n}{6p^2|\Aa|^2}$. 
		We divide this by the length of $w$, which is at most $2E +  2F \eps n + n$. We obtain that $d(w, \lang{\Aa}) \geq \frac{\eps}{X} |w|$ for some constant $X$. 
	\end{itemize}
	
	Let us now describe the algorithm for testing $\lang{P}$.
	\begin{itemize}
		\item If $\lang{P} \cap \Sigma^{n} = \emptyset$ then we reject.
		
		\item If $|v| < \frac{6p^2|\Aa|^2}{\eps}$ then we read $v$ entirely and check that it is in $\lang{P}$.
		
		\item If $v \in \lang{P}$ then we apply our algorithm for testing $\lang{\Aa}$ on $w = w_l^* v w_r^*$ with parameter $\eps' =\frac{\eps}{X}$.
	\end{itemize}
	
	The number of queries used on $v$ is at most the number of queries needed on $w$, hence at most~$f(\eps / X)$ queries.
	We obtain a procedure to test $\lang{P}$ using $f(\eps/X)$ queries.
	By \cref{thm:scc-lb}, $f(\eps/X) = \Omega(\epslogeps)$, hence $f(\eps) = \Omega(\epslogeps)$.
	This concludes our proof.
\end{proof}

\begin{proposition}
		If $\Aa$ has infinitely many minimal blocking sequences, 
		then $\lang{\Aa}$ is hard.
\end{proposition}
\begin{proof}
	We combine Lemmas~\ref{lem:hard-aut-to-hard-portal} and~\ref{lem:P1-P3-then-hard}.
\end{proof} 
\section{Trivial and Easy languages}
\label{sec:trivial-easy}
\subsection{Upper bound for easy languages}

We first establish that an automaton with finitely many minimal blocking sequences is easy (or trivial) to test.

\begin{lemma}\label{lem:far-bounded-mbs}
	Let $\Aa$ be an NFA with a finite number of minimal blocking sequences,
    let~$\SCCpath  = P_0 \xrightarrow{a_1} \cdots  P_k$ be an SCC-path of $\Aa$, let $L = \lang{\SCCpath}$, and let $\mu$ be a positional word of length $n$ such that $d(\mu, L)$ is finite.
    There are constants $B, D$ such that if $n \geq 2D/\eps$
    and $\mu$ is $\eps$-far from $L$, then $\mu$ can be partitioned into $\mu = \tau_0\tau_1\cdots\tau_k$ such that for every $i = 0,\ldots, k$,
    $\tau_i$ contains at least $\frac{\eps n}{D}$ disjoint blocking factors for~$P_i$, each of length at most~$B$.
\end{lemma}
\begin{proof}
	By \cref{cor:far-L-many-bs}, the positional word $\mu$ contains $N \ge \eps n/C$ disjoint blocking sequences $(\sigma_j)_{j=1,\ldots, N}$ for $\Aa$, for some constant $C$.
	We can extract from each $\sigma_j$ a minimal blocking sequence $\sigma_j' = (\nu_{0,j},\ldots, \nu_{s_j, j})$.
	By definition of blocking sequences, $\sigma_j'$ is also blocking for  $\SCCpath$.
	
	As $\Aa$ has a finite number of minimal blocking sequences, hence there is a constant $B$ such that any $\nu_{i,j}$ has length at most $B$.

	We build the decomposition $\mu = \tau_0\tau_1\cdots\tau_k$ with the following iterative process.
	For the index $i = 0$, we set $\tau_0$ to the shortest prefix of $\mu$ that contains the leftmost $N/(k+1)$ components of the $\sigma_j'$ that are blocking for $P_0$.
	Since the $(\sigma_j)_j$ are disjoint in $\mu$, so are the $(\nu_{i,j})_{i,j}$, and this leaves us with at least $N(1-1/(k+1))$ of the $\sigma_j'$ that have their component blocking for $P_0$, and therefore also for $P_1$ in the part of~$\mu$ outside of~$\tau_0$.
	We then iterate again for $i=1,\ldots, k+1$, with the invariant that at step $i$, we have $N(1-i/(k+1))$ of the $\sigma_j'$ that have their component blocking for $P_i$ outside for $\tau_0\ldots\tau_{i-1}$. We then take for~$\tau_i$ the shortest prefix of the rest of~$\mu$ that contains the leftmost $N/(k+1)$ components of these~$\sigma_j'$ that are blocking for $P_i$.

	At each step, the factor~$\tau_i$ contains $N/(k+1)$ blocking factors for $P_i$, hence the decomposition $\mu = \tau_0\tau_1\cdots\tau_k$ has the desired property for $D = C\cdot (k+1)$.
\end{proof}

\begin{proposition}
	\label{coro:fin-bs-then-easy}
	If $\Aa$ has finitely many minimal blocking sequences, then there is a tester for $\lang{\Aa}$ that uses $\cO(1/\eps)$ queries.
\end{proposition}
\begin{proof}
	We use the same algorithm that for \cref{thm:gen-ub}, except that we use the factors given by \cref{lem:far-bounded-mbs}, therefore, in the call to the \textsc{Sampler} function (\cref{alg:generic-sampling}), the upper bound on the length of the factors is~$B$ instead of $\cO(1/\eps)$.
	In that case, the query complexity becomes $\cO(\log(B)/\eps) = \cO(1/\eps)$.
\end{proof}

This already gives us a clear dichotomy: all languages either require $\Theta(\epslogeps)$ queries to be tested, or can be tested with $\cO(1/\eps)$ queries.


\subsection{Separation between trivial and easy languages}

It remains to show that languages that can be tested with $\cO(1/\eps)$ queries have query complexity either $\Theta(1/\eps)$, or $0$ for large enough $n$.
Our proof uses the class of \emph{trivial} regular languages identified by Alon et al.~\cite{alon2001regular}, which we revisit next.

An example of a trivial language is $L_2$ consisting of words containing at least one $a$ over the alphabet $\set{a,b}$.
For any word $u$, replacing any letter by $a$ yields a word in $L_2$, hence $d(u,L_2) \le 1$.
Therefore, for $n > 1/\eps$, no word of length $n$ is $\eps$-far from $L_2$, and the trivial property tester that answers ``yes'' without sampling any letter is correct.

Alon et al.~\cite{alon2001regular} define non-trivial languages as follows.
\begin{restatable}[{\cite[Definition 3.1]{alon2001regular}}]{definition}{trivialalondef}\label{def:trivial-alon}
	A language~$L$ is non-trivial if there exists a constant $\eps_0 > 0$, so that for infinitely
	many values of $n$ the set $L\cap\Sigma^n$ is non-empty, and there exists a word $w \in \Sigma^n$ so that $d(w, L) \ge \eps_0 n$.
\end{restatable}
It is easy to see that if a language is trivial in the above sense (i.e. not non-trivial), then for large enough input length $n$, the answer to testing membership in~$L$ only depends $n$, and the algorithm does not need to query the input.
Alon et al.~\cite[Property 2]{alon2001regular} show that if a language is non-trivial, then testing it requires $\Omega(1/\eps)$ queries for small enough $\eps > 0$.

To obtain our characterization of \emph{trivial} languages, we show that $\MBS(\Aa)$ is non-empty if and only if $\lang{\Aa}$ is non-trivial (in the above sense).
It follows that if $\MBS(\Aa)$ is empty, then testing $\lang{\Aa}$ requires $0$ queries for large enough $n$.
Furthermore, by the result of Alon et al.~\cite{alon2001regular}, if $\MBS(\Aa)$ is non-empty, then testing $\lang{\Aa}$ requires $\Omega(1/\eps)$ queries.

Recall that we focus on infinite languages, since we know that all finite ones are trivial (Remark~\ref{rmk:finite}). 
\begin{lemma}\label{lem:trivialiffMBSempty}
	$\MBS(\Aa)$ is empty if and only if $L = \lang{\Aa}$ is trivial.
\end{lemma}

We prove the two directions separately.
\begin{lemma}
	If $\MBS(\Aa)$ is empty, then $L = \lang{\Aa}$ is trivial in the sense of \cref{def:trivial-alon}.
\end{lemma}
\begin{proof}
	We showed in \cref{cor:far-L-many-bs} that if $\mu$ is long enough and $\eps$-far from $L$,
	then~$\mu$ contains $\Omega(\eps n)$ disjoint blocking sequences for $\Aa$.
	As $\Aa$ has no minimal blocking sequences, it does not have blocking sequences either, and long enough words cannot be $\eps$-far from $L$, hence it is trivial in the sense of \cref{def:trivial-alon}.
\end{proof}

To prove the converse property, we need the following extension of Kleene's Lemma for languages of SCC-paths: for large enough~$\ell$, whether $\lang{\SCCpath}$ contains a word of length~$\ell$ only depends on the value of~$\ell$ modulo~$p$ ($p$ is the $\lcm$ of all the lengths of the simple cycles in $\Aa$).
\begin{lemma}
    Let $\SCCpath = P_0 \xrightarrow{a_1} \cdots P_k$ be an SCC-path.
    There exists a constant $B $ such that, for all $\ell \ge B$, if there is a word $\mu$ of length~$\ell$ in $\lang{\SCCpath}$,
    then there exists a word $\mu'$ of length  $\ell - p$  and a word $\mu''$ of length  $\ell + p$ in $\lang{\SCCpath}$.
\end{lemma}
\begin{proof}
    Recall the definition of $\lang{\SCCpath}$ (\cref{def:lang-of-sccpath}):
    \[\lang{\SCCpath} = L_0 a_1 L_1 a_2 \cdots L_k, \text{ where } L_i = \lang{P_i} \text { for } i =0,\ldots,k.\]
    It follows that a word $\mu\in \lang{\SCCpath}$ can be written as $\mu= \mu_1a_1\mu_2\ldots \mu_k$ with $\mu_i\in L_i$.
    Each $L_i$ is recognized by a strongly connected automaton $\Aa_i$ with at most $p|\Aa|$ states.
    Let $B = 5(p|\Aa|)^2$.
    If the length $\ell$ of $\mu$ exceeds $B$, then the run of $\mu$ in each of the $\Aa_i$'s contains simple loops with sum of lengths greater than $p+ 3(p|\Aa|)^2$. Let $\ell_0+p$ denote the sum of the length of these simple cycles: by construction $\ell_0$ is greater than $3(p|\Aa|)^2$.
    We remove these simple cycles from the run: the resulting run is still in $\lang{\SCCpath}$. Next, select any non-trivial SCC $S_i$ in $\SCCpath$ and let $s$ be a state of $S_i$ used by the run.
    As $\ell_0 \ge 3(p|\Aa|)^2$, by \cref{fact:periodicity}, there is a path of length $\ell_0$ from $s$ to itself in $\Aa_i$. Adding this path to the run yields an accepting run of length $\ell - (\ell_0 + p) +\ell_0 = \ell-p$: the word labeling this run is the desired word $\mu'$.
    
    To obtain $\mu''$, consider any simple cycle in the run of $\mu$ in $\Aa$, and let $m$ denote the length of this cycle.
    By definition of $p$, $m$ divides $p$. Iterating this cycle $p/m$ times yields a word $\mu''$ of length $\ell+p$ that is in $\lang{\SCCpath}$.
\end{proof}
\begin{corollary}\label{lem:fin-dist-iff-modulo}
    Let $\SCCpath$ be an SCC path.
    For large enough $\ell$, whether there is an word of length $\ell$ in $\lang{\SCCpath}$ only depends on the value of $\ell \pmod{p}$.
\end{corollary}

To finish our characterization of trivial languages, we show that if $\MBS(\Aa)$ is not empty, then $L = \lang{\Aa}$ is non-trivial in the sense of Alon et al.~\cite{alon2001regular}.
\begin{lemma}
	\label{lem:charac-trivial}
	Let $\Aa$ be a trim NFA such that $L = \lang{\Aa}$ is infinite.
	If $\Aa$ admits a blocking sequence,
	then there exists $\eps_0 > 0$, such that for infinitely many $n$ there exist words in $\lang{\Aa} \cap \Sigma^n$ and there exists $w \in \Sigma^n$ such that $d(w,\lang{\Aa})\geq \eps_0 n$
\end{lemma}
\begin{proof} 
	Let $\sigma = (\mu_1, \ldots, \mu_k)$ be a blocking sequence for $\Aa$.
	We can assume w.l.o.g. that $\sigma$ is strongly blocking for every accepting $\SCCpath$ of $\Aa$, as we can make it strongly blocking by concatenating $\sigma$ to itself $K$ times, where $K$ is the maximum length of an accepting SCC-path in $\Aa$.
	Let $C$ be the maximum length of a $\mu_i$'s.
	As~$L$ is infinite, there exists an accepting SCC-path~$\SCCpath$ in~$\Aa$ and $w \in \lang{\SCCpath}$ with $|w| \geq t$ for arbitrary $t$.
	By \cref{lem:fin-dist-iff-modulo}, for all sufficiently large $\ell$ such that $\ell = |w| \pmod{p}$, there exists $w' \in \lang{\SCCpath}$ with $|w'| = \ell$.
	
	For all $i = 1,\ldots, k$, let $\nu_i$ be a shortest word of the form $\timedword{0}{v_i}$, for some $v_i$, and of length $\ell_i$ equal to $0$ modulo $p$, such that $\mu_i$ is a factor of $\nu_i$. By minimality, $\ell_i$ is at most $C+2p$.
	Then, for any integer $N \in \NN$, let $w_N = \nu_1^N \cdots \nu_k^N \timedword{0}{a^{|w|}}$, where $a$ is an arbitrary letter.
	
	As $w_N$ is of length $|w| \pmod{p}$, there is a word of the same length in $\lang{\Aa}$, i.e. $\lang{\Aa} \cap \Sigma^n$ is nonempty.
	On the other hand, it contains $N$ disjoint occurrences of $\sigma$, which is a strongly blocking sequence for every accepting SCC-path of~$\Aa$, therefore, the distance between $w_N$ and $\lang{\Aa}$ is at least $N$.
	Furthermore, the length of $w_N$ is less than $|w| + N(C+2p)$. 
	Therefore, if we let $\eps_0 = \frac{1}{C+2p+|w|}$, then we have $\eps_0 |w_N| \leq N \leq d(w_N, \lang{\Aa})$, i.e. $w_N$ is $\eps$-far from~$L$ for any $\eps \le \eps_0$ and any $N$.
\end{proof}

It is easy to see that if a language is trivial in the above sense, then for large enough input length $n$, membership in~$L$ only depends $n$, and the algorithm does not need to query the input.
Alon et al.~\cite{alon2001regular} show that if a language is non-trivial, then testing it requires $\Omega(1/\eps)$ queries for small enough $\eps > 0$.
As a corollary of that lower bound, we obtain that if $\MBS(\Aa)$ is non-empty, then testing $\lang{\Aa}$ requires $\Omega(1/\eps)$ queries.
 

\section{Hardness of classifying}
\label{sec:complexity}
In the previous sections, we have shown that testing some regular languages (\emph{easy} ones) that requires fewer queries than testing others (\emph{hard} ones).
Therefore, given the task of testing a word for membership in $\lang{\Aa}$,
it is natural to first try to determine if the language of $\Aa$ is easy, and if this is the case, run the appropriate $\eps$-tester, that uses fewer queries.
In this section, we investigate the computational complexity of checking which class of the trichotomy the language of a given automaton belongs to.
We formalize this question as the following decision problems:

\begin{problem}[Triviality problem]
	Given an finite automaton $\Aa$, is $\lang{\Aa}$ trivial?
\end{problem}
\begin{problem}[Easiness problem]
	Given an finite automaton $\Aa$, is $\lang{\Aa}$ easy?
\end{problem}
\begin{problem}[Hardness problem]
	Given an finite automaton $\Aa$, is $\lang{\Aa}$ hard?
\end{problem}

In these problems, the automaton $\Aa$ is the input and is no longer fixed.
We show that, our combinatorial characterization based on minimal blocking sequences is effective, in the sense that all three problems are decidable. However, it does not lead to efficient algorithms, as both problems are \PSPACE-complete.

\begin{theorem}\label{thm:PSPACE-main}
	The triviality and easiness problems are both \PSPACE-complete, even for strongly connected NFAs.
\end{theorem}

In \cref{sec:ppace-ub} we show the \PSPACE upper bounds on the hardness and triviality problems (Propositions~\ref{prop:hard-to-test-PSPACE} and~\ref{prop:trivial-PSPACE}). The upper bound on the easiness problem follows immediately, as the three properties form a trichotomy.

In \cref{sec:pspace-hard}, we show that all three problems are \PSPACE-hard (\cref{lemma:trivial-complexity} and \cref{cor:hardness-easy}).

\subsection{A $\PSPACE$ upper-bound}\label{sec:ppace-ub}

\subsubsection{Testing hardness}

A naive algorithm to check hardness of a language $\lang{\Aa}$ would be to construct an automaton recognising blocking sequences of $\lang{\Aa}$ (exponential in $\Aa$), and use it to get an automaton recognising the minimal ones (which requires complementation and could yield another exponential blow-up). This would a priori not give a \PSPACE algorithm, since we obtain a doubly-exponential state space.
We solve this by providing another characterisation of automata with hard languages, resulting in a recursive \PSPACE algorithm to test it.


\begin{lemma}
	\label{lem:uniformisation-blocking-seq}
	Let $\SCCpath = P_0 \xrightarrow{a_1} \cdots  P_\ell$ be an SCC-path, $i$ an index, $\Pi$ a set of SCC-paths and $(\sigma_{\SCCpath'})_{\SCCpath' \in \Pi}$ a family of sequences of positional words such that $\lefteffect{\sigma_{\SCCpath'}}{\SCCpath} < i$ for all $\SCCpath'$.
	
	There exists a sequence of positional words $\sigma$ such that:
	\begin{itemize}
		\item $\lefteffect{\sigma}{\pi} < i$
		\item $\lefteffect{\sigma_{\SCCpath'}}{\SCCpath'} \leq \lefteffect{\sigma}{\SCCpath'}$ for all $\SCCpath' \in \Pi$.
	\end{itemize}
\end{lemma}

\begin{proof}
	We prove this by induction on the sum of the lengths of the elements of~$\Pi$.
	If~$\Pi$ is empty or contains only empty sequences, then we can set~$\sigma$ as the empty sequence.
	
	If not, let $\SCCpath^*$ be such that the first term $\nu_1$ of $\sigma_{\SCCpath^*} = (\nu_1, \ldots, \nu_k)$ has the least left effect on $\SCCpath$ among all SCC-paths in $\Pi$; let $\SCCpath^* = P_0' \xrightarrow{a_1'} \cdots  P_{\ell'}'$. We consider the effect of $\nu_1$ (as a single-element sequence) on $\SCCpath^*$ and $\SCCpath$: let~$j = \lefteffect{\nu_1}{\SCCpath^*}$ and~$r = \lefteffect{\nu_1}{\SCCpath}$.

	Next, we build a set $\Pi'$ of SCC-paths as follows.
	Let $\overline{\SCCpath}$ denote the part of $\SCCpath^*$ that survives $\nu_1$, if any, i.e. $\overline{\SCCpath} = P_{j+1}' \xrightarrow{a_{j+1}'} \cdots P_{\ell'}'$.
	We define $\Pi' = \Pi \setminus \set{\SCCpath^*} \cup \set{\overline{\SCCpath}}$ if $j<\ell'$ and $\Pi' = \Pi \setminus \set{\SCCpath^*}$ otherwise.
	In the first case the sequence associated with $\overline{\SCCpath}$ is $\sigma_{\overline{\SCCpath}} = (\nu_2, \ldots, \nu_k)$.
	
	We now wish to apply the induction hypothesis to the set $\Pi'$ and the part of $\SCCpath$ that survives $\nu_1$, i.e. on $\tilde{\SCCpath} = P_{r+1}\xrightarrow{a_{r+1}} \ldots \rightarrow P_\ell$, with a target left effect of $i-r-1$.
	By construction, the sum of the lengths of the elements in~$\Pi'$ is smaller than that of~$\Pi$.
	The following claim shows that, for any~$\SCCpath'$ in~$\Pi'$, the left effect of~$\sigma_{\SCCpath'}$ on~$\tilde{\SCCpath}$ is at most~$i-r-1$.

	\begin{claim}
		For all $\SCCpath' \in \Pi'$, we have $\lefteffect{\sigma_{\SCCpath'}}{\tilde{\SCCpath}} < i-r-1$.
	\end{claim}
	
	\begin{claimproof}
		Let $\pi' \in \Pi\setminus \set{\SCCpath^*}$, and let $\sigma_{\SCCpath'} = (\nu_1', \ldots, \nu_m')$.
		Since the first term of $\sigma_{\SCCpath^*}$ was the one with the least left effect on $\SCCpath$, the first term of every other sequence has a left effect at least $r$ on it.
		Formally, let $z = \lefteffect{\nu_1'}{\SCCpath}$: we have $z \ge r$.
		
		In other words, $\nu_1'$ is blocking for all portals in $\tilde{\SCCpath}$ up to $P_z$.
		Therefore, the sequence $(\nu_2', \ldots, \nu_m')$ will be applied to the same portals in~$\SCCpath$ and in~$\tilde{\SCCpath}$. Since portal $P_i$ survives in~$\SCCpath$, it must also survive in~$\tilde{\SCCpath}$, and we have $\lefteffect{\sigma_{\SCCpath'}}{\tilde{\SCCpath}} < i-r-1$.
	\end{claimproof}
		
	By induction hypothesis, we obtain a sequence $\tilde{\sigma}$ such that 
	\begin{itemize}
		\item $\lefteffect{\tilde{\sigma}}{\tilde{\SCCpath}} < i-r-1$
		\item $\lefteffect{\sigma_{\SCCpath'}}{\SCCpath'} \leq \lefteffect{\tilde{\sigma}}{\SCCpath'}$ for all $\SCCpath' \in \Pi'$.
	\end{itemize}
	Then, the sequence obtained by prepending $\nu_1$ to $\tilde{\sigma}$ satisfies both conditions of the lemma, as $\tilde{\SCCpath}$ is the part of $\SCCpath$ that survives $\nu_1$, and prepending $\nu_1$ cannot decrease the left effect of a sequence.
\end{proof}

\begin{lemma}\label{lem:charac-hard-PSPACE}
	An automaton $\Aa$ is hard if and only if there exists an accepting SCC-path $\SCCpath$ containing a portal $P$ such that:
	\begin{itemize}
		\item $P$ has infinitely many minimal blocking factors.
		\item For any accepting SCC-path $\SCCpath'$ there exist sequences $\sigma_{l, \SCCpath'}, \sigma_{r, \SCCpath'}$ such that: 
		\begin{itemize}
			\item $P$ survives $(\sigma_{l, \SCCpath'}, \sigma_{r, \SCCpath'})$ in $\SCCpath$
			\item All portals surviving $(\sigma_{l, \SCCpath'}, \sigma_{r, \SCCpath'})$ in $\SCCpath'$ are $\equivportals$-equivalent to $P$
		\end{itemize} 
	\end{itemize} 
\end{lemma}
\begin{proof}
	The left-to-right direction follows from \cref{coro:fin-bs-then-easy}, by taking $\sigma_{l, \SCCpath'} = \sigma_l$ and $\sigma_{r, \SCCpath'} = \sigma_r$ for every $\SCCpath'$.

	Let us now prove the other direction.
	Suppose we have $\SCCpath$ and $P$ satisfying the conditions of the lemma.
	We only need to construct two sequences $\sigma_l, \sigma_r$ such that properties P1 and P3 are satisfied.
	The result follows by \cref{lem:P1-P3-then-hard}.
	
	Let $\Pi$ be the set of accepting SCC-paths in $\Aa$. 
	Consider families of sequences $(\sigma_{l, \SCCpath'})_{\SCCpath' \in \Pi}$ and $(\sigma_{r, \SCCpath'})_{\SCCpath' \in \Pi}$ such that for all $\SCCpath' \in \Pi$:
	\begin{itemize}
		\item $P$ survives $(\sigma_{l, \SCCpath'}, \sigma_{r, \SCCpath'})$ in $\SCCpath$
		\item All portals surviving $(\sigma_{l, \SCCpath'}, \sigma_{r, \SCCpath'})$ in $\SCCpath'$ are $\equivportals$-equivalent to $P$
	\end{itemize} 
	
	Let $i$ be the index of $P$ in $\SCCpath$.	
	By \cref{lem:uniformisation-blocking-seq} we can build a sequence $\sigma_l$ such that 
	\begin{itemize}
		\item $\lefteffect{\sigma_l}{\SCCpath} < i$, and
		\item $\lefteffect{\sigma_{l, \SCCpath'}}{\SCCpath'} \leq \lefteffect{\sigma_l}{\SCCpath'}$ for all $\SCCpath' \in \Pi$.
	\end{itemize}
	
	Using a symmetric argument, we build a sequence $\sigma_r$ such that 
	\begin{itemize}
		\item $i< \righteffect{\sigma_r}{\SCCpath}$, and
		\item $\righteffect{\sigma_{r, \SCCpath'}}{\SCCpath'} \geq \righteffect{\sigma_r}{\SCCpath'}$ for all $\SCCpath' \in \Pi$.
	\end{itemize}
	
	As a consequence, for all accepting SCC-path $\SCCpath' \in \Pi$, all portals surviving $(\sigma_l, \sigma_r)$ in $\SCCpath'$ are $\equivportals$-equivalent to $P$.
	Furthermore, $P$ survives $(\sigma_l, \sigma_r)$ in $\SCCpath$.
	
	We have shown that $P$ and $(\sigma_l, \sigma_r)$ satisfy properties P1 and P3. 
	P2 is immediate by assumption. 
	We simply apply \cref{lem:P1-P3-then-hard} to obtain the result.
\end{proof}

Next, we establish that the items listed in the previous lemma can all be checked in polynomial space in $|\Aa|$.

\begin{lemma}
	\label{lem:aut-block-fact}
	Given a portal $P$, we can check whether it has infinitely many minimal blocking factors in space polynomial in $|\Aa|$.
\end{lemma}

\begin{proof}
	Recall that, by \cref{lemma:portal-to-SC}, $L = \lang{P}$ is recognized by a strongly connected automaton $\Aa'$ with at most $p|\Aa|$ states. While this number may be exponential in $|\Aa|$, the transition function of $\Aa'$ can be computed in polynomial space from the polynomial-sized representation of a state.
	Furthermore, in this case, we can show that the same property holds for the construction used in \cref{lemma:blocking-regular}, as in the determinization step, all states share the index modulo $p$.
	
	We then simply need to check if the resulting automaton has an infinite language, which is the case if and only if it has a cycle reachable from the initial state and from which a final state is reachable.
	This can be checked by exploring the state space of the automaton, in non-deterministic polynomial space (in $|\Aa|$), and applying Savitch's theorem~\cite[Theorem 1]{SAVITCH1970177}.  
\end{proof}

\begin{lemma}
	\label{lem:PSPACE-blocking-for-one}
	Given two SCC-paths $\SCCpath$ and $\SCCpath'$, one can check in \PSPACE whether there is a sequence $\sigma$ that is blocking for $\SCCpath$ and not $\SCCpath'$.
\end{lemma}
\begin{proof}
	The algorithm relies on the following property.
	\begin{claim}
		There is a sequence $\sigma$ that is blocking for $\SCCpath = P_0 \xrightarrow{a_1} \cdots  P_k$ and not $\SCCpath' = P_0' \xrightarrow{a'_1} \cdots  P_\ell'$ if and only if either:
		\begin{itemize}
			\item there is a positional word $\mu$ that is a blocking factor for $P_0$ and not $P_0'$ and there is a sequence $\sigma'$ that is blocking for $P_1 \xrightarrow{a_2} \cdots  P_k$ and not $\SCCpath'$,
			
			\item or there is a positional word $\mu$ that is a blocking factor for $P_0$ and $P_0'$ and there is a sequence $\sigma'$ that is blocking for $P_1 \xrightarrow{a_2} \cdots  P_k$ and not $P_1' \xrightarrow{a'_2} \cdots  P_\ell'$.
		\end{itemize}
	\end{claim}
	\begin{claimproof}
		The right-to-left direction is clear (just take $\sigma =  \mu \sigma'$ in both cases).
		
		For the left-to-right direction, consider a sequence $\sigma$ that is blocking for $\SCCpath$ and not $\SCCpath'$, of minimal length.
		Let $\sigma_+$ and $\mu$ be such that $\sigma = \mu \sigma_+$.
		\begin{itemize}
			\item If $\mu$ is not blocking for $P_0$ then $\sigma_+$ is blocking for $\SCCpath$ and not $\SCCpath'$, contradicting the minimality of $\sigma$.
			
			\item If $\mu$ is blocking for $P_0$ and not $P_0'$ then we set $\sigma' = \sigma$. We know that $\sigma$ is not blocking for $\SCCpath'$. On the other hand, as $\sigma$ is blocking for $\SCCpath$, it is also blocking for $P_1 \xrightarrow{a_2} \cdots  P_k$.
			
			\item If $\mu$ is blocking for both $P_0$ and  $P_0'$ then we set $\sigma' = \sigma$. 
			As $\sigma$ is blocking for $\SCCpath$, it is also blocking for $P_1 \xrightarrow{a_2} \cdots  P_k$. 
			On the other hand, if $\sigma$ was blocking for $P_1' \xrightarrow{a'_2} \cdots  P_\ell'$, then it would also be blocking for $\SCCpath'$, a contradiction. Hence $\sigma$ is not blocking for $P_1' \xrightarrow{a'_2} \cdots  P_\ell'$
		\end{itemize}
	\end{claimproof}
	
	The claim above lets us define a recursive algorithm.
	
	\begin{itemize}
		\item First check if there is a positional word $\mu$ that is blocking for $P_0$ and not $P_0'$.
		If it is the case, make a recursive call to check if there is a sequence $\sigma'$ that is blocking for $P_1 \xrightarrow{a_2} \cdots  P_k$ and not $\SCCpath'$.
		If it is the case, answer yes.
		
		\item Then check if there is a positional word $\mu$ that is a blocking factor for $P_0$ and $P_0'$. If so, make a recursive call to check if there is a sequence $\sigma'$ that is blocking for $P_1 \xrightarrow{a_2} \cdots  P_k$ and not $P_1' \xrightarrow{a'_2} \cdots  P_\ell'$.
		If it is the case, answer yes.
	\end{itemize}
	
	If both items fail, answer no.
	
	The existence of those positional words can be checked in polynomial space using the automaton $\Bb$ constructed in the proof of \cref{lem:aut-block-fact}.
	The depth of the recursive calls is at most the sum of the lengths of $\SCCpath$ and $\SCCpath'$, which is bounded by $2|\Aa|$.
	In consequence, this algorithm runs in polynomial space.
	
\end{proof}

\begin{proposition}
	\label{prop:hard-to-test-PSPACE}
	The hardness problem is in \PSPACE.
\end{proposition}
\begin{proof}
	Our algorithm is based on \cref{lem:charac-hard-PSPACE}.
	We use the following algorithm to check whether the characterization holds.
	\begin{enumerate}
		\item First, we nondeterministically guess an SCC-path $\SCCpath = P_0 \xrightarrow{a_1} \cdots  P_k$ and an index $i$.
		\item Using \cref{lem:aut-block-fact}, we check that $P_i$ has infinitely many minimal blocking factors.
	
		\item For each accepting SCC-path $\SCCpath' = P_0' \xrightarrow{a'_1} \cdots  P_\ell'$  of $\Aa$, we guess indices $j_l$ and $j_r$, and check that every portal $P_j'$ with $j_l < j < j_r$ is $\equivportals$-equivalent to $P_i$.

		\item Then, we use \cref{lem:PSPACE-blocking-for-one} to check that there is a sequence $\sigma_l$ that is blocking for $P_0' \xrightarrow{a'_1} \cdots  P_{j_l}'$ and not $P_0 \xrightarrow{a_1} \cdots P_i$.
		Symmetrically, we check that there is a sequence $\sigma_r$ that is blocking for $P_{j_r}' \xrightarrow{a'_1} \cdots  P_\ell'$ and not $P_i \xrightarrow{a_{i+1}} \cdots  P_k$.
	\end{enumerate}
	
	If all those tests succeed, we answer ``yes'', otherwise we answer ``no''.
	This algorithm is correct and complete by \cref{lem:charac-hard-PSPACE}.
\end{proof}


\subsubsection{Testing triviality}

We show the \PSPACE upper bound on the complexity of checking if a language is trivial.
It is based on the characterisation of trivial languages given by \cref{lem:charac-trivial}, and uses the following result.

\begin{lemma}
	\label{lem:exists-blocking-fact}
	Given a portal $P$, we can check whether it has a blocking factor in space polynomial in $|\Aa|$.
\end{lemma}
\begin{proof}
	We proceed as in the proof of \cref{lem:aut-block-fact}, except that we only need to check whether some final state is reachable from the final state.
\end{proof}


\begin{proposition}\label{prop:trivial-PSPACE}
	The triviality problem is in \PSPACE.
\end{proposition}
\begin{proof}
	Recall that $\lang{\Aa}$ is trivial if and only if $\Aa$ has no blocking sequences.
	\begin{claim}
		There is an accepting SCC-path $\SCCpath$ of $\Aa$ that contains a portal $P$ with no blocking factors if and only if $\Aa$ has no blocking sequence.
	\end{claim}
	\begin{claimproof}
		Any blocking sequence of $\Aa$ is blocking for $\SCCpath$, therefore it contains a blocking factor for $P$.
	\end{claimproof}
	Therefore, it suffices to enumerate all accepting SCC-paths $\SCCpath$ in the automaton, and then check that all portals in $\SCCpath$ have at least one blocking factor, using \cref{lem:exists-blocking-fact}.
\end{proof}


\subsection{Hardness of classifying automata}\label{sec:pspace-hard}

We prove hardness of the triviality problem and easiness problems, concluding on their \PSPACE-completeness.
We reduce from the universality problem for NFAs, which is well-known to be \PSPACE-complete (see e.g.~\cite[Theorem 10.14]{aho1974design}).

\begin{lemma}\label{lemma:trivial-complexity}
	The triviality and hardness problems are \PSPACE-hard.
\end{lemma}
\begin{proof}
	Consider an NFA $\Aa = (Q, \Sigma, \delta, q_0, F)$ on an alphabet $\Sigma$.
	Without loss of generality, we assume that $\Aa$ is trim (up to removing unreachable or non-co-reachable states) and that it accepts all words of length less than 2: this can be checked in polynomial time and does not affect the \PSPACE-hardness of universality.
	Let $\#$ and $!$ be two letters that are not in $\Sigma$.
	We apply the following transformations to $\Aa$:
	\begin{itemize}
		\item add a transition labeled by $!$ from every final state to the initial state~$q_0$
		\item add a self-loop labeled by $\#$ to each state.
	\end{itemize}
	
	We call the resulting automaton $\Bb = (Q, \Sigma\cup\set{!,\#}, \delta', q_0, F)$.
	Note that $\Bb$ is strongly connected:
	consider any two states $q, q' \in Q$, we show that~$q'$ is reachable from~$q$. As $\Aa$ is trim, there exists $q_f \in F$ that is reachable from~$q$, and~$q'$ is reachable from the initial state~$q_0$.
	Furthermore, we have put a $!$ transition from~$q_f$ to~$q_0$, hence~$q'$ is reachable from~$q$.
	
	Recall that the language of a strongly connected automaton is trivial if and only if it has no minimal blocking factor, and hard if and only if it has infinitely many minimal blocking factors.
	
	Hence, to complete the proof, we show that $\MBF(\Bb)$ is empty when $\Aa$ is universal and infinite otherwise. 
	
	First, let us describe the language recognized by $\Bb$. It is given by
	\[\lang{\Bb} = \set{u_1!u_2!\cdots !u_n \mid \forall i, u_i \in (\Sigma\cup\set{\#})^* ~\land~ \pi_{\Sigma}(u_i) \in \lang{\Aa}},\]
	where $\pi_{\Sigma}(u)$ is the word in $\Sigma^*$ obtained by removing all letters not in $\Sigma$ from $u$.
	
	\begin{claim}
		If $\Aa$ is universal, then $\Bb$ is also universal. 
	\end{claim}
	\begin{claimproof}
		Indeed, any word in $u$ in $ $ can be uniquely decomposed into $u = u_1!u_2!\cdots !u_n$ where each $u_i$ does not contain the letter ``$!$''.
		As $\#$ is idempotent on $\Bb$, $\delta'(q_0,u_i)$ is equal to $\delta(q_0, \pi_{\Sigma}(u_i))$ for every $i$.
		Since $\Aa$ is universal, each of the $\delta'(q_0, u_i)$ contains a final state, hence $\delta'(q_0, u_i!) = \set{q_0}$.
		Therefore, the set $\delta'(q_0, u)$ is equal to $\delta'(q_0, u_n)$, which contains a final state, and  $u$ is in $\lang{\Bb}$, which shows that $\Bb$ is universal.
	\end{claimproof}
	This shows that if $\Aa$ is universal, then $\MBF(\Bb)$ is empty.
	
	Now we show that a word $w \in \Sigma^*$ not in $\lang{\Aa}$ induces infinitely many minimal blocking factors for $\Bb$.
	Consider such a $w$ of minimal size. As we assumed that $\Aa$ accepts all words of size less than 2, $|w| \geq 2$. 
	Let $u, v$ be words of length at least 1 such that $w=uv$.
	For all $n \in \NN$, at least one of $u\#^nv, !u\#^nv, u\#^nv!, !u\#^nv!$ is a minimal blocking factor (depending respectively on whether $w$ is not a factor of any word of $\lang{\Aa}$ or is a prefix/suffix of a word of $\lang{\Aa}$ or not).
	As a consequence, $\Bb$ has infinitely many blocking factors, and is thus hard to test by \cref{thm:scc}.
	
	In summary, $\Aa$ is universal if and only if $\Bb$ is trivial to test, and  $\Aa$ is \emph{not} universal if and only if $\Bb$ is hard to test.
	This shows the \PSPACE-hardness of the triviality problem.
\end{proof}

The above proof can be extended to show the \PSPACE-hardness of the easiness problem.
\begin{corollary}\label{cor:hardness-easy}
	The easiness problem is \PSPACE-hard.
\end{corollary}
\begin{proof}
	We proceed as in the proof of \cref{lemma:trivial-complexity}: given an automaton $\Aa$ over an alphabet $\Sigma$,
	we build an automaton $\Bb$ over the alphabet $\Sigma\cup\set{!,\#}$ such that if $\Aa$ is universal,
	$\MBF(\Bb)$ is empty, and if $\Aa$ is not universal, then $\MBF(\Bb)$ is infinite.
	
	To show the hardness of the easiness problem, let $\flat$ denote a new letter not in $\Sigma \cup \set{\#, !}$ and consider the automaton $\Bb'$ equal to $\Bb$ but taken over the alphabet $\Sigma \cup \set{\#, !, \flat}$.
	As there are no transitions labeled by $\flat$ in $\Bb'$, the word $\flat$ is always a minimum blocking factor of $\Bb'$. As a result, we have $\MBF(\Bb') = \MBF(\Bb) \cup\set{\flat}$, hence $\Aa$ is universal if and only if $\MBF(\Bb')$ is finite but non-empty: by \cref{thm:scc}, this is equivalent to $\lang{\Bb'}$ is easy to test.
	Therefore, the easiness problem is also \PSPACE-hard.
\end{proof}

This concludes the proof of \cref{thm:PSPACE-main} 



\section{Conclusion}
We presented an effective classification of regular languages in three classes, each associated with an optimal query complexity for property testing.
We thus close a line of research aiming to determine the optimal complexity of regular languages.
All our results are with respect to the Hamming distance. We conjecture that they can be adapted to the edit distance.
We use non-deterministic automata to represent regular languages. 
A natural open question is the complexity of classifying languages represented by \emph{deterministic} automata.

\bibliography{biblio}


\newpage















\end{document}