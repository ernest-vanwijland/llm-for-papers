
\documentclass[a4paper,UKenglish,cleveref, autoref, numberwithinsect, thm-restate]{lipics-v2021}


\pdfoutput=1 \hideLIPIcs  



\nolinenumbers
\usepackage{xcolor}

\bibliographystyle{plainurl}

\title{Subgraph Counting in Subquadratic Time for Bounded Degeneracy Graphs} 



\author{Daniel Paul-Pena}{University of California, Santa Cruz, United States }{dpaulpen@ucsc.edu}{https://orcid.org/0009-0008-1073-6173}{}

\author{C. Seshadhri}{University of California, Santa Cruz, United States}{sesh@ucsc.edu}{https://orcid.org/0000-0003-2163-3555}{}

\authorrunning{D. Paul-Pena and C. Seshadhri} 

\Copyright{Daniel Paul-Pena and C. Seshadhri} 

\ccsdesc[500]{Mathematics of computing~Graph algorithms} 


\keywords{Homomorphism counting, Bounded degeneracy graphs, Fine-grained complexity, Subgraph counting.} 

\category{} 

\relatedversion{} 



\funding{Both authors are supported by NSF CCF-1740850, CCF-1839317, CCF-2402572, and DMS-2023495.
}






\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}



\newcommand{\mcomment}[1]{\textbf {\em \color{red} \footnotesize[#1]}\marginpar{\tiny\textsc{\color{red} PLEASE CHECK}}}

\newcommand{\Daniel}[1]{{\color{blue} DPP: #1}}


\newcommand{\maybefootnote}[2]{\ifcsname firsttime#1\endcsname
\else
	\expandafter\gdef\csname firsttime#1\endcsname{}\footnote{#2}\fi
}



\mathchardef\mhyphen="2D
\newcommand{\reducible}[1]{${#1}$-reducible}
\newcommand{\computable}[1]{${#1}$-computable}
\newcommand{\reduced}[1]{G_{#1}}

\newcommand{\cycle}[1]{\cC_{#1}}
\newcommand{\dcycle}[1]{\vec{\cC}_{#1}}
\newcommand{\simplex}[1]{\cS_{#1}}
\newcommand{\hyperone}{\cH_1}
\newcommand{\hypertwo}{\cH_2}
\newcommand{\hyperthree}{\cH_\triangle}
\newcommand{\diamondgraph}{\cD}

\newcommand{\colSetSub}{\text{Col-}\cS}


\newcommand{\dircycle}[1]{$\vec{\cC}_{#1}$}
\newcommand{\maxoutdeg}{d}

\newcommand{\expandG}{G'}
\newcommand{\expandGOdd}{G''}

\newcommand{\complexity}[1]{c({#1})}


\newcommand{\complexityUndirected}[1]{c'({#1})}

\newcommand{\extension}[3]{ext\left(#1,#2;#3\right)}

\newcommand{\WSub}[2]{\mathrm{\text{Col-WSub}}_{#2}(#1)}
\newcommand{\WSubNI}[1]{\mathrm{\text{Col-WSub}}_{#1}}
\newcommand{\Hom}[2]{\mathrm{Hom}_{#2}(#1)}
\newcommand{\Sub}[2]{\mathrm{Sub}_{#2}(#1)}
\newcommand{\IndSub}[2]{\mathrm{IndSub}_{#2}(#1)}
\newcommand{\Aut}[1]{\mathrm{Aut}_{#1}}
\newcommand{\licl}{LICL}
\newcommand{\LICL}{LICL}
\newcommand{\LIPL}{LIPL}
\newcommand{\UR}{UR}
\newcommand{\Reachable}{Reach}
\newcommand{\Unique}{U}
\newcommand{\Origin}{ORIGIN}
\newcommand{\Area}{A}
\newcommand{\Shared}{C}
\newcommand{\ReducedV}{\cV_{{\HubSet}'}}
\newcommand{\Prec}{PREC}
\newcommand{\Frat}[2]{\Sigma(#1,#2)}
\newcommand{\MinFrat}[2]{{\vec{#1}}^{(#2)}}
\newcommand{\ExpG}{F}
\newcommand{\LabeledH}{H^{L}}
\newcommand{\Spasm}{Spasm}
\newcommand{\down}{down}
\newcommand{\ext}{ext}
\newcommand{\Gt}{G_t}
\newcommand{\Gtt}{G_{t'}}
\newcommand{\degenOrientation}{\vec{G}^\degen}
\newcommand{\optimalOrientation}{\vec{G}^*}
\newcommand{\HubSet}{\cS}
\newcommand{\Agg}{AGG}






\newcommand{\Extension}{Extension}
\newcommand{\Homomorphisms}{Homomorphisms}
\newcommand{\ComputeMinFrat}{CompOptimalExtension}
\newcommand{\ComputeFrat}{ComputeExtensions}

\newcommand{\SparsityAuthors}{Ne\v{s}et\v{r}il and Ossona de Mendez}

\newcommand{\degen}{\kappa}
\newcommand{\grad}{\nabla}
\newcommand{\topgrad}{\tilde{\nabla}}
\newcommand{\tw}{t}
\newcommand{\dtw}{\tau}
\newcommand{\htw}{\tau}
\newcommand{\dagtree}{DAG-tree decomposition}
\newcommand{\dagtreewidth}{DAG-treewidth}
\newcommand{\hubtree}{hub-tree decomposition}
\newcommand{\hubtreewidth}{hub-treewidth}
\newcommand{\TRICONJ}{Triangle Detection Conjecture}
\newcommand{\minor}[2]{#1\; \triangledown\; #2}
\newcommand{\topminor}[2]{#1\; \tilde{\triangledown}\; #2}

\newcommand{\ignore}[1]{}

\DeclareMathOperator*{\argmax}{argmax} \DeclareMathOperator*{\argmin}{argmin} \DeclareMathOperator*{\supp}{support}



\newcommand{\cA}{{\cal A}}
\newcommand{\cB}{\mathcal{B}}
\newcommand{\cC}{{\cal C}}
\newcommand{\cD}{\mathcal{D}}
\newcommand{\cE}{{\cal E}}
\newcommand{\cF}{\mathcal{F}}
\newcommand{\cG}{\mathcal{G}}
\newcommand{\cH}{{\cal H}}
\newcommand{\cI}{{\cal I}}
\newcommand{\cJ}{{\cal J}}
\newcommand{\cL}{{\cal L}}
\newcommand{\cM}{{\cal M}}
\newcommand{\cO}{\mathcal{O}}
\newcommand{\cP}{\mathcal{P}}
\newcommand{\cQ}{\mathcal{Q}}
\newcommand{\cR}{{\cal R}}
\newcommand{\cS}{\mathcal{S}}
\newcommand{\cT}{{\cal T}}
\newcommand{\cU}{{\cal U}}
\newcommand{\cV}{{\cal V}}
\newcommand{\cW}{{\cal W}}
\newcommand{\cX}{{\cal X}}

\newcommand{\R}{\mathbb R}
\newcommand{\F}{\mathbb F}
\newcommand{\Z}{{\mathbb Z}}
\newcommand{\eps}{\varepsilon}
\newcommand{\lam}{\lambda}
\newcommand{\sgn}{\mathrm{sgn}}
\newcommand{\poly}{\mathrm{poly}}
\newcommand{\polylog}{\mathrm{polylog}}
\newcommand{\littlesum}{\mathop{{\textstyle \sum}}}
\newcommand{\half}{1/2}
\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\wh}{\widehat}
\newcommand{\wt}{\widetilde}
\newcommand{\calE}{{\cal E}}
\newcommand{\calL}{{\cal L}}
\newcommand{\calF}{{\cal F}}
\newcommand{\calW}{{\cal W}}
\newcommand{\calH}{{\cal H}}
\newcommand{\calN}{{\cal N}}
\newcommand{\calO}{{\cal O}}
\newcommand{\calP}{{\cal P}}
\newcommand{\calV}{{\cal V}}
\newcommand{\calS}{{\cal S}}
\newcommand{\calT}{{\cal T}}
\newcommand{\calD}{{\cal D}}
\newcommand{\calC}{{\cal C}}
\newcommand{\calX}{{\cal X}}
\newcommand{\calY}{{\cal Y}}
\newcommand{\calZ}{{\cal Z}}
\newcommand{\calA}{{\cal A}}
\newcommand{\calB}{{\cal B}}
\newcommand{\calG}{{\cal G}}
\newcommand{\calI}{{\cal I}}
\newcommand{\calJ}{{\cal J}}
\newcommand{\calR}{{\cal R}}
\newcommand{\calK}{{\cal K}}
\newcommand{\calU}{{\cal U}}
\newcommand{\barx}{\overline{x}}
\newcommand{\bary}{\overline{y}}

\newcommand{\bone}{{\bf 1}}
\newcommand{\btwo}{{\bf 2}}
\newcommand{\bthree}{{\bf 3}}
\newcommand{\ba}{\boldsymbol{a}}
\newcommand{\bb}{\boldsymbol{b}}
\newcommand{\bp}{\boldsymbol{p}}
\newcommand{\bt}{\boldsymbol{t}}
\newcommand{\bu}{\boldsymbol{u}}
\newcommand{\bv}{\boldsymbol{v}}
\newcommand{\bw}{\boldsymbol{w}}
\newcommand{\bx}{\boldsymbol{x}}
\newcommand{\by}{\boldsymbol{y}}
\newcommand{\bz}{\boldsymbol{z}}
\newcommand{\br}{\boldsymbol{r}}
\newcommand{\bh}{\boldsymbol{h}}

\newcommand{\bA}{\boldsymbol{A}}
\newcommand{\bC}{\boldsymbol{C}}
\newcommand{\bD}{\boldsymbol{D}}
\newcommand{\bG}{\boldsymbol{G}}
\newcommand{\bH}{\boldsymbol{H}}
\newcommand{\bR}{\boldsymbol{R}}
\newcommand{\bS}{\boldsymbol{S}}
\newcommand{\bT}{\boldsymbol{T}}
\newcommand{\bP}{\boldsymbol{P}}
\newcommand{\bX}{\boldsymbol{X}}
\newcommand{\bY}{\boldsymbol{Y}}
\newcommand{\bZ}{\boldsymbol{Z}}
\newcommand{\dc}{d}
\newcommand{\ds}{d^{(s)}}
\newcommand{\Gs}{G^{(s)}}
\newcommand{\Gc}{G}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\vs}{v^{(s)}}
\newcommand{\vc}{v}
\newcommand{\abs}[1]{\left\lvert #1 \right\rvert}
\newcommand{\norm}[1]{\left\lVert #1 \right\rVert}
\newcommand{\ceil}[1]{\lceil#1\rceil}
\newcommand{\Exp}{\EX}
\newcommand{\floor}[1]{\lfloor#1\rfloor}
\newcommand{\cei}[1]{\lceil#1\rceil}

\newcommand{\EX}{\hbox{\bf E}}
\newcommand{\var}{\hbox{\bf var}}
\newcommand{\prob}{{\rm Prob}}

\newcommand{\gset}{Y}
\newcommand{\gcol}{{\cal Y}}

\newcommand{\eqdef}{:=}

\newcommand{\otilde}{\widetilde{O}}
\newcommand{\bigO}[1]{{O\left( #1 \right)}}

\newcommand{\wgt}{\mathrm{wt}}

\newcommand{\extract}{{\tt Extract}}
\newcommand{\decompose}{{\tt Decompose}}



\newcommand{\Sec}[1]{\S \ref{sec:#1}} \newcommand{\Eqn}[1]{\hyperref[eq:#1]{(\ref*{eq:#1})}} \newcommand{\Fig}[1]{{Fig.\,\ref{fig:#1}}} \newcommand{\Tab}[1]{\hyperref[tab:#1]{Tab.\,\ref*{tab:#1}}} \newcommand{\Table}[1]{\hyperref[tab:#1]{Table\,\ref*{tab:#1}}} \newcommand{\Thm}[1]{\hyperref[thm:#1]{Theorem\,\ref*{thm:#1}}} \newcommand{\Fact}[1]{\hyperref[fact:#1]{Fact\,\ref*{fact:#1}}} \newcommand{\Lem}[1]{\hyperref[lem:#1]{Lemma\,\ref*{lem:#1}}} \newcommand{\Prop}[1]{\hyperref[prop:#1]{Prop.~\ref*{prop:#1}}} \newcommand{\Cor}[1]{\hyperref[cor:#1]{Corollary~\ref*{cor:#1}}} \newcommand{\Conj}[1]{\hyperref[conj:#1]{Conjecture~\ref*{conj:#1}}} \newcommand{\Def}[1]{\hyperref[def:#1]{Definition~\ref*{def:#1}}} \newcommand{\Alg}[1]{\hyperref[alg:#1]{Alg.~\ref*{alg:#1}}} \newcommand{\Clm}[1]{\hyperref[clm:#1]{Claim~\ref*{clm:#1}}} \newcommand{\Obs}[1]{\hyperref[obs:#1]{Observation~\ref*{obs:#1}}} \newcommand{\Rem}[1]{\hyperref[rem:#1]{Remark~\ref*{rem:#1}}} \newcommand{\Con}[1]{\hyperref[con:#1]{Construction~\ref*{con:#1}}} \newcommand{\Step}[1]{\hyperref[step:#1]{Step~\ref*{step:#1}}} \newcommand{\Assumption}[1]{\hyperref[assm:#1]{Assumption\,\ref*{assm:#1}}} 

\newcommand{\Sesh}[1]{{\color{red} Sesh: #1}}




\newcommand{\Esymb}{\mathbb{E}}
\newcommand{\Psymb}{\mathbb{P}}
\newcommand{\Vsymb}{\mathbb{V}}
\newcommand{\Varsymb}{\mathrm{Var}}
\def\pr{{\operatorname p}}


\DeclareMathOperator*{\ExpOp}{\Esymb}
\DeclareMathOperator*{\ProbOp}{\Psymb}

\newcommand{\nesetril}{Ne\v{s}et\v{r}il}
 

\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsmath}
\usepackage{comment}
\usepackage{tikz}
\usepackage{paralist}
\usepackage{caption}
\usetikzlibrary{positioning}
\usepackage{mathtools,amsfonts}

\usepackage{thm-restate}
\usepackage{standalone}
\usepackage{standalone}


\begin{document}
	
	\maketitle
	
	\begin{abstract}
		We study the classic problem of subgraph counting, where we wish to determine the number of occurrences of a fixed pattern graph $H$ in an input graph $G$ of $n$ vertices. Our focus is on \emph{bounded degeneracy} inputs, a rich family of graph classes that also characterizes real-world massive networks. 
		Building on the seminal techniques introduced by Chiba-Nishizeki (SICOMP 1985), a recent line of work has built subgraph counting algorithms for bounded degeneracy graphs. Assuming fine-grained complexity conjectures, there is a complete characterization of patterns $H$ for which linear time subgraph counting is possible. For every $r \geq 6$, there exists an $H$ with $r$ vertices that cannot be counted in linear time.
		
		In this paper, we initiate a study of subquadratic algorithms for subgraph counting on bounded degeneracy graphs. We prove that when $H$ has at most $9$ vertices, subgraph counting can be done in $\tilde{O}(n^{5/3})$ time. As a secondary result, we give improved algorithms for counting cycles of length at most $10$. Previously, no subquadratic algorithms were known for the above problems on bounded degeneracy graphs. 
		
		Our main conceptual contribution is a framework that reduces subgraph counting in bounded degeneracy graphs to counting smaller hypergraphs in arbitrary graphs. We believe that our results will help build a general theory of subgraph counting for bounded degeneracy graphs.
	\end{abstract}
	
	
	\section{Introduction} \label{sec:intro}
	
	The fundamental algorithmic problem of subgraph counting in a large input graph has a long
	and rich history~\cite{Lo67, DiSeTh02, FlGr04, DaJo04, Lo12, AhNeRo+15, CuDeMa17, PiSeVi17, SeTi19}.
	There are applications in logic, properties of graph products, partition functions in statistical physics, database theory, machine learning, and network science~\cite{ChMe77,BrWi99,DrRi10,BoChLo+06,PiSeVi17,DeRoWe19,PaSe20}. 
	We are given a \emph{pattern} graph $H = (V(H), E(H))$, and an \emph{input} graph $G = (V(G), E(G))$.
	All graphs are assumed to be simple. We use $\Sub{G}{H}$ to denote the problem of computing the number of (not necessarily induced) subgraphs of $H$ in $G$, that is, the number of subgraphs of $G$ isomorphic to $H$. 
	
	If the pattern is part of the input, this problem becomes $\mathbb{NP}$-hard,
	as it subsumes subgraph isomorphism. Often, one thinks of the pattern $H$ as fixed, and running times are parameterized in terms of the properties (like the size) of $H$.
	Let us set $n = |V(G)|$ and $k = |V(H)|$. 
	There is a trivial brute-force $O(n^k)$ algorithm, but we do not expect
	$O(n^{k-\eps})$ algorithms for general $H$ for some constant $\eps> 0$~\cite{DaJo04}. 
	
	The rich field of subgraph counting focuses on restrictions on the pattern or the input,
	under which non-trivial algorithms and running times are possible~\cite{ItRo78,AlYuZw97,BrWi99,DrGr00,DiSeTh02,DaJo04,BoChLo+06,CuDeMa17,Br19,RoWe20}. 
	Given the practical importance of subgraph counting, there is a special focus on linear time
	(or small polynomial) running times.
	
	Inspired by seminal work of Chiba-Nishizeki~\cite{ChNi85}, a recent line of work has focused
	on building a theory of subgraph counting for \emph{bounded degeneracy graphs}~\cite{Br19,BePaSe20,BePaSe21,BrRo22,BeGiLe+22}.
	These are classes of graphs where all subgraphs have a constant average degree. 
    This work culminated in results of Bera-Pashanasangi-Seshadhri and Bera-Gishboliner-Levanzov-Seshadhri-Shapira~\cite{BePaSe21, BeGiLe+22}.
	We now have precise dichotomy theorems characterizing linear time subgraph counting in bounded degeneracy graph.
    When $H$ has at most $5$ vertices, then $\Sub{G}{H}$ can
	be determined in linear time (if $G$ has bounded degeneracy). For all $k \geq 6$,
    there is a pattern $H$ on $k$ vertices that cannot be counted in linear time, assuming
    fine-grained complexity conjectures.
	The following question is the next step from this line of work.
	\smallskip
	
	\emph{When can we get subquadratic algorithms for subgraph counting (when $G$ has bounded degeneracy)?
		Are there non-trivial algorithms that work for all $H$ with $6$ (or more) vertices?
	}
	
	\smallskip
	Before stating our main results, we offer some justification for this problem.
	
	{\bf Bounded degeneracy graphs:} This is an extremely rich family of graph classes, containing
	all minor-closed families, bounded expansion families, and preferential attachment graphs~\cite{Se23}.
	Most massive real-world graphs, like social networks, the Internet, communication networks, etc.,
	have low degeneracy (\cite{GoGu06,JaSe17,ShElFa18,BeChGh20,BeSe20}, also Table 2 in~\cite{BeChGh20}). 
	The degeneracy has a special significance in the analysis of real-world graphs, since it is intimately tied to the technique of ``core decompositions''~\cite{Se23}. 
	Most of the state-of-the-art practical subgraph counting algorithms use algorithmic techniques
	for bounded degeneracy graphs~\cite{AhNeRo+15,JhSePi15,PiSeVi17,OrBr17,JaSe17,PaSe20}.
	
	{\bf Subquadratic time:} From a theoretical perspective, the orientation techniques of
	Chiba-Nishizeki and further results~\cite{ChNi85,BePaSe20,BePaSe21,BeGiLe+22} are designed for linear time algorithms.
	The primary technical tool is the use of DAG-Tree decompositions, introduced
	in a landmark result of Bressan \cite{Br19,Br21}. Bressan's algorithm yields running times
	of the form $n^r$, where $r \in \NN$ and is the \emph{DAG-treewidth} of $H$.
	It is known that linear time algorithms are possible iff the DAG-treewidth is one \cite{BeGiLe+22}.
	It is natural to ask if the DAG-treewidth being two is a natural barrier. 
	\emph{Subquadratic} algorithms would necessarily require a new technique, other than
	DAG-treewidth. It would also show situations where the DAG-treewidth can be beaten.
	
	From a practical standpoint, the best exact subgraph counting codes (the ESCAPE package~\cite{escape}) use methods similar to the above results. Algorithms for bounded degeneracy graphs have been remarkably successful in dealing with modern large networks. Subquadratic algorithms could provide new practical tools for subgraph counting.
	
	{\bf The focus on $6$ vertices and the importance of cycle patterns:} The problem
	of counting all patterns of a fixed size is called \emph{graphlet analysis}
	in bioinformatics and machine learning \cite{Pr07,ShViPe+09}. Current scalable exact counting codes go to
	5 vertex patterns~\cite{escape}, which is precisely the theoretical barrier seen in \cite{BePaSe20}.
	Part of our motivation is to understand the complexity of counting all $6$ vertex patterns
	(in bounded degeneracy graphs). 
	
	The seminal cycle detection work of Alon-Yuster-Zwick also gave algorithms 
	parameterized by the graph degeneracy~\cite{AlYuZw97}. But most of their results are for cycle \emph{detection}, whereas counting is arguably the more relevant problem. It is natural to ask if counting is also feasible with similar running times.
	
	\subsection{Main Results} \label{sec:results}
	
	Our main result shows that patterns with at most $9$ vertices can be counted in subquadratic time. Let $n$ be the number of vertices and $\degen$ be the degeneracy of the input graph $G$.
    The degeneracy $\kappa$ is the maximum value, over all subgraphs of $G$, of the minimum degree of the subgraph.
    In what follows, $f:\NN \to \NN$ denote some explicit function.

	\begin{restatable}{theorem}{main}(Main Theorem)\label{thm:main} 
		There is an algorithm that computes\maybefootnote{1}{We can obtain a similar result for the problem of counting only induced subgraphs $\IndSub{G}{H}$, as it can be expressed as a linear combination of $\Sub{G}{H'}$ for some patterns $H'$ with $V(H')=V(H)$.} $\Sub{G}{H}$ for all patterns $H$ with at most $9$ vertices
		in time $f(\degen) \tilde{O}(n^{5/3})$.\maybefootnote{2}{We express our results parameterizing by the degeneracy of the input graph $G$. Note that if $G$ is from a class with bounded degeneracy, then $f(\degen)$ is constant and we can ignore that term.}
	\end{restatable}

	Recall that previous works gave (near) linear time algorithms when $H$ had at most $5$ vertices \cite{BePaSe20}. The best subgraph counting algorithm for bounded degeneracy graphs is Bressan's algorithm, which runs in at least quadratic (if not cubic) time for many patterns with $6$ to $9$ vertices.
	
    Additionally, we construct an explicit $10$-vertex pattern that we conjecture cannot be counted in subquadratic time in the bounded degeneracy setting. We are able to relate the complexity of counting that pattern to counting a specific hypergraph in general graphs, which we believe can not be done in subquadratic time. (More in \Sec{invert} and \Sec{hardness}.)
	
	\subsubsection{Counting cycles}

	As a secondary result, we are able to show that cycle counting in bounded degeneracy graphs can be done even faster. These results are tight, in the sense that any improvement will imply beating long
    standing cycle detection algorithms for sparse graphs. Let $\cycle{k}$ denote the $k$-cycle and $d_k$ be the exponent (in terms of edges) of the fastest algorithm for $k$-cycle detection. 
    Gishboliner-Levanzov-Shapira-Yuster (henceforth GLSY) recently showed that \emph{homomorphism} counting of $\cycle{2k}$ in bounded degeneracy graphs can be done in time $O(n^{d_k})$~\cite{GiLeSh+23}. 
    We prove that this complexity can be matched for the problem of \emph{subgraph} counting. Cycle counting is more challenging, since it involves compute linear combinations
    of homomorphisms of non-cyclic patterns (which requires other techniques).
	
	\begin{theorem} \label{thm:cycles}


		\begin{asparaitem}
			\item There is an algorithm that computes $\Sub{G}{\cycle{6}}$ and $\Sub{G}{\cycle{7}}$ in time $f(\degen)\tilde{O}(n^{d_3}) \approx f(\degen)\tilde{O}(n^{1.41})$. Additionally, no $f(\degen)o(n^{d_3})$ algorithm exists unless there exists a $o(m^{d_3})$ algorithm for counting triangles.
			\item There is an algorithm that computes $\Sub{G}{\cycle{8}}$ and $\Sub{G}{\cycle{9}}$ in time $f(\degen)\tilde{O}(n^{d_4}) \approx f(\degen)\tilde{O}(n^{1.48})$. Additionally, no $f(\degen)O(n^{d_4})$ algorithm exists unless there exists a $o(m^{d_4})$ algorithm for counting $4$-cycles.
			\item There is an algorithm that computes $\Sub{G}{\cycle{10}}$ in time $f(\degen)\tilde{O}(n^{d_5}) \approx f(\degen)\tilde{O}(n^{1.63})$. Additionally, no $f(\degen)o(n^{d_5})$ algorithm exists unless there exists a $o(m^{d_5})$ algorithm for counting $5$-cycles.
		\end{asparaitem}
	\end{theorem}

	Previously, for bounded degeneracy graphs, subquadratic results were only known
    for detecting cycles, by a result of Alon, Yuster and Zwick \cite{AlYuZw97}. \Thm{cycles} improves or matches their bounds in all cases, despite solving the harder problem of counting. 
    The lower bounds relating to cycle counting in general graphs follow directly from the techniques of GLSY~\cite{GiLeSh+23}.
    We note that the exponents $d_k$ have not been improved for twenty years~\cite{AlYuZw97, YuZw04}.
    As a side corollary of our methods, we also get a better algorithm for counting $5$-cycles in arbitrary graphs (\Cor{5-cycle}).

	
	\subsection{Main Ideas} \label{sec:ideas}
	
	The theorems above are obtained from a new reduction technique that converts
	homomorphism counting in bounded degeneracy graphs to subgraph counting in 
	arbitrary graphs for some specific patterns.

The starting point for most subgraph counting algorithms for bounded degeneracy graphs
	is to use \emph{graph orientations}~\cite{Se23}. A graph $G$ has bounded degeneracy iff
	there exists an acyclic orientation $\vec{G}$ such that all vertices have bounded \emph{outdegree}.
	(An acyclic orientation is obtained by directing the edges of $G$ into a DAG.)
	Moreover, this orientation can be found in linear time~\cite{MaBe83}. To count $H$-subgraphs
	in $G$, we consider all possible orientations $\vec{H}$ of $H$ and compute
	(the sum of) all $\Sub{\vec{G}}{\vec{H}}$.
	
	The approach formalized by Bressan~\cite{Br21} and Bera-Pashanasangi-Seshadhri~\cite{BePaSe20} is to break $\vec{H}$ into a collection of (out)directed trees rooted at the sources of $\vec{H}$. 
	The copies of each tree in $\vec{G}$ can be enumerated in linear time, since outdegrees
	are bounded. We need to figure out how to "assemble" these trees into copies of $\vec{H}$.
	
	Bressan's DAG-tree decomposition gives a systematic method to perform this assembly,
	and the running time is $O(n^\tau)$, where $\tau$ is the ``DAG-treewidth'' of $\vec{H}$.
	The definition is technical, so we do not give details here. 
	Also, this method only gives the homomorphism count (edge-preserving maps from $H$ to $G$), and we require further
	techniques to get subgraph counts~\cite{CuDeMa17}. 
	The main contribution of the linear time dichotomy theorems is to completely characterize patterns $H$ such that all orientations $\vec{H}$ have DAG-treewidth one~\cite{BePaSe21,BeGiLe+22}. 
	
	Since $\tau$ is a natural number, to get subquadratic time algorithms, we need new ideas.
	
	\subsubsection{The 6-cycle} It is well-known (from~\cite{AlYuZw97}) that linear-time orientation based methods hit an obstruction at $6$-cycles. 
    Consider the oriented $6$-cycle in the left of \Fig{cycles}. It is basically a ``triangle'' of out-out wedges (as given by the red lines); indeed, one can show that $6$-cycle counting in bounded degeneracy graphs is essentially equivalent to triangle counting in arbitrary graphs~\cite{BePaSe20,BePaSe21,BeGiLe+22}.
    This observation can be converted into an algorithm, as was shown by GLSY~\cite{GiLeSh+23}. Starting with $\vec{G}$, we create a new graph with edges (the red lines) corresponding to the endpoints of out-out wedges. Since $\vec{G}$ has bounded outdegree, the number of edges in the new graph is $O(n)$. Every triangle in the new graph corresponds to a (directed) $6$-cycle homomorphism in $\vec{G}$.
	Triangle counting in the new graph can be done in $O(n^{1.41})$ time (or $n^{3/2}$ time using a combinatorial algorithm)~\cite{AlYuZw97}. 
    Getting the subgraph count is more involved, but we can use existing methods that reduce to homomorphism counting~\cite{CuDeMa17}.
	
	\begin{figure}[t]
		\centering
		\begin{minipage}{.47\linewidth}
			\centering
			\includegraphics[width=\textwidth]{figures/cycle6.png}
		\end{minipage}
		\hspace{0.5cm}
		\begin{minipage}{.47\linewidth}
			\centering
			\includegraphics[width=\textwidth]{figures/example_reducible.png}
		\end{minipage}
		\caption{(a) The $6$-cycle obstruction, this orientation has three sources intersecting with each other, this oriented pattern can not be counted in linear time in bounded degeneracy graphs. Adding an edge connecting the end-points of every out-out wedge gives a triangle. (b) An example of how the oriented $\cycle{8}$ reduces to a $\cycle{4}$, the four sources become edges connecting the intersection vertices.} 
		\label{fig:cycles}
	\end{figure}
	
	One can extend this idea more generally as follows. 
	Let $\vec{H}$ be a directed pattern, a source is any vertex with no incoming arcs, and we define an intersection vertex as any vertex that can be ``reached'' by two different sources.
	
	Suppose there are $k$ sources and $k$ intersection vertices. Suppose further that there is an ordering of the sources $\{s_0,...,s_{k-1}\}$ and the intersection vertices $\{i_0,...,i_{k-1}\}$ of $\vec{H}$ such that, for all $j$, only the sources $s_j$ and $s_{j+1}$ (taking modulo $k$ in the indexes) can both reach the vertex $i_j$.
	This is the case of the oriented $\cycle{6}$ and $\cycle{8}$ in \Fig{cycles} or of any acyclic orientation of any cycle.
	One can then construct a new graph $G'$ such that $\Sub{G'}{\cycle{k}}$ is the same as $\Hom{\vec{G}}{\vec{H}}$ (where $\Hom{\vec{G}}{\vec{H}}$ denotes the homomorphism count). 
	
	
	\subsubsection{Generalizing to non-cyclic patterns}
	
	So far, the algorithmic approach only makes sense for cycle patterns. Our main contribution is a framework that generalizes this approach to count homomorphisms and subgraphs of more complex patterns. 
	
	The first part of our framework is the concept of \reducible{P} patterns. A directed pattern is \reducible{P} if we can reduce counting homomorphisms of it to counting $P$ subgraphs in a sparse hypergraph. The formal definition is technical and can be seen in \Sec{reduce}. We provide a simplified exposition in this section.
	
	Consider a directed pattern $\vec{H}$, for example the left image in \Fig{reductions}. We can replace every source with a hyperedge connecting the intersection vertices reachable by the source. The result is a graph (or hypergraph) $P$ such that $\vec{H}$ is \reducible{P}. 
	
	However, our framework allows for even more freedom: instead of looking at individual sources, we partition sources into sets of sources $S_e$. See the rightmost figure in \Fig{reductions} for an example, where the $6$ sources are divided into $4$ sets of sources. 
	The sub-patterns induced by the vertices reachable by every set of sources are ``easy'' to count using existing techniques. We can also arrange the intersection vertices into sets $I_v$ such that every set of sources will reach some sets of intersection vertices. We can obtain $P$ by replacing every set of intersection vertices with a vertex and every set of sources $S_e$ with a hyperedge $e$ that contains the vertices corresponding to the sets of intersection vertices that can be reached by $S_e$.
	
	In the example of \Fig{reductions}, the intersection of the vertices reachable from source sets forms a ``cyclic arrangement''. The intersection vertices reachable from $S_1$ are also reachable from $S_2$ and $S_4$, and similarly for the other sets of sources, giving that the pattern will be \reducible{\cycle{4}}. 

	\begin{figure}[t]
		\centering
		\begin{minipage}{.4\linewidth}
			\centering
			\includegraphics[width=\textwidth]{figures/example_reducible3.png}
		\end{minipage}
		\hspace{0.5cm}
		\begin{minipage}{.52\linewidth}
			\centering
			\includegraphics[width=\textwidth]{figures/example_reducible2.png}
		\end{minipage}
		\caption{Two more complex examples $P$-reducibility.} 
		\label{fig:reductions}
	\end{figure}
	
	\subsubsection{The reduced graph} \label{sec:reduced}
	
	The second part of our framework is the \emph{reduced graph}. If a pattern is \reducible{P}, then for any directed input graph $\vec{G}$,
	we can construct a colored weighted graph $\reduced{P}$ with the following property. The number of homomorphisms of the original pattern relates to the number of colorful copies of $P$ in $\reduced{P}$. 
	
	The reduced graph consists of $|V(P)|$ layers of vertices, where each layer is related to one intersection set of $\vec{H}$. Specifically, there is a vertex in the $j$-th layer for every possible image of the corresponding intersection set $I_j$ in $\vec{G}$, that is, every set of vertices in $\vec{G}$ such that $I_j$ can be mapped to it. Moreover, the vertices of every layer will have the same color. For example, for every intersection set $I_j$ in $\vec{H}$ and any map $\phi:I_j\to \vec{G}$ there is a vertex $(\phi(I_j) \mhyphen j)$ in $\reduced{P}$ with color $j$.\footnote{There could be $O(n^{|I_j|})$ such vertices, however, as we will note later, there will be at most $O(n)$ edges, so we can ignore vertices with degree $0$ and we do not need to even create them.}
	
	The edges have weights that represent the number of homomorphisms mapping the intersection sets to the corresponding images. For example, let $S$ be a source set reaching two intersection sets $I_j=\{i_j\}$ and $I_{j'}=\{i_{j'}\}$, and let $u,v \in \vec{G}$. An edge $e$ connecting $(u\mhyphen j)$ and $(v \mhyphen j')$ with weight $w=w(e)$ indicates that there are $w$ different homomorphisms mapping $\vec{H}(S)$ (the subgraph of $\vec{H}$ induced by the vertices reachable by $S$) to $\vec{G}$ that map $j$ to $u$ and $j'$ to $v$. Additionally we can show that if $\vec{G}$ has bounded outdegree, then the new reduced graph will have $O(n)$ edges.
	
	We give an example in \Fig{example_reduction}. For simplicity of exposition, the graph $\vec{G}$ is smaller than the pattern. 
	Each vertex of $\vec{G}$ has three copies (each with a different color) in the reduced graph, denoted $G_{\cycle{3}}$. Since the vertex $a$ cannot be the image
	of any intersection vertex (it has zero indegree), copies of this vertex do not appear in $G_{\cycle{3}}$. Observe that there is no mapping of an out-out wedge 
	where $b$ is one endpoint and $d$ is the other endpoint. Hence, there is no edge from a copy of $b$ to a copy of $d$. 
	
	\begin{figure}
		\centering
		\includegraphics[width=\textwidth*3/5]{figures/example_reduction.png}\caption{An example of the construction of $\reduced{\cycle{3}}$, for pattern $\vec{H}$ and input graph $\vec{G}$. The red vertices correspond with $i_1$ in $\vec{H}$, the green ones with $i_2$ and the blue ones with $i_3$. The weight of the edges is $1$ except when indicated. For example there are two homomorphisms $\phi: \vec{H}(s_2) \to \vec{G}$ that map $i_1$ and $i_2$ to $c$, hence the edge $(c\mhyphen 1,c\mhyphen 2)$ has weight $2$. One can verify that the number of homomorphisms from $\vec{H}$ to $\vec{G}$ is equal to the sum of products of (colorful) triangles in $\reduced{\cycle{3}}$.}
		\label{fig:example_reduction}
	\end{figure}
	
	Every colorful copy of $P$ in $\reduced{P}$ correspond to fixing the positions of the intersection sets in $\vec{G}$, and the weight of each hyperedge will correspond to the number of homomorphisms mapping that portion of the graph. Hence the product of the weights of all hyperedges in each copy will give the total number of homomorphisms mapping all the intersection sets to the corresponding vertices in $\vec{G}$.
	Therefore, the total number of homomorphisms will be equal to the quantity $\WSub{\reduced{P}}{P}$, which corresponds to the sum of products of weights of colorful copies of $P$. That is:
	\begin{equation} \label{eq:wsub}
		\WSub{\reduced{P}}{P} = \sum_{P \in \colSetSub(P,\reduced{P})} \prod_{e\in E(P)} w(e)
	\end{equation}
Here, $\colSetSub(P,\reduced{P})$ denotes the set of distinct colorful copies of $P$ in $\reduced{P}$. We are able to show that solving $\WSub{\reduced{P}}{P}$ is equivalent to counting the number of homomorphisms of $\vec{H}$ in $\vec{G}$.

	Therefore, we can count homomorphisms of \reducible{P} patterns in the same time as counting colorful copies of $P$ in the reduced graph.
	
	\begin{restatable}{lemma}{maindirected} \label{lem:main_directed}
		Let $c>1$, if there exists a $\tilde{O}(m^{c})$ algorithm that for any graph $G'$ computes $\WSub{G'}{P}$. Then, for any \reducible{P} pattern $\vec{H}$ and directed input graph $\vec{G}$ we can compute $\Hom{\vec{G}}{\vec{H}}$ in time $f(\maxoutdeg)\tilde{O}(n^{c})$, where $\maxoutdeg$ is the maximum outdegree of $\vec{G}$.
	\end{restatable}

	\subsubsection{From directed to undirected: getting homomorphisms counts}
	
	To extend our reduction framework to undirected graphs we introduce the concept of \computable{\cP} patterns. Note that different acyclic orientations of the same pattern might reduce to different graphs. We say that a pattern $H$ is \computable{\cP} if all the acyclic orientations of $H$ can be computed in linear time or are \reducible{P} for some $P\in \cP$. If for all the patterns in $\cP$ we can compute $\WSubNI{P}$ in time $O(m^c)$ then we can use \Lem{main_directed} to get a bound in the complexity of $\Hom{G}{H}$.

	For each $k\geq 6$, we find a set of hypergraphs $\cP_k$ such that all patterns with $k$ vertices are \computable{\cP_k}. These sets grow with $k$ and we have $\cP_k \subseteq \cP_{k+1}$. We give a definition of these sets in Section \Sec{others} and prove the following lemma.
	
	\begin{restatable}{lemma}{pkcomputable} \label{lem:pk_computable}
		Let $k\geq 6$, every connected pattern $H$ with $k$ vertices is \computable{\mathcal{P}_{k}}.
	\end{restatable}
	

	For $k=9$ we are able to show that there exists a subset $\cP^*_9$ of $\cP_9$ such that every $9$-vertex pattern is also \computable{\cP^*_9} and for every pattern $P \in \cP^*_9$ we can compute $\WSubNI{P}$ in $\tilde{O}(m^{5/3})$ time. Allowing us to show that for all patterns with $9$ vertices or less we can count the number of homomorphisms in subquadratic time.

	We can also show similar results for cycles. All orientations of cycle patterns can be reduced to cycles of half their length. This means that any $2k$-cycle and $2k+1$-cycle are \computable{\{\cycle{k}\cup...\cup \cycle{3} \}} (in these cases we will simply write \computable{\cycle{k}}).

	We can also show that for all cycles we can compute $\WSub{G}{\cycle{k}}$ in $\tilde{O}(m^{d_k})$ time, the fastest time for detecting $k$-cycles in general graphs.
	
	\begin{restatable}{lemma}{cyclecomplexity} \label{lem:cycle_complexity}
		For all $k\geq 3$, there is an algorithm that computes $\WSub{G}{\cycle{k}}$ in time $\tilde{O}(m^{d_k})$.
	\end{restatable}
	
	This means that we can compute the number of homomorphisms of $\cycle{2k}$ and $\cycle{2k+1}$ in time $\tilde{O}(m^{d_k})$, similar result to the one obtained in  GLSY~\cite{GiLeSh+23}.
	
	
	\subsubsection{Getting subgraph counts} \label{sec:subgraph}
	
	At this point, we have algorithms for computing various pattern \emph{homomorphisms}. To get subgraph counts,
	we need the inclusion-exclusion techniques of~\cite{CuDeMa17}. One can express the $H$-subgraph
	count as a linear combination of $H'$-homomorphism counts, where $H'$ is a pattern in $\Spasm(H)$.
	The $\Spasm(H)$ consists of all patterns $H'$ such that $H$ has a surjective homomorphism to $H'$.
	Thus, every pattern in the spasm has at most as many vertices as $H$. 

	Hence for any pattern $H$ with $k$ vertices, all the patterns in $\Spasm(H)$ will have at most $k$ vertices and hence they will also be \computable{\cP_k}, giving \Thm{main}.
	
	In the case of the cycles, to be able to extend the results from last section to the $Sub$ problem, we analyze the spasm of the different cycles. For $k\leq 10$ we are able to show that the patterns in the spasms of $\cycle{k}$ are also \computable{\cycle{\lfloor k/2 \rfloor}}. That combined with \Lem{cycle_complexity} implies the upper bound of \Thm{cycles}.
	
    \subsubsection{Inverting the reduction for conditional hardness} \label{sec:invert}
	
    We show that in some cases our reduction procedure is optimal. For example, counting small cycles in general graphs can be reduced to counting cycles of twice the length in graphs of degeneracy $\kappa=2$. The reduction is quite simple and just involves subdividing the edges. With a slight modification, the subdivision approach can be used to show lower bounds for odd cycles too, which gives the lower bound of \Thm{cycles}. We note that an analogous result for counting homomorphisms was shown in GLSY~\cite{GiLeSh+23}.
	
	\begin{restatable}{lemma}{lowerbound} \label{lem:lowerbound}
		Let $6\leq k \leq 10$, an $f(\degen)o(n^{d_{\lfloor k/2 \rfloor}})$ algorithm for counting $k$-cycles implies the existence of a $o(m^{d_{\lfloor k/2 \rfloor}})$ algorithm for counting $\lfloor k/2 \rfloor$-cycles. 
	\end{restatable}

	
	 This inversion of the reduction procedure also gives us an algorithm for counting undirected $5$-cycles in general graphs which improves on the current state of the art, and matches the complexity for $5$-cycle detection.
	
	\begin{restatable}{corollary}{fivecycle} \label{cor:5-cycle}
		There is an algorithm that, for any graph $G$, computes $\Sub{G}{\cycle{5}}$ in time $O\left(m^{d_5} \right) \approx O\left(m^{1.63}\right)$.
	\end{restatable}

	The approach of subdividing edges can be used to prove a relation between other patterns too. In the case of hypergraphs, we can replace hyperedges of arity $r$ by $r$-stars. We are able to show a strong relation between the hypergraph $\hyperthree$ depicted in \Fig{hyperthree}, and a $10$-vertex pattern. We conjecture that for this pattern we can not count the number of subgraphs in subquadratic time.
	\begin{conjecture} \label{conj:hyperthree}
		There is no $o(m^2)$ algorithm for computing $\Sub{G}{\hyperthree}$.
	\end{conjecture}
	\begin{figure}
	\centering
	\includegraphics[width=\textwidth*1/4]{figures/Special3.png}\caption{The hypergraph $\hyperthree$.}
	\label{fig:hyperthree}
	\end{figure}
	This conjecture implies that there are no subquadratic algorithms for computing the number of subgraphs of all $10$-vertex patterns.
	\begin{restatable}{lemma}{hardness} \label{lem:hardness}
		If \Conj{hyperthree} holds, there is no algorithm that computes $\Sub{G}{H}$ in time $f(\degen)o(n^{2})$ for all patterns $H$ with $10$ vertices.
	\end{restatable}
	We consider it an interesting open problem to relate our conjecture with existing fine-grained complexity assumptions. Some previous works prove barriers for subquadratic \emph{listing} in general graphs~\cite{BrGo24}, but no similar results exist for counting hypergraphs.

	
	\subsection{Related Work}  \label{sec:related}
	
	Subgraph counting is closely tied to homomorphism counting; in some cases,
	it is more convenient to talk about the latter. Seminal work
	of Curticepean-Dell-Marx showed that the optimal algorithms for subgraph
	counting can be designed from homomorphism counting algorithms and vice versa \cite{CuDeMa17}.
	
	Much of the study of subgraph/homomorphism counting comes from
	paramterized complexity theory.
	D{\'\i}az et al ~\cite{DiSeTh02} gave a $O(2^{k}n^{tw(H)+1})$
	algorithm for determining the $H$-homomorphism count,
	where $tw(H)$ is the treewidth of $H$.
	Dalmau and Jonsson~\cite{DaJo04} proved
	that $\Hom{G}{H}$ is polynomial time solvable iff
	$H$ has bounded treewidth. Otherwise it is
	$\#W[1]$-complete. Roth and Wellnitz~\cite{RoWe20} consider 
	restrictions of both $H$ and $G$, and focus of $\#W[1]$-completeness.
	
	Tree decompositions have played an important role in subgraph counting.
	We give a brief review of the graph parameters treewidth and degeneracy.
	The notion of tree decomposition and treewidth were introduced in a seminal work by Robertson and Seymour~\cite{RoSe83,RoSe84,RoSe86}, although the concept
	was known earlier~\cite{BeBr73,Ha76}.
	
	Degeneracy is a measure of sparsity and has
	been known since the early work of Szekeres-Wilf~\cite{SzWi68}.
	We refer the reader to the short survey of Seshadhri~\cite{Se23} about degeneracy
	and algorithms. The 
	degeneracy has been exploited for subgraph counting problems in many
	algorithmic results~\cite{ChNi85,Ep94,AhNeRo+15,JhSePi15,PiSeVi17,OrBr17,JaSe17,PaSe20}.
	
	Bressan connected degeneracy to treewidth-like notation and introduced
	the concept of DAG treewidth~\cite{Br19, Br21}. 
	The main result is the following. For a pattern $H$ with $|V(H)|=k$ and 
	an input graph $G$ with $|E(G)|=m$ and degeneracy $\degen$,
	one can count $\Hom{G}{H}$ in
	$f(\degen,k)O(m^{\dtw(H)}\log m)$ time, where $\dtw(H)$ is the 
	DAG treewidth of $H$. Assuming the exponential time hypothesis~\cite{ImPaZa98}, the subgraph counting problem does not admit
	any $f(\degen,k)m^{o(\dtw(H)/\ln \dtw(H))})$ algorithm, for any positive function $f:\mathbb{N}\times \mathbb{N} \rightarrow \mathbb{N}$.
	
	Bera-Pashanasangi-Seshadhri introduced the first theory of linear time homomorphism
	counting \cite{BePaSe20}, showing that all patterns with at most $5$ vertices could be counted in linear time. It was later shown that for every pattern with no induced cycles of length $6$ or more, the number of homomorphisms could also be counted in linear time \cite{BePaSe21,BeGiLe+22}.
	
	A recent work of Komarath et al. \cite{KoKuMi+23} gave quadratic and cubic algorithms for counting cycles in sparse graphs. Gishboliner et al. gave subquadratic algorithms for homomorphism counting of cycles in bounded degeneracy graphs \cite{GiLeSh+23}.
	Bressan, Lanziger and Roth have also studied counting algorithms for directed patterns \cite{BrLaRo23}.
	

	
	\subsection{Paper Organization}
	
	In Section $3$, we define our reduction framework formally and prove the equivalence between the bounded degeneracy and the general setting. In Section $4$,
    we prove that many patterns are cycle-reducible. In Section $5$, we define the sets $\cP_k$ and complete the proof of the main theorem. Finally, in Section $6$, we show how to compute Col-WSub for cycle patterns. Due to space limitations most proofs have been deferred to the appendix, including the proofs of \Lem{lowerbound} and \Lem{hardness}.
	
	\section{Preliminaries} \label{sec:prelim}
	
	\paragraph*{Graphs, subgraphs and homomorphisms}
	
	We use $H = (V(H), E(H))$ to denote the pattern graph and $G = (V(G),E(G))$ to denote the input graph. We will use $n=|V(G)|$ and $m=|E(G)|$ for the number of vertices and edges of $G$ respectively.
	
	A homomorphism from $H$ to $G$ is a mapping $\phi: V(H) \to V(G)$ such that $\forall (u,v) \in E(H)$ we have $(\phi(u),\phi(v)) \in E(G)$. We use $\Phi(H,G)$ to denote the set of all homomorphisms from $H$ to $G$. We use $\Hom{G}{H}$ to denote the problem of counting the number of homomorphisms from $H$ to $G$, that is, computing $|\phi(H,G)|$. Similarly we use $\Sub{G}{H}$ to denote the problem of counting the number of subgraphs (not necessarily induced) of $G$ isomorphic to $H$.
	
	We say that two homomorphisms $\phi: V \to G$ and $\phi': V' \to G$ agree if for any vertex $v \in V \cap V'$ we have $\phi(v) = \phi'(v)$.
	
	The spasm of a graph is the set of all possible graphs obtained by recursively combining two vertices that are not connected by an edge, removing any duplicated edge. Using inclusion-exclusion arguments one can express the value of $\Sub{G}{H}$ as a weighted sum of homomorphism counts of the graphs in the spasm of $H$. Hence, computing $\Hom{G}{H'}$ for all $H'\in \Spasm(H)$, allows to compute $\Sub{G}{H}$, as given by the following equation: $\Sub{G}{H}  = \sum_{H' \in \Spasm(H)} f(H') \Hom{G}{H'}$.
	
	Here $f(H')$ are a series of non-zero coefficients that can be computed for each $H$. See \cite{BoChLo+06} for more details. Curticapean, Dell and Marx showed that this process is optimal \cite{CuDeMa17}, that is, the complexity of $\Sub{G}{H}$ is exactly the hardest complexity of $\Hom{G}{H'}$ for the graphs in $\Spasm(H)$.
	
	\paragraph*{Degeneracy and directed graphs}
	
	A graph $G$ is $\degen$-degenerate if every subgraph has a minimum degree of at most $\degen$. The degeneracy $\degen(G)$ of a graph is the minimum value such that $G$ is $\degen$-degenerate. There exists an acyclic orientation of a graph, called the degeneracy orientation, which has the property that the maximum outdegree of the graph is at most $\degen$ \cite{MaBe83}. Additionally, this orientation can be computed in $O(n+m)$ time. We will use $\vec{G}$ to denote the directed input graph. For a pattern $H$, we use $\Sigma(H)$ to denote the set of acyclic orientations of $H$. When orienting the input graph, every occurrence of $H$ will now appear as exactly one of its acyclic orientations, that is, $\Hom{G}{H} = \sum_{\vec{H} \in \Sigma(H)} \Hom{\vec{G}}{\vec{H}}$.
	
	We say that $v \in V(\vec{H})$ is a source if its in-degree is $0$. We use $S(\vec{H})$ to denote the set of sources of $\vec{H}$. We say a vertex $u$ is reachable from $v$ if there is a directed path connecting $v$ to $u$ and use $\Reachable_{\vec{H}}(s)$ to denote the set of vertices reachable by the source $s$. Abusing notation, for a set $S' \subseteq S(\vec{H})$ we use $\Reachable_{\vec{H}}(S')$ (or $\Reachable(S')$ if $\vec{H}$ is clear from the context) to denote the set of vertices reachable by any vertex in $S'$. We use $\vec{H}(S)$ and $\vec{H}(s)$ for the subgraphs of $\vec{H}$ induced by $\Reachable_{\vec{H}}(S)$ and $\Reachable_{\vec{H}}(s)$. 
	
	We say that a vertex $v$ of $\vec{H}$ is an intersection vertex if there are at least two distinct sources $s,s' \in S(\vec{H})$ such that $v$ is reachable by both of them, that is, $v \in \vec{H}(s) \cap \vec{H}(s')$. We use $I(\vec{H})$ to denote the set of intersection vertices. Note that $S(\vec{H}) \cap I(\vec{H}) = \emptyset$.
	
	\paragraph*{The \dagtreewidth}
	
	Bressan introduced the concept of \dagtree{} of a directed acyclic graph \cite{Br19}:
	
	\begin{definition}[\dagtree{} \cite{Br19}]
		For a given directed acyclic graph $\vec{H} = (V(\vec{H}),E(\vec{H}))$, a \dagtree{} of $\vec{H}$ is a rooted tree $T=(\cB,\cE)$ such that: 
		\begin{itemize}
			\item Each node $B \in \cB$, is a subset of the sources of $\vec{H}$, $B \subseteq S(\vec{H})$.
			\item Every source of $\vec{H}$ is in at least one node of $T$, $\bigcup_{B \in \cB} B = S(\vec{H})$.
			\item $\forall B,B_1,B_2 \in \cB$. If $B$ is in the unique path between $B_1$ and $B_2$ in $T$, then $\Reachable_{\vec{H}}(B_1) \cap \Reachable_{\vec{H}}(B_2) \subseteq \Reachable_{\vec{H}}(B)$.
		\end{itemize}
	\end{definition}
	
	The \dagtreewidth{} of a \dagtree{} $T$,  $\dtw(T)$, is the maximum size of all the bags in $T$. The \dagtreewidth{} of a directed acyclic graph $\vec{H}$ is the minimum value of $\dtw(T)$ across all valid \dagtree{} $T$ of $\vec{H}$. For an undirected graph $H$, we will have that $\dtw(H) = \max_{\vec{H} \in \Sigma(H)} \dtw(\vec{H})$.
	
	\paragraph*{Using \dagtree{} to compute homomorphisms}
	
	Bressan gave an algorithm that computes $\Hom{G}{H}$ making use of the \dagtree{} of a directed pattern \cite{Br19,Br21}. The algorithm decomposes the pattern into smaller subgraphs, computes the number of homomorphisms of every subgraph and then combines the counts using dynamic programming.
	\begin{theorem} \label{thm:bressan} \cite{Br19}
		For any pattern $H$ with $k$ vertices there is an algorithm that computes $\Hom{G}{H}$ in time $f(k, \degen) \tilde{O}(n^{\dtw(H)})$.
	\end{theorem}
	For the patterns with $\dtw(H) = 1$ we obtain an algorithm that runs in linear time when parameterized by the degeneracy of the input graph. Bera et al. showed an exact characterization of which patterns have $\dtw(H) = 1$.
	\begin{lemma} \label{lem:licl} \cite{BePaSe21}
		$LICL(H) < 6 \Leftrightarrow$ $\dtw(H) = 1$.
	\end{lemma}
	
	If we analyze the algorithm from Bressan in more detail, we can see that it can be used as a black box to obtain some more fine-grained counts. In order to understand this we need to introduce the following definition:
	
	A homomorphism $\phi'$ extends $\phi$ if for every vertex $u \in \phi$ we have $\phi(u) = \phi'(u)$. Let $\phi$ be a homomorphism from a subgraph $\vec{H}'$ of $\vec{H}$ to $\vec{G}$. We define $\extension{\vec{H}}{\vec{G}}{\phi}$ as the number of homomorphisms $\phi'$ from $\vec{H}$ to $\vec{G}$ that extend $\phi$.
	
	\begin{lemma} [\label{lem:bressan_ext} Lemma $5$ in \cite{Br21} (restated)] There exists an algorithm that, given a directed pattern $\vec{H}$ with $k$ vertices and a \dagtree{} $T$ rooted in $s$ with $\dtw(T)=1$, and a directed graph $\vec{G}$ with $n$ vertices and maximum outdegree $d$; returns, for every homomorphism $\phi:\vec{H}[s] \to \vec{G}$, the quantity $\extension{\vec{H}}{\vec{G}}{\phi}$. The algorithm runs in time $f(k,d)\tilde{O}(n)$.
	\end{lemma}
	
	\paragraph*{Hypergraphs}
	
	A hypergraph is a graph where the each edge (or hyperedge) is a subset of the vertices. The arity of a hyperedge is the number of vertices that it contains. We will only consider hypergraphs where every hyperedge has arity at least $2$. We use $E(G)$ for the set of hyperedges of $G$, where for each $e \in E(G)$ we have $e \subseteq V(G)$.We will also consider weighted hypergraphs, for a hypergraph $G$, the function $w: E(G) \to \NN$ gives the weight of each hyperedge $e$ in $G$. We use $\simplex{k}$ to denote the simplex hypergraph of arity $k$.
	
	\section{The reduction procedure} \label{sec:reduce}
	
	In this section we explain our reduction procedure. We start with the concept of $P$-reducibility. The main idea is to divide the set of sources of the directed pattern $\vec{H}$ into $|E(P)|$ different subsets of sources $S_e$, each corresponding to one hyperedge $e$ in $E(P)$, such that every source in $S(\vec{H})$ belong to exactly one subset $S_e$. We also require that the subgraphs reachable by every set of source can be counted efficiently using Bressan's algorithm.
	
	We also set $|V(P)|$ distinct subsets of intersections vertices $I_v \subseteq I(\vec{H})$, with each subset corresponding to each vertex $v$ in $V(P)$. Not all the intersection vertices of $I(\vec{H})$ must belong necessarily to one of the subsets, and we use $I^*$ to denote the set of intersection vertices that appear in at least one of the set. Moreover, different intersection sets can contain the same intersection vertex, however we require that the vertices corresponding to sets that contain the same intersection vertex in $V(P)$ induce a connected subgraph.
	
	We use $I(e)$ to denote the vertices in $I^*$ reachable by the sources in $S_e$. For every hyperedge $e$ of $P$, we require that the corresponding set of sources can reach all the vertices in the intersection sets corresponding to the vertices of $e$. Also the set of sources related to every hyperedge containing the vertex $v$ must reach all the vertices in $I_v$. These conditions ensure that we will be able to combine the homomorphism counts for each of the subgraphs $\vec{H}(S_e)$. We now present the full definition.
	
	\begin{definition} [\reducible{P}] \label{def:reducible}
	A connected DAG $\vec{H}$ is \reducible{P} if we can set:
	\begin{itemize}
		\item For every vertex $v \in V(P)$, a subset of intersection vertices $I_v \subseteq I(\vec{H})$. With $I^*=\bigcup_i I_i$. Such that for every intersection vertex $i \in I^*$, we have that the vertices $\{v : i \in I_v\} \subseteq V(P)$ induce a connected hypergraph in $P$.
		
		\item For every hyperedge $e \in E(P)$, a subset of sources $S_e \subseteq S(\vec{H})$. With $S_e \cap S_{e'} =\emptyset\ \forall e\neq e'$ and $\bigcup_{e\in E(P)} S_e = S(\vec{H})$. Such that every subset of sources $S_e$ contains a source $s_e$ with $\vec{H}(s_e) \cap I^* = \vec{H}(S_e) \cap I^* = I(e)$, and the subgraph $\vec{H}(S_e)$ admits a $\dtw=1$ \dagtree{} rooted at the source $s_e$.
		\end{itemize}
		Satisfying:
		\begin{enumerate}
			\item  For every vertex $v \in V(P)$: $I_v \subseteq I(e) \forall e \ni v$
			\item For every hyperedge $e \in E(P)$: $\bigcup_{v \in e} I_v = I(e)$
		\end{enumerate}
	
	\end{definition}

	We now define the reduced graph $\reduced{P}$.

	\begin{definition} [Reduced graph $\reduced{P}$]  \label{def:reduced_graph} 
		Given a \reducible{P} directed pattern on source sets $\{S_e : e \in E(P)\}$ and intersection sets $\{I_v : v \in V(P)\}$, we define the reduced graph $\reduced{P}$ of the directed input graph $\vec{G}$ as follows:
		\begin{itemize}
			\item For every vertex $v\in V(P)$ and every homomorphism $\phi: I_{v} \to \vec{G}$ we have the vertex $(\phi(I_{v})\mhyphen v)$ with color $v$. The vertices with the same color form the ``layers'' of $\reduced{P}$.
			\item For every hyperedge $e\in E(P)$ and for every homomorphism $\phi: I(e) \to \vec{G}$, let $\phi_v$ be the restriction of $\phi$ to $I_v$ for each vertex $v \in e$, we will have a hyperedge connecting the vertices $\{(\phi_v(I_v) \mhyphen v) : v\in e\}$ with weight $\extension{\vec{H}(S_e)}{\vec{G}}{\phi}$.
		\end{itemize}
	\end{definition}

	We use $V^{(v)}(\reduced{P})$ to refer to the vertices of $\reduced{P}$ in the $v$-th layer. 
	The number of vertices in every layer $v$ can be up to $O(n^{|I_v|})$, however we will only consider vertices that are not isolated, that is, have degree at least $1$. We can show that we can construct $\reduced{P}$ efficiently when only considering such vertices.
	
	\begin{restatable}{lemma}{construct} \label{lem:construct_reduced_graph} 
		Given a \reducible{P} pattern $\vec{H}$ and a directed graph $\vec{G}$ with maximum outdegree $\maxoutdeg$, we can construct $\reduced{P}$ in $f(\maxoutdeg)\tilde{O}(n)$ time. Additionally, the number of non-isolated vertices and the total number of hyperedges are bounded by $f(\maxoutdeg)O(n)$.
	\end{restatable}


	We can now prove the equivalence between homomorphisms of the original pattern and weighted colorful copies of the reduced hypergraph. This lemma relates the counts between the original and the reduced graph.

	\begin{restatable}{lemma}{equivalence}\label{lem:equivalence_reduction}
		$
		\Hom{\vec{G}}{\vec{H}} = \WSub{\reduced{P}}{P}
		$
	\end{restatable}


	Finally, we have all the tools to complete our reduction framework, giving us \Lem{main_directed}.
	
	\maindirected*
	\begin{proof}\textcolor{red}{TOPROVE 0}\end{proof}

	\subsection{From directed to undirected}
	
	We introduce the concept of \computable{\cP}, which will help us give upper bounds in the complexity of undirected patterns.
	
	\begin{definition}[\computable{\mathcal{P}}] \label{def:computable}
		Let $\mathcal{P}$ be a set of hypergraphs. We say that a pattern $H$ is \computable{\mathcal{P}} if every acyclic orientation $\vec{H} \in \Sigma(H)$ has either \dagtreewidth{} of $1$ or there exists a hypergraph $P \in \mathcal{P}$ such that $\vec{H}$ is $P$-reducible.
	\end{definition}
	
		If a pattern $H$ is \computable{\mathcal{P}} and $\mathcal{P}$ is only formed by cyclic patterns we will instead write \computable{\cycle{l}}, where $l$ is the length of the largest cycle in $\mathcal{P}$. The complexity of computing homomorphisms of \computable{\mathcal{P}} patterns will be dominated by the hardest complexity for computing $\WSubNI{P}$.
	
	\begin{restatable}{lemma}{computablelemma} \label{lem:computable}
				Let $\mathcal{P}$ be a set of hypergraphs, if for every hypergraph $P \in \mathcal{P}$ there is an algorithm that computes $\WSubNI{P}$ in time $\tilde{O}(m^c)$, then for any input graph $G$ with degeneracy $\degen$ and any \computable{\mathcal{P}} pattern $H$, there is an algorithm that computes $\Hom{G}{H}$ in time $f(\degen)\tilde{O}(n^c)$.
		\end{restatable}


	\section{Reducing to cycles} \label{sec:reductions}
	
	We first focus on patterns that can be reduced to counting cycles. We start by introducing the following two lemmas, showing that directed patterns with either few sources or few intersection vertices are \reducible{\cycle{3}}.
	
	\begin{restatable}{lemma}{threesources} \label{lem:3sources}
		Every directed acyclic pattern $\vec{H}$ with at most $3$ sources is either \reducible{\cycle{3}} or $\dtw(\vec{H})=1$.
	\end{restatable}

	\begin{restatable}{lemma}{threeintersections} \label{lem:3intersections}
		Every directed acyclic pattern $\vec{H}$ with at most $3$ intersection vertices is either \reducible{\cycle{3}} or $\dtw(\vec{H})=1$. 
	\end{restatable}
	
	Using this two lemmas we can prove that all $6$ and $7$-vertex patterns are \computable{\cycle{3}}.
	
	\begin{restatable}{lemma}{sixseven} \label{lem:sixseven}
		Every $6$ and $7$-vertex undirected pattern $H$ is \computable{\cycle{3}}.
	\end{restatable}

	Additionally, the patterns in the spasm will always have less vertices, and hence all patterns in the spasms of all $6$ and $7$-vertex patterns will also be \computable{\cycle{3}}. This fact, together with \Lem{cycle_complexity} gives the following.

	\begin{corollary} \label{cor:sixseven}
		Let $H$ be a pattern with $6$ or $7$ vertices. For any input graph $G$, we can compute $\Hom{G}{H}$ and $\Sub{G}{H}$ in time $f(\degen)\tilde{O}(n^{d_3}) \approx f(\degen)O(n^{1.41})$.
	\end{corollary}
	
	We can also show that the acyclic orientations of cycle patterns are always \reducible{\cycle{k}} for some $k$ at most half of the length of the cycle. This is equivalent to the result in \cite{GiLeSh+23}, but expressed using our reducibility framework.
	
	\begin{restatable}{lemma}{cyclehom}  \label{lem:cycle_hom}
		For all $k\geq3$, $\cycle{2k}$ and $\cycle{2k+1}$ are \computable{\cycle{k}}.
	\end{restatable}


	Moreover, we can also show that all patterns in the spasms of cycles up to length $10$ are also cycle-computable.
	
	\begin{lemma} \label{lem:spasms}
		\begin{itemize}
			\item All the patterns in $\Spasm(\cycle{6})$ and $\Spasm(\cycle{7})$ are \computable{\cycle{3}}.
			\item All the patterns in $\Spasm(\cycle{8})$ and $\Spasm(\cycle{9})$ are \computable{\cycle{4}}.
			\item All the patterns in $\Spasm(\cycle{10})$ are \computable{\cycle{5}}.
		\end{itemize}
	\end{lemma}

	This lemma allows us to prove the upper bound of \Thm{cycles}.
	\begin{restatable}{lemma}{uppercycle} \label{lem:uppercycle}
		For all $6\leq k\leq 10$, there is an algorithm that computes $\Sub{G}{\cycle{k}}$ in time $f(\degen)O(n^{d_{\lfloor k/2\rfloor}})$.
	\end{restatable}
	
	\section{Reducing to other patterns} \label{sec:others}
	
	Consider the set of directed patterns with $8$ vertices. Using the results of the previous section we can show that most of the orientations will either admit a \dagtree{} with $\tau=1$ or will be \reducible{\cycle{3}}. However, if a pattern $\vec{H}$ has $4$ sources and $4$ intersection vertices then it might not be cycle-reducible. Instead we might need to reduce to some hypergraphs, like in \Fig{reductions}. The following definitions will help us determining which patterns we will need to reduce to for patterns with at least $8$ vertices.
	
	\begin{restatable}{definition}{calp} [$\mathcal{P}_{i,s}$, $\mathcal{P}_k$] \label{def:group}
		We define $\mathcal{P}_{i,s}$ as the set of hypergraphs $P$ with $i$ vertices and $s$ hyperedges such that:
		\begin{enumerate}
			\item Every vertex has degree at least $2$.
			\item Every hyperedge contains at least $2$ vertices.
			\item No hyperedge is a subset of any other hyperedge.
			\item For every pair of distinct vertices $u,v \in V(P)$ the set of hyperedges containing $u$ can not be equal or a subset of the set of hyperedges containing $v$.
		\end{enumerate}
		For any $k\geq 7$, we define $\mathcal{P}_{k}$ recursively as the union of $\cP_{k-1}$ and all sets $\mathcal{P}_{i,s}$, with $i+s = k$ and $i,s\geq 4$, with $\cP_6=\{\cycle{3}\}$.
	\end{restatable}

	We can prove that for any $k$, patterns with $k$ vertices will reduce to some pattern in $\cP_k$. This was stated earlier as \Lem{pk_computable}.
\pkcomputable*

	In order to prove \Thm{main}, we show exactly which patterns form $\cP_9$.
	
	\begin{lemma} \label{lem:nine_content}
		$
			\cP_9 = \{\cycle{3},\cycle{4},\diamondgraph,\simplex{3},\hyperone, \hypertwo\}
		$
	\end{lemma}
	\begin{figure}[t]
	\centering
	\begin{minipage}{.15\linewidth}
		\centering
		\includegraphics[width=\textwidth]{figures/diamond.png}
	\end{minipage}
	\hspace{1cm}
	\begin{minipage}{.15\linewidth}
		\centering
		\includegraphics[width=\textwidth]{figures/Special_1.png}
	\end{minipage}
	\hspace{1cm}
	\begin{minipage}{.2\linewidth}
		\centering
		\includegraphics[width=\textwidth]{figures/Special2.png}
	\end{minipage}
	\caption{The diamond graph $\diamondgraph$, the hypergraph $\hyperone$ and the hypergraph $\hypertwo$.} 
	\label{fig:hypers}
	\end{figure}
	Where, $\diamondgraph$ is the diamond pattern, $\simplex{3}$ the $3$-simplex, $\hyperone$ and $\hypertwo$ are the two hypergraphs shown in \Fig{hypers}. It turns out that simplex-reducible patterns are also cycle-reducible. Hence we can set $\cP^*_9 = \cP_9 \setminus \simplex{3}$ and show that every \computable{\cP_9} pattern is also \computable{\cP^*_9}.
	
	\begin{restatable}{lemma}{ninestar} \label{lem:nine_star}
		If a pattern $H$ is \computable{\cP_9}, then it is also \computable{\cP^*_9}
	\end{restatable}

	We can show that all the hypergraphs in $\cP^*_9$ can be counted in subquadratic time.
	
	\begin{restatable}{lemma}{allnine} \label{lem:allnine}
			For any weighted colored hypergraph $G$ with $m$ edges, there is an algorithm that computes $\WSub{G}{P}$ for all patterns $P \in \cP^*_9$ in time $\tilde{O}(m^{5/3})$.
	\end{restatable}


	Finally we can prove the main theorem.
	
	\main*
	\begin{proof}\textcolor{red}{TOPROVE 1}\end{proof}

	\section{Counting cycles} \label{sec:wsub}
	
	We adapt the two algorithms for counting weighted homomorphisms of cycles shown in \cite{GiLeSh+23} for computing $\WSubNI{\cycle{k}}$. The first is a combinatorial algorithm that matches the complexity of detecting directed cycles combinatorially~\cite{AlYuZw97}. The second is a matrix multiplication based algorithm which adapts the algorithm from \cite{YuZw04}. The complexity of this algorithm for counting $\cycle{k}$ is given by the value $c_k$, the exact values of $c_k$ for $k\geq 6$ are not known, but the following upper bound holds~\cite{DaVuWi19}:
	\begin{equation}
	\begin{split} 
		&c_k \leq \frac{\omega(k+1)}{2\omega+k-1}\ &\text{if $k$ is odd} \qquad\qquad
		&c_k \leq \frac{\omega k - 4/k}{2 \omega + k - 2 - 4/k}\ &\text{if $k$ is even}
	\end{split}
	\end{equation}
	Where $\omega$ is the matrix multiplication exponent.
	\begin{lemma} \label{lem:wsub_cycles}
		Let $G$ be a colored weighted graph with $m$ edges. For all $k>3$:
		\begin{itemize}
			\item There is a combinatorial algorithm that computes $\WSub{G}{\cycle{k}}$ in time $\tilde{O}(m^{2-1/\lceil k/2 \rceil })$.
			\item There is an algorithm that computes $\WSub{G}{\cycle{k}}$ in time $\tilde{O}(m^{c_k})$.
		\end{itemize}
	\end{lemma}

	For any $k$ we use $d_k$ for the fastest of the two algorithms, similar to \cite{GiLeSh+23}. \Lem{cycle_complexity} follows directly from \Lem{wsub_cycles} and the following equation:
	\begin{equation} \label{eq:dk}
		d_k = min(2-1/\lceil k/2 \rceil,c_k)
	\end{equation}

	Note that $d_k < 2$ for all $k$, hence we have subquadratic algorithms for all cycles. For $k<6$ and using the fastest matrix multiplication exponent known to date $\omega = 2.371339$ \cite{AlDuWi+25}, we have that the matrix multiplication algorithm is faster and we get the following approximate values of $d_k$: $d_3 \approx 1.41$, $d_4 \approx 1.48$ and $d_5 \approx 1.63$.
	
	\bibliography{subgraph_counting_doi}
	
	\newpage
	\appendix
	\section{Proofs of Section \ref{sec:reduce}}
	
	\subsection{Proof of \Lem{construct_reduced_graph}}
	
	First, we show how to compute homomorphism extensions of the different subgraphs $\vec{H}(S_e)$ of \reducible{P} patterns, this is a necessary step in order to construct the reduced graph.
	
	\begin{lemma} \label{lem:extension_subgraphs}
		Let $\vec{H}$ be a \reducible{P} directed pattern and $\vec{G}$ a directed input graph with $n$ vertices and maximum outdegree $\maxoutdeg$. Let $\{S_e : e\in E(P)\}$ and $\{I_v : v\in V(P)\}$ be the sets of sources and intersections that achieve the $P$-reducibility. For every set of sources $S_e$ we can compute $\extension{\vec{H}(S_e)}{\vec{G}}{\phi}$ for every $\phi: I(e) \to \vec{G}$ in $f(\maxoutdeg)\tilde{O}(n)$ time. Additionally, there are at most $f(\maxoutdeg)O(n)$ homomorphisms $\phi$ with non-zero extension.
	\end{lemma}
	\begin{proof}\textcolor{red}{TOPROVE 2}\end{proof}
	
	We can now prove \Lem{construct_reduced_graph}.
	
	\construct*
	\begin{proof}\textcolor{red}{TOPROVE 3}\end{proof}

	\subsection{Proof of \Lem{equivalence_reduction}}
	First we show that each colorful copy of $P$ in $\reduced{P}$ can be related to $|V(P)|$ homomorphisms that do not disagree in any vertex.
	
	\begin{claim} \label{clm:connected}
		Let $P' \in \colSetSub(P,\reduced{P})$ with vertex set $\{u_v : v \in V(P)\} = V(P')$. Consider the homomorphisms $\{\phi_v\}$ corresponding to each vertex $u_v \in V(P')$ such that $u_v = (\phi_v(I_v)\mhyphen v)$. Every pair of homomorphisms will agree with each other.
	\end{claim}
	\begin{proof}\textcolor{red}{TOPROVE 4}\end{proof}
	
	We can now prove \Lem{equivalence_reduction}. This lemma relates the counts between the original and the reduced graph.
	
	\equivalence*
	\begin{proof}\textcolor{red}{TOPROVE 5}\end{proof}

	\subsection{Proof of \Lem{computable}}
	
	\computablelemma*
	\begin{proof}\textcolor{red}{TOPROVE 6}\end{proof}

	\section{Proofs of Section \ref{sec:reductions}}

	\subsection{Proof of \Lem{3sources}}
		\threesources*
		\begin{proof}\textcolor{red}{TOPROVE 7}\end{proof}

	\subsection{Proof of \Lem{3intersections}}
	\threeintersections*
	\begin{proof}\textcolor{red}{TOPROVE 8}\end{proof}

	\subsection{Proof of \Lem{sixseven}}
	\sixseven*	
	\begin{proof}\textcolor{red}{TOPROVE 9}\end{proof}

	\subsection{Proof of \Lem{cycle_hom}}
	\cyclehom*
	\begin{proof}\textcolor{red}{TOPROVE 10}\end{proof}

	\subsection{Proof of \Lem{spasms}}
	
	We start by proving some auxiliary lemmas.
	
		\begin{lemma} \label{lem:merge}
		Given two directed patterns $\vec{P},\vec{P}'$ with $\dtw(\vec{P}) = \dtw(\vec{P}') = 1$, the graph $\vec{P}''$ obtained by either merging a vertex from $\vec{P}$ with a vertex from $\vec{P}'$ or two vertices $u,v$ from $\vec{P}$ connected by an edge with two vertices $u',v'$ from $\vec{P}'$ connected by an edge will also have $\dtw(\vec{P}'') = 1$.
	\end{lemma}
	
	\begin{proof}\textcolor{red}{TOPROVE 11}\end{proof}
	
	\begin{figure}
		\centering
		\includegraphics[width=\textwidth*3/4]{figures/dag.png}\caption{The possible cases in \Lem{merge}. $T$ and $T'$ represent \dagtree{} of the graphs $\vec{P}$ and $\vec{P}'$, with $u \in \Reachable_{\vec{P}}(r)$ and $u' \in \Reachable_{\vec{P}'}(r')$.}
		\label{fig:dag}
	\end{figure}
	
	
	\begin{lemma} \label{lem:complexpattern}
		Given any \computable{\cycle{k}} undirected pattern $H$, and an undirected connected pattern $H'$ with $\LICL(H')<6$, the graphs resulting of the following operations are \computable{\cycle{k}}:
		\begin{itemize}
			\item Merge any vertex $u \in H$ with any vertex $u' \in H'$.
			\item Combine any edge $(u,v) \in E(H)$ with any edge $(u',v') \in E(H')$ by merging $u$ with $u'$ and $v$ with $v'$, and removing the duplicate edge.
		\end{itemize}
	\end{lemma}
	\begin{proof}\textcolor{red}{TOPROVE 12}\end{proof}
	
	Now we have all the tools to prove \Lem{spasms}. We break the result into different lemmas. The result for $\cycle{6}$ and $\cycle{7}$ follows directly from \Lem{sixseven}, as every pattern in those spasms will have at most $7$ vertices. We prove next the result for $\cycle{8}$ and $\cycle{9}$.
	
	\begin{lemma}
		All the patterns in $\Spasm(\cycle{8})$ and $\Spasm(\cycle{9})$ are \computable{\cycle{4}}.
	\end{lemma}
	
	\begin{figure}
		\centering
		\includegraphics[width=\textwidth*1/2]{figures/spasm8.png}\caption{The spasm of $\cycle{8}$, only including patterns with \LICL{} greater than $5$.}
		\label{fig:spasm8}
	\end{figure}
	
	\begin{figure}
		\centering
		\includegraphics[width=\textwidth*4/5]{figures/spasm9.png}\caption{The spasm of $\cycle{9}$, only including patterns with \LICL{} greater than $5$.}
		\label{fig:spasm9}
	\end{figure}
	
	\begin{proof}\textcolor{red}{TOPROVE 13}\end{proof}
	
	Finally, we prove the result for $\cycle{10}$.
	
	\begin{lemma}
		All the patterns in $\Spasm(\cycle{10})$ are \computable{\cycle{5}}.
	\end{lemma}
	\begin{proof}\textcolor{red}{TOPROVE 14}\end{proof}
	
	\subsection{Proof of \Lem{uppercycle}}
	\uppercycle*
	\begin{proof}\textcolor{red}{TOPROVE 15}\end{proof}
	
	\section{Proofs of Section \ref{sec:others}}
	
	\subsection{Proof of \Lem{pk_computable}}
	
	For reference we restate the definition of $\mathcal{P}_{i,s}$ and $\mathcal{P}_k$.
	
	\calp*
	
	We can show that if we have a graph $P$ satisfying the first three conditions definition, then every \reducible{P} pattern can also be reduced to some graph in $\mathcal{P}_{i,s}$, for some $i$ and $s$.
	
	\begin{lemma} \label{lem:simplify}
		Let $P$ be a hypergraph with $i\geq4$ vertices and $s \geq 4$ hyperedges such that:
		\begin{enumerate}
			\item Every vertex has degree at least $2$.
			\item Every hyperedge contains at least $2$ vertices.
			\item No hyperedge is a subset of any other hyperedge.
		\end{enumerate}
		Then, for some $i' \leq i$, there exists a hypergraph $P' \in \mathcal{P}_{i',s}$ such that every directed pattern $\vec{H}$ that is \reducible{P} is also \reducible{P'}.
	\end{lemma}
	\begin{proof}\textcolor{red}{TOPROVE 16}\end{proof}
	
	We can now prove \Lem{pk_computable}.
	
	\pkcomputable*
	\begin{proof}\textcolor{red}{TOPROVE 17}\end{proof}
	
	\subsection{Proof of \Lem{nine_content}}
	
	\begin{figure}
		\centering
		\includegraphics[width=\textwidth*1/4]{figures/Special_1.png}\caption{The hypergraph $\hyperone$. Formed by one hyperedge of arity $3$ (in gray) and three normal edges.}
		\label{fig:hyperone}
	\end{figure}
	
	From the definition of $\cP_9$ we have that:
	\[
		\cP_9 = \cP_8 \cup \cP_{4,5}  \cup \cP_{5,4} = \{\cycle{3}\} \cup \cP_{4,4} \cup \cP_{4,5}  \cup \cP_{5,4}
	\]
	We will show which patterns form each of these sets. First, we can show that $\cP_{4,4}$ is formed by the $4$-cycle, the $3$-simplex and $\hyperone$ (\Fig{hyperone}).
	
	\begin{claim}
		$\mathcal{P}_{4,4} = \{\cycle{4}, \simplex{3}, \hyperone \}$
	\end{claim}
	\begin{proof}\textcolor{red}{TOPROVE 18}\end{proof}

	$\cP_{4,5}$ only contains the diamond graph $\diamondgraph$, also known as $K_4$ minus one edge.

	\begin{claim}
		$\mathcal{P}_{4,5} = \{\diamondgraph \}$.
	\end{claim}
	\begin{proof}\textcolor{red}{TOPROVE 19}\end{proof}

	\begin{figure}
		\centering
		\includegraphics[width=\textwidth*1/4]{figures/Special2.png}\caption{The hypergraph $\hypertwo$. Formed by two hyperedges of arity $3$ (in gray) and two normal edges.}
		\label{fig:hypertwo}
	\end{figure}
	
	Finally, $\mathcal{P}_{5,4}$ only contains the hypergraph $\hypertwo$ (\Fig{hypertwo}).
	
	\begin{claim}
		$\mathcal{P}_{5,4} = \{\hypertwo\}$.
	\end{claim}
	\begin{proof}\textcolor{red}{TOPROVE 20}\end{proof}

	Combining the three previous claims gives \Lem{nine_content}.
	
	\subsection{Proof of \Lem{nine_star}}
	
	Let $\simplex{r}$ be the $r$-simplex. We can show that every pattern that is \reducible{\simplex{r}} is also \reducible{\cycle{r+1}}. See \Fig{simplex} for an example.
	\begin{lemma} \label{lem:simplex}
		For all $r\geq 3$, every \reducible{\simplex{r}} pattern is \reducible{\cycle{r+1}}.
	\end{lemma}
	\begin{proof}\textcolor{red}{TOPROVE 21}\end{proof}
	
	\begin{figure}
		\centering
		\includegraphics[width=\textwidth*3/4]{figures/simplex_to_cycle.png}\caption{An example of apply \Lem{simplex} to the $3$-simplex, which becomes a $4$-cycle. Here $I'_i =  I_{i+1}\cup I_{i+2}$.}
		\label{fig:simplex}
	\end{figure}

	We can now prove \Lem{nine_star}.
	
	\ninestar*
	\begin{proof}\textcolor{red}{TOPROVE 22}\end{proof}
	
	\subsection{Proof of \Lem{allnine}}
	
	From \Lem{cycle_complexity} we have for $\cycle{3}$ and $\cycle{4}$, we can compute Col-WSub in time $O(m^{d_3})$ and $O(m^{d_4})$ respectively. We verify that for the remaining three graphs in $\cP^*_9$ ($\diamondgraph, \hyperone, \hypertwo)$ we can compute Col-WSub in $\tilde{O}(m^{5/3})$ time.
	
	\begin{lemma}
		There is an algorithm that for any colored, weighted input graph $G$ with $m$ edges computes $\WSub{G}{\hyperone}$ in $O(m^{5/3})$ time.
	\end{lemma}
	\begin{proof}\textcolor{red}{TOPROVE 23}\end{proof}

	\begin{lemma}
		There is an algorithm that for any colored, weighted input graph $G$ with $m$ edges computes $\WSub{G}{\diamondgraph}$ in $\tilde{O}(m^{3/2})$ time.
	\end{lemma}
	\begin{proof}\textcolor{red}{TOPROVE 24}\end{proof}
	
	\begin{lemma} \label{lem:hypertwo}
		There is an algorithm that for any colored, weighted input graph $G$ with $m$ edges computes $\WSub{G}{\hypertwo}$ in $\tilde{O}(m^{5/3})$ time.
	\end{lemma}
	\begin{proof}\textcolor{red}{TOPROVE 25}\end{proof}
	
	\begin{figure}
		\centering
		\includegraphics[width=\textwidth]{figures/ComputingSpecial2.png}\caption{The possible cases for thresholding of hypergraph $\hypertwo$ that are analyzed in \Lem{hypertwo}.}
		\label{fig:hypertwocomp}
	\end{figure}

	
	\section{Proof of \Lem{wsub_cycles}}
	
	The proof will closely follow the structure of Sections $4$ and $5$ in \cite{GiLeSh+23}, with the necessary modifications, as we are simply adapting the existing algorithms.
	
	\subsection{Combinatorial algorithm for cycles}
	
	Let $P_r$ be the path with $r+1$ vertices and $r$ edges with consecutive vertices having consecutive colors. For a colored graph $G$ we use $V^{(l)}(G)$ to denote the set of vertices with color $l$ or just $V^{(l)}$ if $G$ is clear from the context. In this section indexes and colors are taken modulo $k$.
	
	We first show the following auxiliary lemma, equivalent to Lemma $4.1$ in \cite{GiLeSh+23}:
	
	\begin{lemma} \label{lem:aux_cycle}
		Let $G$ be a weighted colored graph with $m$ edges. There is an algorithm that for integers $r, o$ and $\Delta \geq 1$ computes:
		\begin{itemize}
			\item For every pair $u,v \in V(G)$, the total weight $N_{r,o,\Delta}(u,v)$ of paths $P_r =\{p_0,...,p_{r}\}$ in $G$ such that $p_i \in V^{(i+o)}(G)$ for all $i$, $p_0 = u$, $p_{r} = v$ and $d(p_i) \leq \Delta$ for every $0 < i < r$.
			\item For every pair $u,v \in V(G)$ with $d(u) > \Delta$ and for every function $f: \{1,...,r\} \to \{\text{Low},\text{High}\}$ the total weight $M_{r,o,\Delta,f}$ of paths $P_r =\{p_0,...,p_r\}$ in $G$ such that $p_i \in V^{(i+o)}(G)$ for all $i$, $p_0 = u$, $p_{r} = v$ and for all $i>0$, $d(p_i) \leq \Delta$ if $f(i) =\text{Low}$ and $d(p_i) > \Delta$ if $f(i) =\text{High}$.
			\item For every pair $u,v \in V(G)$ with $d(v) > \Delta$ and for every function $f: \{0,...,r-1\} \to \{\text{Low},\text{High}\}$ the total weight $M'_{r,o,\Delta,f}$ of paths $P_r =\{p_0,...,p_r\}$ in $G$ such that $p_i \in V^{(i+o)}(G)$ for all $i$, $p_0 = u$, $p_{r} = v$ and for all $i<r$, $d(p_i) \leq \Delta$ if $f(i) =\text{Low}$ and $d(p_i) > \Delta$ if $f(i) =\text{High}$.
		\end{itemize}
		The first can be computed in time $\tilde{O}(m\Delta^{r-1})$ and the second and third in time $\tilde{O}(m^2/\Delta)$. There are at most $O(m\Delta^{r-1})$ pairs $u,v$ for which $N_{r,\Delta}(u,v) > 0$.
	\end{lemma}
	\begin{proof}\textcolor{red}{TOPROVE 26}\end{proof}
	
	We can now prove the combinatorial algorithm:
	
	\begin{lemma} \label{lem:wsub_cycles_comb}
		Let $G$ be a colored weighted graph with $m$ edges. For all $k>3$, there is a combinatorial algorithm that computes $\WSub{G}{\cycle{k}}$ in time $\tilde{O}(m^{2-1/\lceil k/2 \rceil })$.
	\end{lemma}
	\begin{proof}\textcolor{red}{TOPROVE 27}\end{proof}	
	
	\subsection{Matrix multiplication algorithm for cycles}
	
		We prove now the matrix multiplication algorithm. The following lemma together with \Lem{wsub_cycles_comb} completes the proof of \Lem{wsub_cycles}. The structure of our proof follows closely Section $5$ in \cite{GiLeSh+23}. Note that the indexes over $\{0,...,k-1\}$ will be taken as modulo $k$.
		
		\begin{lemma} \label{lem:wsub_cycles_mm}
		Let $G$ be a colored weighted graph with $m$ edges. For all $k>3$, there is an algorithm that computes $\WSub{G}{\cycle{k}}$ in time $\tilde{O}(m^{c_k})$.
		\end{lemma}
		\begin{proof}\textcolor{red}{TOPROVE 28}\end{proof}
	
	\section{Proof of \Lem{lowerbound}}
		
		\subsection{Even cycles}
			We first prove \Lem{lowerbound} for even cycles.
			\begin{definition} [Expanded Graph]
				Given a graph $G$ with $n$ vertices and $m$ edges we define $\expandG$ as the graph resulting of subdividing every edge in $G$ by a $2$-edge path. The resultant graph has $m+n$ vertices and $2m$ edges.
			\end{definition}
		
		\begin{figure}
			\centering
			\includegraphics[width=\textwidth*3/4]{figures/subdivision.png}\caption{An example of the construction of $\expandG$ from a graph $G$. The original graph had one $\cycle{3}$, one $\cycle{4}$ and one $\cycle{5}$. Those cycle become $\cycle{6},\cycle{8}$ and $\cycle{10}$ respectively.}
			\label{fig:subdivision}
		\end{figure}
		
		\Fig{subdivision} shows an example of the construction. We can show that $\expandG$ has constant degeneracy.
		
		\begin{claim} \label{lem:degen}
			The degeneracy of $\expandG$ is $2$.
		\end{claim}
		\begin{proof}\textcolor{red}{TOPROVE 29}\end{proof}
	
		We also show that there is a direct relation between the cycles in $G$ and in $\expandG$.
	
		\begin{lemma} \label{lem:equivalence}
			For any $k\geq 3$, the number of $\cycle{k}$ in $G$ is equal to the number of $\cycle{2k}$ in $\expandG$.
		\end{lemma}
		\begin{proof}\textcolor{red}{TOPROVE 30}\end{proof}
	
		We can now prove the following lemma.
		
		\begin{restatable}{lemma}{even} \label{thm:even}
			Let $c\geq 1$, if there is an $f(\degen)O(n^c)$ algorithm for counting $2k$-cycles, then there is a $O(m^c)$ algorithm for counting $k$-cycles. 
		\end{restatable}
		\begin{proof}\textcolor{red}{TOPROVE 31}\end{proof}
		
		The previous lemma, together with \Lem{uppercycle} gives \Cor{5-cycle}.

		\fivecycle*
		
		\subsection{Odd cycles}
		
		We now prove the lower bound for $7$ and $9$-cycles. We need to slightly modify our construction.
		
		\begin{definition} [Odd Expanded Graph]
			Given a graph $G$ with $n$ vertices and $m$ edges we define $\expandGOdd$ as the graph resulting of replacing every edge by a $2$-path and a $3$-path. The resultant graph has $3m+n$ vertices and $5m$ edges.
		\end{definition}
		
		\begin{figure}
			\centering
			\includegraphics[width=\textwidth*3/4]{figures/subdivision2.png}\caption{An example of the construction of $\expandGOdd$ from a graph $G$. The original graph had one $\cycle{3}$ and one $\cycle{4}$. The expanded graph has $3$ $\cycle{7}$ and $5$ $\cycle{9}$.}
			\label{fig:subdivision2}
		\end{figure}
		
		\Fig{subdivision2} shows an example of the construction. Again, this graph will have a degeneracy of $2$. We can show the following:
		
		\begin{lemma} \label{lem:equivalence2}
			For any odd $k$:
			\begin{itemize}
				\item $\Sub{\expandGOdd}{\cycle{7}} = 3 \cdot \Sub{G}{\cycle{3}}$
				\item $\Sub{\expandGOdd}{\cycle{9}} = \Sub{G}{\cycle{3}} + 4 \cdot \Sub{G}{\cycle{4}} $
			\end{itemize}
		\end{lemma}
		\begin{proof}\textcolor{red}{TOPROVE 32}\end{proof}
		
		We can now show the lower bounds:
		
		\begin{lemma}
			\begin{itemize}
			\item If an $f(\degen)o(n^{d_3})$ algorithm for $\Sub{G}{\cycle{7}}$ exists then there exist a $o(m^{d_3})$ algorithm for $\Sub{G}{\cycle{3}}$.
			\item If an $f(\degen)o(n^{d_4})$ algorithm for $\Sub{G}{\cycle{9}}$ exists then there exist a $o(m^{d_4})$ algorithm for $\Sub{G}{\cycle{4}}$.
		\end{itemize}
		\end{lemma}
		\begin{proof}\textcolor{red}{TOPROVE 33}\end{proof}
	
	
	
    \section{Proof of \Lem{hardness}} \label{sec:hardness}

	Consider the $10$-vertex graph $H_\triangle$ shown in \Fig{reduction_three}, it has one acyclic orientation $\vec{H}_\triangle$ that is \reducible{\hyperthree}, that can be seen by replacing every source in $\vec{H}_\triangle$  with a hyperedge.
	
	Let $G$ be any input graph with bounded degeneracy, we can show that a subquadratic algorithm for computing $\Sub{G}{H_\triangle}$ implies a subquadratic algorithm for computing $\Sub{\vec{G}}{\vec{H}_\triangle}$.
	
	\begin{lemma} \label{lem:aux_conj}
		If there is a $f(\degen)o(n^2)$ algorithm for computing $\Sub{G}{H_\triangle}$, then there is a $f(\degen)o(n^2)$ algorithm for computing $\Sub{\vec{G}}{\vec{H}_\triangle}$.
	\end{lemma}
	\begin{proof}\textcolor{red}{TOPROVE 34}\end{proof}
	\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{figures/Special3_reduction.png}\caption{The graph $H_\triangle$, its acyclic orientation $\vec{H}_\triangle$ that is \reducible{\hyperthree} and the hypergraph $\hyperthree$.}
	\label{fig:reduction_three}
	\end{figure}
		
	Now we can prove \Lem{hardness}.
	\hardness*
	\begin{proof}\textcolor{red}{TOPROVE 35}\end{proof}
	

	
\end{document}
