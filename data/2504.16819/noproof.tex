\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate]{lipics-v2021}

\nolinenumbers

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}


\usepackage{amsmath} 
\usepackage{amssymb}
\usepackage{mathrsfs}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{hyperref}
\usepackage{stmaryrd}
\usepackage{mathtools}
\usepackage{todonotes}
\hypersetup{hidelinks,breaklinks}
\usepackage{quiver}


\usepackage[notion, quotation, composition]{knowledge}

\newif\ificalp
\icalpfalse 


\knowledge{notion}
|empty word

\knowledge{notion}
|tree
|trees
|$\Sigma$-tree
|$I$-tree
|$[1,2j]$-tree

\knowledge{notion}
|arity
|arities

\knowledge{notion}
|word
|words

\knowledge{notion}
|alphabet
|alphabets

\knowledge{notion}
|concatenation

\knowledge{notion}
|product
|tree product

\knowledge{notion}
|branch
|branches

\knowledge{notion}
|path@tree-p
|paths@tree-p

\knowledge{notion}
|path@automaton-p
|paths@automaton-p

\knowledge{notion}
|index

\knowledge{notion}
|parity accepting
|parity rejecting
|accepting
|rejecting
|acceptance
|accepted

\knowledge{notion}
|accepted@tree

\knowledge{notion}
|acceptance game

\knowledge{notion}
|priority
|priorities

\knowledge{notion}
|parity tree automaton
|tree automata
|automaton
|automata
|non-deterministic $I$-parity tree automaton
|$I$-automaton
|$J$-automaton
|$[1,2j^*]$-automaton
|non-deterministic automaton
|nondeterministic parity tree automaton
|nondeterministic $I$-parity tree automaton

\knowledge{notion}
|state
|states

\knowledge{notion}
|transition
|transitions

\knowledge{notion}
|complete

\knowledge{notion}
|transition path

\knowledge{notion}
|reachable
|reachability
|non-reachable

\knowledge{notion}
|acceptation game
|acceptation games

\knowledge{notion}
|recognized
|recognizes
|recognizing

\knowledge{notion}
|run
|runs

\knowledge{notion}
|accepting run
|accepting@run-acc
|accepting runs
|rejecting run

\knowledge{notion}
|language
|languages

\knowledge{notion}
|$\omega$-regular tree language
|$\omega$-regular tree languages
|regular tree language
|regular language

\knowledge{notion}
|$I$-feasible
|$J$-feasible
|feasible
|feasibility
|$I$-feasibility
|$J$-feasibility

\knowledge{notion}
|deterministic
|deterministic automaton

\knowledge{notion}
|guidable automaton
|guidable automata
|Guidable automata
|guidable
|guidability
|Guidability

\knowledge{notion}
|guiding function

\knowledge{notion}
|preserve acceptance
|preserves acceptance

\knowledge{notion}
|guides
|guided by
|guiding
|guided


\knowledge{notion}
|parity graph
|parity graphs
|$I$-graph
|$I$-graphs

\knowledge{notion}
|even
|odd
|even graph
|odd graph

\knowledge{notion}
|game
|games
|parity game
|parity games

\knowledge{notion}
|play
|plays

\knowledge{notion}
|winning
|winning play
|losing
|losing play

\knowledge{notion}
|strategy
|strategies

\knowledge{notion}
|consistent with

\knowledge{notion}
|winning strategy

\knowledge{notion}
|determined
|determinacy

\knowledge{notion}
|attractor
|attractors



\knowledge{notion}
|attractor decomposition
|attractor decompositions
|decomposition
|decompositions
|($h$-height, $\kappa$-width)-attractor decomposition

\knowledge{notion}
|tight
|tightness

\knowledge{notion}
|well-indexed

\knowledge{notion}
|tree-shape
|tree-shapes

\knowledge{notion}
|level


\knowledge{notion}
|ordered tree
|ordered trees

\knowledge{notion}
|finite tree
|finite
|finite trees

\knowledge{notion}
|child
|children

\knowledge{notion}
|node
|nodes


\knowledge{notion}
|root

\knowledge{notion}
|depth

\knowledge{notion}
|distance
|distances

\knowledge{notion}
|height
|heights

\knowledge{notion}
|diameter
|diameters

\knowledge{notion}
|subtree
|subtrees

\knowledge{notion}
|sibling
|siblings

\knowledge{notion}
|leaf
|leaves

\knowledge{notion}
|mapping
|mappings
|mapping of $G$ into $T$
|mapping of $G$ into $T^*$

\knowledge{notion}
|offset
|offsets


\knowledge{notion}
|$n$-Strahler number
|Strahler number
|Strahler numbers

\knowledge{notion}
|$n$-Strahler number@game-Strahler

\knowledge{notion}
|universal
|universal for $\T$
|universality

\knowledge{notion}
|universal tree
|universal trees

\knowledge{notion}
|width

\knowledge{notion}
|isomorphically embedded
|isomorphic embedding

\knowledge{notion}
|smallest common ancestor
|smallest common ancestors


\knowledge{notion}
|$J,n$-priority transduction game
|priority transduction games
|priority transduction game
|transduction game
|transduction games
|counter
|counters
|register
|registers
|Registers

\knowledge{notion}
|$n$-bound
|$n$-bound by
|$n$-boundedness

\knowledge{notion}
|finitely branching
|finitely-branching

\knowledge{notion}
|rank

\knowledge{notion}
|star-rank

\knowledge{notion}
|regular
|regular tree
|regular trees

\knowledge{notion}
|universal for an automaton $\A$
|universal for $A$
|universal@automaton-univ 
\newcommand{\RR}{\mathbb{R}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\CC}{\mathbb{C}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\GG}{\mathbb{G}}
\newcommand{\PP}{\mathbb{P}}
\newcommand{\KK}{\mathbb{K}}
\newcommand{\IE}{\mathbb{E}}
\newcommand{\IR}{\mathbb{R}}
\newcommand{\IZ}{\mathbb{Z}}
\newcommand{\IN}{\mathbb{N}}
\newcommand{\IP}{\mathbb{P}}
\newcommand{\IF}{\mathbb{F}}

\newcommand{\cF}{\mathcal{F}}
\newcommand{\ck}{\mathcal{K}}
\newcommand{\cK}{\mathcal{K}}
\newcommand{\cL}{\mathcal{L}}
\newcommand{\cN}{\mathcal{N}}
\newcommand{\cNU}{\mathcal{NU}}
\newcommand{\cP}{\mathcal{P}}
\newcommand{\A}{{A}}
\newcommand{\B}{\mathcal{B}}
\newcommand{\C}{\mathcal{C}}
\newcommand{\D}{\mathcal{D}}
\newcommand{\E}{\mathcal{E}}
\newcommand{\F}{\mathcal{F}}
\newcommand{\G}{\mathcal{G}}
\newcommand{\cH}{\mathcal{H}}
\newcommand{\I}{\mathcal{I}}
\newcommand{\K}{\mathcal{K}}
\renewcommand{\L}{\mathcal{L}}
\newcommand{\M}{\mathcal{M}}
\newcommand{\N}{\mathcal{N}}
\newcommand{\cO}{\mathcal{O}}
\newcommand{\R}{\mathcal{R}}
\renewcommand{\S}{\mathcal{S}}
\newcommand{\T}{\mathcal{T}}
\newcommand{\U}{\mathcal{U}}
\newcommand{\V}{\mathcal{V}}
\newcommand{\X}{\mathcal{X}}

\newcommand{\bA}{\mathbf{A}}
\newcommand{\bE}{\mathbf{E}}
\newcommand{\bF}{\mathbf{F}}
\newcommand{\bG}{\mathbf{G}}
\newcommand{\bN}{\mathbf{N}}
\newcommand{\bU}{\mathbf{U}}
\newcommand{\bX}{\mathbf{X}}

\newcommand{\ens}[1]{\left\{ #1 \right\}}
\newcommand{\set}[1]{\left\{ #1 \right\}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\renewcommand{\le}{\leqslant}
\renewcommand{\ge}{\geqslant}
\newcommand{\cplx}[1]{\mathcal O \left( #1 \right)}
\newcommand{\floor}[1]{\left \lfloor #1 \right \rfloor}
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\brackets}[1]{\left\llbracket #1 \right\rrbracket}
\renewcommand{\angle}[1]{\left\langle #1 \right\rangle}
\newcommand{\donne}{\rightarrow}
\newcommand{\gives}{\rightarrow}
\newcommand{\dans}{\to}
\newcommand{\booleen}{\set{0,1}^*}
\newcommand{\eps}{\varepsilon}
\renewcommand{\implies}{~\Rightarrow~}
\newcommand{\tildarrow}{\rightsquigarrow}
\newcommand{\blank}{\texttt{\char32}}
\newcommand{\trans}[1]{\xrightarrow{#1}}
\newcommand{\rules}[1]{\xrightarrow{#1}}
\newcommand{\wtf}[1]{\Large\textcolor{red}{WTF ?! #1}\normalsize}
\newcommand{\argmin}{\text{argmin}}
\newcommand{\rainbowdash}{\vdash}
\newcommand{\notrainbowdash}{\nvdash}
\newcommand{\rainbowDash}{\vDash}
\newcommand{\notrainbowDash}{\nvDash}
\newcommand{\Rainbowdash}{\Vdash}
\newcommand{\notRainbowdash}{\nVdash}
\newcommand{\bottom}{\bot}
\newcommand{\ra}{\rightarrow}
\newcommand{\Ra}{\Rightarrow}
\newcommand{\longra}{\longrightarrow}
\newcommand{\longRa}{\Longrightarrow}
\newcommand{\la}{\leftarrow}
\newcommand{\La}{\Leftarrow}
\newcommand{\longla}{\longleftarrow}
\newcommand{\longLa}{\Longleftarrow}
\newcommand{\lra}{\leftrightarrow}
\newcommand{\LRa}{\Leftrightarrow}
\newcommand{\longlra}{\longleftrightarrow}
\newcommand{\longLRa}{\Longleftrightarrow}
\newcommand{\opname}[1]{\operatorname{#1}}
\newcommand{\suml}{\sum\limits}
\newcommand{\prodl}{\prod\limits}
\newcommand{\liml}{\lim\limits}
\newcommand{\supl}{\sup\limits}
\newcommand{\infl}{\inf\limits}
\newcommand{\maxl}{\max\limits}
\newcommand{\minl}{\min\limits}
\newcommand{\bigcapl}{\bigcap\limits}
\newcommand{\bigcupl}{\bigcup\limits}


\newcommand{\ptime}{{\sc PTime}}

\newcommand{\exptime}{{\sc ExpTime}} 
\knowledgenewcommand{\concat}{\cmdkl{\cdot}}
\knowledgenewcommand{\Tr}[1]{\cmdkl{Tr_{#1}}}
\knowledgenewcommand{\trProd}{\cmdkl{\otimes}}
\knowledgenewcommand{\Lang}{\cmdkl{\L}}

\knowledgenewcommand{\attr}{\cmdkl{\mathtt{Attr}}}
\knowledgenewcommand{\restrict}{\cmdkl{\upharpoonright}}

\knowledgenewcommand{\subt}{\cmdkl{\sqsubseteq}}
\knowledgenewcommand{\h}{\cmdkl{\mathtt{h}}}
\knowledgenewcommand{\dist}{\cmdkl{\delta}}

\knowledgenewcommand{\Ut}[1]{\cmdkl{\U_{#1}}}

\knowledgenewcommand{\Reg}[2]{\cmdkl{\T_{#1}^{#2}}}


\knowledgenewcommand{\Succ}{\mathit{\cmdkl{Succ}}}
\knowledgenewcommand{\St}[1]{\cmdkl{\S_{#1}}}

\knowledgenewcommand{\For}{\cmdkl{\F}}

\knowledgenewcommand{\guided}{\cmdkl{\rtimes}}

\knowledgenewcommand{\AGame}[2]{\cmdkl{\G(#1,#2)}}

\knowledgenewcommand{\rks}{\cmdkl{\mathtt{rk}^*}}
\knowledgenewcommand{\rk}{\cmdkl{\mathtt{rk}}}

\knowledgenewcommand{\Rg}[2]{\cmdkl{\R(#1,#2)}}
\knowledgenewcommand{\g}{\cmdkl{\mathtt{g}}}
\knowledgenewcommand{\RgS}{\cmdkl{\mathtt{Reg}}}


\newcommand{\parity}{\mathtt{Parity}}

\newcommand{\oi}[1]{\todo[color=green!40,caption={},size=\tiny]{#1}}
\newcommand{\oii}[1]{\todo[color=green!30,inline]{#1}}
\newcommand{\karoliina}[1]{\todo[color=blue!40,caption={},size=\tiny]{#1 - K}}
\newcommand{\karoliinai}[1]{\todo[color=blue!40,inline]{#1}}

\newcommand{\added}[1]{{\color{purple}[#1]}}



\bibliographystyle{plainurl}

\title{Using games and universal trees to characterise the nondeterministic index of tree languages} 

\titlerunning{Games, universal trees and the index of tree languages} 

\author{Olivier Idir}{Université Paris Cité, CNRS, IRIF, France}{olivier.idir@ens-lyon.org}{https://orcid.org/0009-0003-3848-8515}{}

\author{Karoliina Lehtinen}{CNRS, Université Aix-Marseille, LIS, Marseille, France}{karoliina.lehtinen@lis-lab.fr}{https://orcid.org/0000-0003-1171-8790}{}

\authorrunning{O. Idir and K. Lehtinen} 

\Copyright{Olivier Idir and Karoliina Lehtinen} 

\ccsdesc[100]{Theory of computation~Automata over infinite objects} 

\keywords{Tree automata, parity automata, Mostowski index, Strahler number, attractor decomposition, universal trees} 

\acknowledgements{We are grateful to Marcin Jurdzi\'nski for insightful discussions about attractor decompositions at Dagtuhl Seminar 24231, and of course to Dagstuhl for enabling such discussions.}

\relatedversion{This is a full version of an article of the same name published at ICALP 2025}

\category{Track B: Automata, Logic, Semantics, and Theory of Programming}

\EventEditors{Keren Censor-Hillel, Fabrizio Grandoni, Joel Ouaknine, and Gabriele Puppis}
\EventNoEds{4}
\EventLongTitle{52nd International Colloquium on Automata, Languages, and Programming (ICALP 2025)}
\EventShortTitle{ICALP 2025}
\EventAcronym{ICALP}
\EventYear{2025}
\EventDate{July 8--11, 2025}
\EventLocation{Aarhus, Denmark}
\EventLogo{}
\SeriesVolume{334}
\ArticleNo{159}
\begin{document}
	
	\maketitle
	
	\begin{abstract}
	The parity index problem of tree automata asks, given a regular tree language
$L$ and a set of priorities $J$, is $L$ $J$-feasible, that is, recognised by a nondeterministic parity automaton with priorities $J$? This is a long-standing open problem, of which only a few sub-cases
and variations are known to be decidable.
In a significant but technically difficult step, Colcombet and L\"oding reduced the problem to the uniform
universality of distance-parity automata.
In this article, we revisit the index problem using tools from the parity game literature.

We add some counters to Lehtinen's register game, originally used to solve parity games in quasipolynomial time,
and use this novel game to characterise $J$-feasibility. 
This provides a alternative proof to Colcombet and L\"oding's reduction.

We then provide a second characterisation, based on the notion of attractor decompositions and the complexity of their structure, as measured by a parameterised version of their Strahler number, which we call $n$-Strahler number. Finally, we rephrase this result using the notion of universal tree extended to automata: a guidable automaton recognises a $[1,2j]$-feasible language if and only if it admits a universal tree with $n$-Strahler number $j$, for some $n$.
In particular, a language recognised by a guidable automaton $\A$ is B\"uchi-feasible if and only if there is a uniform bound $n\in \NN$ such that all trees in the language admit an accepting run with an attractor decomposition of width bounded by $n$. Equivalently, the language is B\"uchi-feasible if and only if $\A$ admits a \textit{finite} universal tree.

While we do not solve the decidability of the index problem, our work makes the state-of-the-art more accessible and brings to light the deep relationships between the $J$-feasibility of a language and attractor decompositions, universal trees and Lehtinen's register game.  

	\end{abstract}
\section{Introduction}



Finite-state "automata" running on infinite structures are fundamental to the theory of verification and synthesis, where they model non-terminating systems. 
The complexity of an "automaton" is measured not only by the size of its state-space, but  also by the complexity of the acceptance condition. For instance, while the membership and non-emptiness questions for B\"uchi and coB\"uchi tree automata are in \ptime, for parity automata they are fixed-parameter tractable in the number of priorities in the parity condition, called its index~\cite{Calude2017DecidingPG}. In the modal $\mu$-calculus, the logic corresponding to parity tree automata, the alternation depth of a formula -- that is, the nesting depth of alternating least and greatest fixpoints -- coincides with the index of the corresponding parity automaton.

While for nondeterministic automata over infinite words, the B\"uchi acceptance condition suffices to recognise all $\omega$-regular languages~\cite{Rabin1968DecidabilityOS}, the classes of languages recognised by parity tree automata of each index form an infinite hierarchy, often called the parity, Mostowski, or Rabin-Mostowski index hierarchy. In other words, no fixed parity index suffices to recognise all $\omega$-regular tree languages, and this is the case for both nondeterministic~\cite{Niwinski1986OnFC}, and alternating~\cite{Bra98, Len96} tree automata.
A language is said to be $J$-feasible if it is recognised by a nondeterministic parity automaton of index $J$.
The nondeterministic index of an $\omega$-regular tree language is the minimal index $J$ for which it is $J$-feasible. The decidability of the index of a language is one of the major open problems in automata theory.

In the case of infinite words, the \textit{deterministic} index of a language is decidable in \ptime~\cite{Niwinski1998RelatingHO}. In the case of infinite trees, however, not much is known. For languages given by deterministic parity automata, deciding their nondeterministic index is decidable~\cite{NW05}. Similarly, deciding if a language is recognisable with a safety/reachibility condition can be done in EXPTIME \cite{Walukiewicz2002DecidingLL}. CoB\"uchi-feasibility, as well as the  weak feasability of B\"uchi languages, are also decidable~\cite{Colcombet2013DecidingTW,SW16}. For the restricted class of game automata (which can be seen as the closure of deterministic automata under complementation and composition), the nondeterministic and alternating index problems are decidable~\cite{GameAutomata}. The most recent advance on the topic is that the \textit{guidable} index of a language is decidable~\cite{NS21}, where "guidable" automata, introduced by Colcombet and L\"oding~\cite{Guidable}, restrict the nondeterminism of the automaton without the loss of expressivity imposed by determinism. 



The general nondeterministic index problem remains wide open. However, in a significant step, in 2008, Colcombet and Löding~\cite{Guidable} reduced the index problem of a tree language to the uniform universality of distance-parity automata. 
This remarkable result is, however, quite technical. In this article we present a similar result, (from which Colcombet and Löding's result can be obtained as a corollary, see~\cref{rmk:colcombet-loding}), using variations of known tools from the parity game literature -- namely, attractor decompositions, universal trees, the register index of parity games, and Strahler numbers. These are all notions that (re-)emerged in the aftermath of Calude et al.'s first quasipolynomial algorithm for solving parity games~\cite{Calude2017DecidingPG} to provide clarity on the newly established complexity bound. Here, we demonstrate that these tools also provide insight into the index hierarchy by using them to reformulate Colcombet and Löding's result and give an alternative proof.

Let us discuss each of these notions in more detail, in order to state our results.\\




\subparagraph*{The register index of parity games and $J$-feasibility.} Parity games are infinite two-player games in which two players, Adam and Eve, take turns moving a token along the edges of a graph labelled with integer priorities. Eve's goal is to ensure that the infinite path taken by the token satisfies the parity condition, that is, that the highest priority occuring infinitely often along the path is even. The acceptance of a tree by a parity tree automaton is determined by whether Eve wins a parity game based on the input tree and the automaton. 

In this article, we use the data-structure introduced in Lehtinen's quasipolynomial parity game algorithm~\cite{RegisterGames}. Lehtinen reduces solving a parity game to solving a new game, in which Eve must map the original game's priorities into a smaller priority range using a purpose-built data-structure, while guaranteeing that the sequence of outputs in this smaller range still satisfies the parity condition. Lehtinen shows that for a parity game of size $n$, Eve wins if and only if she also wins this new game with output range $O(\log n)$, which can be solved in quasipolynomial time.

Here we extend this game to the acceptance parity games of nondeterministic parity tree automata, that is, parity games with  unbounded or even infinite arenas. We furthermore add some counters (inspired by the Colcombet and L\"oding construction), which give  Eve some additional (but bounded) leeway in her mapping. We obtain a game that we call the parity transduction game $\Reg{J}{n}(G)$, played over a parity game $G$, parameterised by the output priority range $J$ , and the bound $n$ on the counters.

Our first contribution is showing that the $J$-feasibility of the language of a guidable automaton $\A$ (and we can always make the input guidable) is characterised by the existence of an integer $n$ such that the parity transduction game with parameters $J$ and $n$ coincides with the acceptance game of $\A$, written $\AGame{\A}{t}$ for an input tree $t$. In other words, a language is $J$-feasible whenever there is a uniform parameter $n$, such that whenever Eve wins the acceptance game $\AGame{\A}{t}$, she also wins the transduction game over it, with output range $J$ and parameter $n$.

\begin{restatable}{theorem}{thmfeasibilitygame}\label{thm:feasible-register}
Given a "guidable automaton" $\A$, $J$ an "index", the following are equivalent:
\begin{itemize}
\item $\Lang(\A)$ is $J$-"feasible".
\item There exists $n\in \NN$ such that for all $\Sigma$-tree $t$, $t\in \Lang(A)$ if and only if Eve wins $\Reg{J}{n}(\AGame{\A}{t})$.
\end{itemize}

\end{restatable}
 
 This corresponds to our version of the Colcombet-L\"oding reduction.
 We then proceed to reinterpret this characterisation in terms of \textit{attractor decompositions} and \textit{universal trees}.\\

\subparagraph*{Attractor decompositions}
describe the structure of Eve's winning strategies in a parity game, or, equivalently, of accepting runs of a parity tree automaton.
While this notion appears at least implicitly in many seminal works, e.g. Zielonka's algorithm for parity games \cite{Zielonka1998InfiniteGO}, Kupferman and Vardi's automata transformations~\cite{KV98} and Klarlund's~\cite{Klarlund1991ProgressMF} proof of Rabin's complementation theorem, 
it has more recently been explicitly studied  for mean payoff parity games~\cite{Daviaud_2018} and  parity games \cite{Attractor_decomposition_next,jurdzinski2022universalalgorithmsparitygames}.

While similar in spirit and structure to progress-measures~\cite{Jurdzinski2017SuccinctPM}, which count the number of odd priorities that might occur before a higher priority, attractor decompositions are more suitable for parity games on infinite arenas, where Eve might see an unbounded number of odd priorities in a row, as long as she is advancing in the attractor of some larger even priority. While progress measures, bounded by the size of a finite game, can be seen as a way to reduce parity games to \textit{safety} games, here we use attractor decompositions with bounded structure to reduce the priority range of the parity condition.
Like progress-measures, attractor decompositions have a tree-like structure, where the play only moves to the right if a suitably high even priorities occurs. The structure of these trees turns out to be closely tied to the index of a language.\\


\subparagraph*{{$n$-Strahler number}}
The Strahler number of a tree $t$ consists in the largest $h$ such that $t$ admits a complete binary tree of height $h$ as a minor.
Daviaud, Jurdzi\'nski and Thejaswini \cite{StrahlerNumber} proved an equivalence between the output range that Eve needs in Lehtinen's  game, called the game's register index, and the Strahler-number of the attractor decompositions of Eve's strategies.
Inspired by this, we define, for $n\in \NN$, the $n$-Strahler number of a tree $t$, that consists in the largest $h$ such that $t$ admits a complete $(n+1)$-ary tree of height $h$ as a minor (by subtree deletion and single-child contraction; we do not allow edge contraction in the presence of siblings). The Strahler number corresponds to our $1$-Strahler number.
 Our second characterisation of the index of a languages is based on the $n$-Strahler number of attractor decompositions.

\begin{restatable}{theorem}{thmparityattractors}\label{cl:parity-attractors}
Given a "guidable" "nondeterministic parity tree automaton" $\A$, the following are equivalent:
\begin{itemize}
\item $L(\A)$ is $[1,2j]$-"feasible".
\item There is an $n\in \NN$ such that for all $t\in L(\A)$ there exists a "run" of $\A$ on $t$ with an "attractor decomposition" of "$n$-Strahler number" at most $j$.
\end{itemize}

\end{restatable}

In particular, B\"uchi feasibility coincides with the existence of a uniform bound on the width (i.e branching degree) of attractor decompositions needed by Eve.
Finally, we restate this result in terms of \textit{universal trees}, extended to automata, as follows.\\

\subparagraph*{{Universal trees}}
Given a set $\T$ of ordered trees of bounded depth, a tree $U$ is said to be universal for $\T$ if all $t\in \T$ can be obtained from $U$ by removing subtrees. We then say that $t$ is isomorphically embedded in $U$. 
This elegant notion emerged in the analysis of quasi-polynomial time parity game algorithms, as a unifying combinatorial structure that can be extracted from the different algorithms \cite{Czerwinski2018UniversalTG}.

We say that an ordered tree $U$ is universal \textit{for an automaton $\A$} if for all regular trees in the language of $\A$, there exists an accepting run with an attractor decomposition (seen as a tree) that can be isomorphically embedded in $U$.

 Then, the  $[1,2j]$-feasibility of the language of a guidable automaton $\A$ is characterised by the existence of an  ordered tree  universal for $\A$ of $n$-Strahler $j$, for some $n\in \NN$. B\"uchi-feasibility is equivalent to the existence of a \textit{finite} universal tree for $\A$.



\begin{restatable}{theorem}{thmuniversaltrees}\label{cl:universal-trees}
Given a "guidable" "nondeterministic parity tree automaton" $\A$, the following are equivalent:
\begin{itemize}
\item $L(\A)$ is $[1,2j]$-"feasible".
\item There exists an $n\in \NN$ and a tree $\U$ of "$n$-Strahler number" at most $j$  that is "universal@@automaton-univ" for $\A$.
\end{itemize}

\end{restatable}

\vspace{5mm}


While our work does not give us the decidability of the index problem, it provides new tools for tackling it and makes the state-of-the-art more accessible by relating it to other familiar concepts. We hope that the deep link between the index of a language and the structure of attractor decompositions will be helpful for future work. The remarkably simple characterisation of B\"uchi feasible languages, as those with attractor decompositions of bounded width, or, equivalently a finite universal tree, is particularly encouraging, as deciding B\"uchi-feasibillity is the next challenge for advancing on the index problem.


\ificalp
A full version of this article, with all the missing proofs, can be found on Arxiv \cite{fullversion}.
\fi
 	
\section{Preliminaries}\label{sec:definitions}




The set of natural numbers $\{0, 1, \dots\}$ is denoted $\NN$, the set of strictly positive numbers is denoted $\NN^+$. The disjoint union of two sets $A$ and $B$ is denoted $A \sqcup B$. 
An ""alphabet"" is a finite non-empty set $\Sigma$ of elements, called letters.
$\Sigma^*$ and $\Sigma^\omega$ denote the sets ot finite and infinite ""words"" over $\Sigma$, respectively.
For $u$ a (possibly infinite) "word" and $n\in \NN$, the "word" $u|_{n}$ consists of the first $n$ letters of $u$. For $u$ and $v$ finite "words", $u \intro*\concat v$ denotes the concatenation of $u$ and $v$.
The length of a finite "word" $u$ is written $|u|$.

\AP An ""index"" $[i,j]$ is a non-empty finite range of natural numbers $I = \{i, i+1,\dots, j\} \subseteq \NN$.
Elements $c \in I$ are called ""priorities"". We say that an infinite sequence of "priorities" $(c_n)_{n\in \NN}$ is ""parity accepting"" (or simply \reintro*accepting) if $\limsup_{n \to \infty} c_n \equiv 0 \mod 2$, else it is "parity rejecting" (or "rejecting").


\subsection{Parity games}
\AP For $I$ an "index", $(V,E)$ a graph with $V$ a countable set of vertices and $L:E\to I$ an edge labeling, we call $G = (V,E,L)$ a ""$I$-graph"", or a "parity graph". We work with graphs in which every vertex has at least one successor. 
A graph (or tree) is said ""finitely branching"" if all its vertices have a finite number of exiting edges.

A graph is said ""even"" if all its infinite paths are "parity accepting".
For $G=(V,E,L)$ a "parity graph" and $V' \subseteq V$, the graph $G \intro*\restrict V'$ is the subgraph restricted to the vertices in $V'$. Similarly, for $E' \subseteq E$, the graph $G \setminus E'$ corresponds to $(V,E\setminus E', L')$ with $L'$ the restriction of $L$ to $E\setminus E'$.

\AP Let $G = (V,E,L)$ a "parity graph", and $E' \subseteq E$. The ""attractor"" of $E'$ in $G$ is the set
$\intro*\attr(E',G) := \{v\in V|\forall \text{ infinite path } \rho \text{ from } v \text { in }G,\ \rho \text{ has an edge in } E'\}$. Similarly, if $V' \subseteq V$, we define its "attractor" as the set $\attr(V',G)$ of vertices from which all infinite paths eventually pass by $V'$. Note that $V' \subseteq \attr(V',G)$.

\AP A ""parity game"" played by players Eve and Adam consists in a "parity graph" $\G = (V,E,L)$ with a partition of $V$ in two sets: $V = V_E \sqcup V_A$, controlled respectively by Eve and Adam. A ""play"" of $\G$ starting in $v\in V$ consists in an infinite sequence of edges $\rho := (e_i)_{i\in \NN}$ forming an infinite path starting in $v$. 
A "play" $(e_i)_{i\in \NN}$ is ""winning"" for Eve (or simply "winning") if $(L(e_i))_{i\in \NN}$ is "parity accepting", else it is said to be "losing" (for Eve, and "winning" for Adam).

\AP A ""strategy"" for Eve consists of a function $\sigma : E^* \to E$ such that, for all play $\rho$, for all $n \in \NN$, if $\rho_{|n}$ ends in a vertex $v \in V_E$, $\sigma(\rho_{|n})$ is an edge from $v$. A "play" $\rho$ is said to be ""consistent with"" the strategy $\sigma$ if for all $n$, $\rho_{|n}$ ending in a vertex of $V_E$ implies that $\rho_{|n+1} = \rho_{|n}\sigma(\rho_{|n})$. 
We say that a Eve "strategy" $\sigma$ is ""winning@winning strategy"" from vertex $v\in V$ if all plays "consistent with" $\sigma$ starting in $v$ are "winning". We similarly define "strategies" for Adam, winning when all plays "consistent with" them are "winning" for Adam.

\AP Parity games enjoy positional ""determinacy"": one of the players always wins with a strategy that only depends on the current position~\cite{EJ91}.

A "strategy" for Eve in a game $\G = (V_E\sqcup V_A,E,L)$ induces an Adam-only "game" $\G'$ played on the unfolding of $\G$, from which are removed all the edges that Eve does not choose. This game can be seen as a "parity graph", as the partition of the vertex set is now a trivial one, and it is "even" if and only if Eve's strategy is winning.

\subsection{Attractor decomposition}

An "attractor decomposition" of an "even" "parity graph" $G$ is a recursive partitionning of $G$. The intuition is that it identifies subgames of $G$ in which the top priorities $h$ (even) and $h-1$ (odd) do not occur and orders them so that a path must always eventually either stay within a subgame (and never see $h-1$ again), advance in the order (potentially seeing $h-1$ finitely many times in between by advancing through the attractor of a subgame), or see the higher even priority $h$. Each subgame is then decomposed recursively, with respect to the priority $h-2$. As the number of subgames is countable, such a decomposition witnesses that the "parity graph" is indeed "even".
An "attractor decomposition" has a tree-like structure, induced by the order on the subgames (which corresponds to the order of sibling nodes), and their sub-decompositions.

\AP Given a "parity graph" $G=(V,E,L)$ with maximal priority at most some even $h$, and $\kappa$ an ordinal, a ($h$-""level"", $\kappa$-""width"")-""attractor decomposition"" of $G$, if it exists, is recursively defined to be $D=(H,A_0,\{(S_i,A_i,D_i)\}_{0<i<\ell})$ where:
\begin{itemize}
	\item $\ell\leq \kappa$,
	\item $H\subseteq E$ is the set of edges in $G$ of priority $h$,
	\item $A_0= \attr(H,G)$,
	\item For every $0<i<\ell$, let $V_i=V\setminus \bigcup_{j< i}A_j$ and $G_i=(G\setminus H)\restrict V_i$. Then:
	\begin{itemize}
		\item $S_i\subseteq V_i$  is non-empty, such that $(G\setminus H)\restrict S_i$ only contains edges with priorities up to $h{-}2$, has no terminal vertices and is closed under successors in $G_i$,
		\item $A_i$ is  $\attr(S_i,G_i)$,
		\item $D_i$ is a ($(h{-}2)$-"level", $\kappa$-"width")-"attractor decomposition" of $(G\setminus H) \restrict S_i$,
	\end{itemize}
	\item $V=\bigcup_{i<\ell} A_i$,
	\item A ($0$-height, $\kappa$-"width")- and a ($h$-"level", $0$-"width")-"attractor decomposition" is just $(H,V)$: the entire graph is in the attractor of the edges of highest priority.
\end{itemize}


\begin{restatable}{lemma}{lemADreachability}\label{cl:ADreachability}	
	Given a "parity graph" $G$ that admits an "attractor decomposition"\\
	$(H, A_0,\{(S_i,A_i,D_i)\}_{0<i < \kappa})$, the set $A_j$ is unreachable from $A_i$ in $G\restrict \bigcup_{0<\ell < \kappa} A_{\ell}$ for all $i$ and $j$ such that $0<i<j < \kappa$.
\end{restatable}

\begin{proof}\textcolor{red}{TOPROVE 0}\end{proof}


\begin{restatable}{lemma}{evenIffDecomposition}\label{cl:EvenIffDecomposition}
	
	A "parity graph" is "even" if and only if it admits an "attractor decomposition".
	
	
\end{restatable}

\begin{proof}\textcolor{red}{TOPROVE 1}\end{proof}





\subsection{$\Sigma$-trees and automata}
\AP A ""$\Sigma$-tree"" (or just \reintro*{tree}) is a function $t : \{0,1\}^* \to \Sigma$. The set of all $\Sigma$-trees is denoted ${\Tr {\Sigma}}$. A tree is ""regular"" if it is finitely representable, that is, if it is the unfolding of a rooted graph. We denote $\intro*\RgS_\Sigma$ the set of "regular" trees of $\Tr{\Sigma}$.

\AP An infinite word $b \in \{0,1\}^\omega$ is called a ""branch"".
Given a  "tree" $t\in \Tr\Sigma$, a ""path@@tree-p"" $p$ (along a "branch" $b$) is a sequence $(p_i)_{i \in \NN} := (t(b_{|i}))_{i\in \NN}$.

\AP A ""nondeterministic $I$-parity tree automaton"" (also called $I$-automaton, or "automaton" of "index" $I$) is
a tuple $A = (\Sigma, Q_A , q_{i,A}, \Delta_A, \Omega_A )$, where $\Sigma$ is an alphabet, $Q_A$ a finite set of ""states"", $q_{i,A} \in Q_A$ an initial "state", $\Delta_A \subseteq Q_A \times \Sigma \times Q_A \times Q_A$ a transition relation; and $\Omega_A : \Delta_A \to I^2$ a "priority" mapping over the edges. 
A ""transition"" $(q, a, q_0 , q_1) \in \Delta_A$, is said to be from the "state" $q$ and over the letter $a$. By default, all "automata" in consideration are complete, that is, for each state $q \in Q_A$ and letter $a\in \Sigma$, there is at least one transition from $q$ over $a$ in $\Delta_A$.
When an automaton A is known from the context, we skip the subscript and write just $Q,\Delta$, etc.

\AP For $q,q' \in Q$, a ""path@@automaton-p"" from $q$ to $q'$ is  a finite "transition" sequence $(q_j, a_j, q_{j,0}, q_{j,1})_{j< N} \in \Delta^N$ such that $q = q_0$, and $\forall j < N, q_{j+1}\in \{q_{j,0}, q_{j,1}\}$ with $q_{j+1} = q'$.

\AP A tree is said to be "accepted" by an "automaton" $A$ if Eve wins a game defined by the product of this tree and the automaton, in which Eve chooses the transitions in $A$ and Adam chooses the direction in $t$. More formally, given a tree $t \in \Tr\Sigma$, and an $I$-"automaton" $A$, the ""acceptance game"" of $A$ on $t$, also denoted $\intro*\AGame{A}{t}$, is the "parity game" obtained by taking the product of $A$ and $t$. Its arena consists in $\{0,1\}^*\times (Q_A \cup \Delta_A)$, where all the positions of the shape $\{0,1\}^*\times Q_A$ are controlled by Eve, and the others by Adam. 
\begin{itemize}
	\item When in a position $(w,q) \in \{0,1\}^* \times Q_A$, Eve chooses a transition $e\in \Delta_A$ of the shape $(q,t(w),q_0,q_1)$, and the play proceeds to the state $(w,e)$. All these transitions have for label the minimal priority in $I$.
	\item Let $q\in Q_A$ and $e=(q,a,q_0,q_1) \in \Delta_A$. In a position $(w,e)$, Adam chooses either $0$ or $1$, and the games then moves towards either $(w\concat 0, q_0)$ or $(w\concat 1, q_1)$. For $\Omega_A(e) = (i_0,i_1)$, these transitions have priorities $i_0$ and $i_1$, respectively.
\end{itemize}
\AP We say that $t$ is ""accepted@@tree"" by $A$ if Eve wins $\AGame{A}{t}$. The set of "trees" "accepted" by $A$ is called the ""language"" of $A$ and is denoted $\intro*\Lang(A)$. We say that $\A$ ""recognizes"" $\Lang(A)$.

\AP If we fix a "strategy" for Eve, the "acceptance game" becomes an Adam-only game, called a ""run"" of $A$ on $t$. We observe that it is played on a "parity graph" in the shape of a binary tree. We thus observe that a "run" can be considered as a tree in $\Tr{\Delta_A}$. This "run" is won by Adam if and only if there exists a "parity rejecting" "branch". In this case, it called a ""rejecting run"", else it is an "accepting run".

If $A$ is an "$I$-automaton", such a "run" over $t$ induces an $I$-labelling of $t$, which, for convenience, we consider to be on edges.



\AP A set of trees $L \subseteq \Tr{\Sigma}$ is an ""$\omega$-regular tree language"" if it is of the form $\Lang(A)$ for some "automaton" $A$. It is said  to be ""$I$-feasible"" if furthermore $A$ is of "index" $I$.

\subsection{Guidable automata}

The notion of a "guidable automata" was first introduced in \cite{Guidable}.
Intuitively, they are "automata" that fairly simulates all language equivalent "automata". "Guidable automata" are fully expressive \cite[Theorem 1]{Guidable} and are more manageable than general nondeterministic automata. 

\AP Fix two "automata" $A$ and $B$ over the same "alphabet" $\Sigma$. A ""guiding function""
from $B$ to $A$ is a function $g : Q_A \times \Delta_B \to \Delta_A$ such that $g(p, (q, a, q_0 , q_1 )) = (p, a, p_0 , p_1)$
for some $p_0, p_1 \in Q_A$ (i.e. the function g is compatible with the "state" $p$ and the letter $a$). 

If $\rho \in Tr_{\Delta_B}$ is a "run" of $B$ over a "tree" $t \in \Tr\Sigma$ then we define the "run" $g (\rho) \in Tr_{\Delta_A}$ as follows. We define inductively $q : \{0,1\}^* \to Q_A$ in the following fashion: $q(\varepsilon) = q_{i,A}$, and supposing $q(u)$ to be defined, for $g(q(w),\rho(w))=(q(w),t(w),q_0,q_1)$, we let $q(u\concat 0),q(u\concat 1)$ to be respectively $q_0,q_1$. We can then define the run $g (\rho) \in \Tr{\Delta_A}$ as 
$$g(\rho): u \mapsto g(q(u),\rho(u)).$$
Notice that directly by the definition, the "tree" $g(\rho)$ is a "run" of $A$ over $t$. 

\AP We say that a "guiding function" $g : Q_A \times \Delta_B \to \Delta_A$ ""preserves acceptance"" if whenever $\rho$ is an "accepting run" of $B$ then $g(\rho)$ is an "accepting run" of $A$. We say that an "automaton" $B$ ""guides"" an "automaton" $A$ if there exists a "guiding function" $g : Q_A \times \Delta_B \to \Delta_A$ which "preserves acceptance". In particular, it implies that $\Lang(B) \subseteq \Lang(A)$.

\AP An "automaton" $A$ is ""guidable"" if it can be "guided by" any "automaton" $B$ such that $L(B) = L(A)$
(in fact one can equivalently require that $L(B) \subseteq L(A)$, see \cite[Remark 4.5]{lodingHDR}).
We will use the following fundamental theorem, stating that "guidable automata" are as expressive as "non-deterministic ones@automata".

\begin{theorem}[{\cite[Theorem 1]{Guidable}}]
	For every regular tree language $L$, there exists a guidable automaton recognizing $L$. Moreover, such an automaton can be effectively constructed from any non-deterministic automaton for $L$.
\end{theorem}




 
 \subsection{Ordered trees}

 \AP We define inductively ""ordered trees"" of finite "depth". 
 They are either the ""leaf"" tree $\langle \rangle$ of "depth" $\intro*\d(\langle\rangle) = 1$, or a tree $T = \langle (T_k)_{k\in K} \rangle$ 
 where $\forall k, T_k$ is an ordered tree of finite "depth", and $K$ is a well-ordered countable set. 
 The ""children"", ""siblings"" and ""subtree"" relation $\intro*\subt$ are defined in the usual way.
 We denote $\prec$ the order relation between the "siblings" of a tree $\langle (T_k)_{k\in K} \rangle$. That is, for $k,k' \in K$, we have $T_k \prec T_{k'}$ when $k < k'$ for $<$ the well-order of $K$.  By abuse of notation, we say that $T_1 \prec T_2$ if $T_1\subt T'_1, T_2 \subt T'_2$ and $T'_1 \prec T'_2$.
 
 \AP From their definitions, it is clear that "attractor decompositions" are tree-shaped. To make this explicit, the ""tree-shape"" of an "attractor decomposition" $D= (H,A_0,\{(S_i,A_i,D_i)\}_{0<i<\kappa})$ is defined inductively as $\langle\rangle$ if $\kappa= 0$, else, defining $(T_i)_{0<i<\kappa}$ the "tree-shapes" of the $(D_i)_{0<i<\kappa}$, $D$ has "tree-shape" $\langle (T_i)_{0<i<\kappa}\rangle$.
 Observe that the "width" of an "attractor decomposition" corresponds to an upper-bound on the branching degree of its "tree-shape".
 
 \AP We extend the notion of "tree-shape" to "runs": a run has "tree-shape" $t$ if it has an "attractor decomposition" of "tree-shape" $t$.
 
\AP We say that an "ordered tree" $T = \langle (T_i)_{i\in I}\rangle$ is ""isomorphically embedded"" in a tree $T' = \langle (T'_j)_{j\in J}\rangle$ if either $I$ is empty, or of there exists $\phi: I \to J$, strictly increasing, such that $\forall i \in I$, $T_i$ is "isomorphically embedded" in $T'_{\phi(i)}$.
Intuitively, this implies the existence of a map from the "subtrees" of $T$ to the "subtrees" of $T'$, where the root of $T$ is mapped onto the root of $T'$, and the children of every node must be mapped injectively and in an order-preserving way onto the children of its image.

\AP Let $\T$ be a set of "ordered trees". We say that a tree $U$ is ""universal for $\T$"" if all the trees of $\T$ can be "isomorphically embedded" in $U$. 

\section{Game characterisation of the parity index}\label{sec:register-game}


In this section we define "priority transduction games", based on the register games from Lehtinen's algorithm  in~\cite{RegisterGames}, augmented with some counters. We characterise the "$J$-feasibility" of a "language" $\Lang(A)$, where $A$ is a "guidable automaton", by the existence of a uniform bound $n\in \NN$ such that a "tree" is in $\Lang(A)$ if and only Eve wins the $J$-"priority transduction game" on $\AGame{A}{t}$, with counters bounded by $n$.

The idea of these "priority transduction games" is that in addition to playing the "acceptance game" of an $I$-automaton $\A$ over a tree $t$, which has priorities in $I$, Eve must map these priorities on-the-fly into the "index" $J$. In the original games from~\cite{RegisterGames}, she does so by choosing at each turn a register among roughly $\frac{\lvert J \rvert }{2}$ registers. Each register stores the highest priority seen since the last time it was chosen. Then, the output is a priority in $J$ which depends on both the register chosen and the parity of the value stored in it. 
Here, the mechanism is similar, except that we additionally have counters that allow Eve to delay outputting odd priorities a bounded number of times.

Intuitively, the registers, which store the highest priority seen since the last time they were chosen, determine the magnitude of the output, while their content's parity decides the output's parity.
This allows Eve to strategically pick registers so that odd priorities get eclipsed by higher even priorities occuring soon after. However, a large odd priority occuring infinitely often will force Eve to produce odd outputs infinitely often.
The counters give Eve some error margin, whereby she can pick a register containing an odd value \textit{without} outputting an odd priority, up to $n$ times in a row. 

\AP Formally, for $J$ a priority "index" (of minimal value assumed to be $1$ or $2$ for convenience), $n \in \NN$, the ""$J,n$-priority transduction game"" is a game played by Eve and Adam, over an $I$-"parity graph" $G=(V,E,L)$ for $I$ an "index". It has two parameters, $J$ the output "index" and $n$ the bound of its "counters", and is denoted $\intro*{\Reg{J}{n}}(G)$. A configuration of the game corresponds to a position $p\in V$, a value in $I$ for each \reintro*"register" $r_j$ for even $2j\in J$ (if $1 \in J$, there is an additionnal "register" $r_0$), and a value between $0$ and $n$ for each \reintro*"counters" $c_{i,j}$ with $i$ odd $\in I, j$ such that $r_j$ is a "register".\\
Starting from some initial vertex $p_0\in V$ with "counters" set to $0$ and "registers" set to the maximal even priority in $I$, the game proceeds as follows at step $l$ :
\begin{itemize}
	\item Adam chooses an exiting edge $e = (p,p')\in E$ ; the position becomes $p'$.
	\item Eve chooses a "register" $r_j$.
	\item The game produces the output $w_l$ :
		\begin{itemize}
		\item if $j = 0$, $w_l=1$ (recall that $r_0$ is a "register" iff $1 \in J$). Else,
		\item if $r_j$ is even, $w_l=2j$.
		\item Else, if $c_{r_j,j} = n$, it is said to reach $n+1$ before being reset: $w_l=2j+1$ and $c_{r_j,j} := 0$. If $2j+1 \notin J$, Eve loses instantly.
		\item else, $w_l = 2j$ and $c_{r_j,j} := c_{r_j,j} +1$
		\end{itemize}
	\item If $L(e)$ is even, let $i:= L(e)$ be the label of the current edge, else Eve chooses an odd $i$ such that $L(e)\leq i$ (choice $\sharp$\label{sharp}). 
	Then the following updates occur : 
	\begin{itemize}
		\item Smaller "counters" are reset : $\forall i' < i, c_{i',j} := 0$ and $ \forall j'<j, c_{r_j,j'} := 0$,
		\item "Registers" get updated : $r_j := i$ and $\forall j' > j$, $ r_{j'} := \max(i, r_{j'}) $, 
	\end{itemize} 
\end{itemize}
Eve wins if the infinite sequence of outputs $(w_l)_{l\in \NN}$ is "parity accepting", else Adam wins.\\

In order to explain two aspects of this game that were not covered in the initial intuition: the minimal "register" $r_0$ allows Eve to wait, for a finite but unbounded time, for better priorities to override the register contents. It thus corresponds to outputting a minimal odd priority.
The choice $\sharp$ allows her to break a sequence dominated by many identical odd priorities $i$ in a sequence with some greater odd $i'$ in between, resetting the "counters" albeit at the cost of witnessing a greater odd priority.\footnote{This is a technical adjustement that is convenient in the proof of~\cref{lem:Strahler-to-Reg}}

Let $\G$ be a "parity game" of "index" $I$, $n\in \NN$, $J$ an "index". We define the game $\Reg{J}{n}(\G)$ as the game $\Reg{J}{n}$ where, instead of following a path of "parity graph" chosen by Adam, it follows an ongoing play of $\G$ where the player owning the current position $q$ chooses its move in $\G$ at each step, before Eve chooses her "register". It corresponds to the composition of $\Reg{J}{n}$ with the game $\G$. If we fix a strategy $\sigma$ for Eve in $\G$, we observe that $\Reg{J}{n}(\G)$ corresponds exactly to the "priority transduction game" $\Reg{J}{n}$ over the Adam-only game $\G_\sigma$ induced by $\sigma$ in $\G$, and that Eve wins $\Reg{J}{n}(\G)$ if and only if she wins $\Reg{J}{n}(\G_\sigma)$.

Note that $\Reg{J}{n}(\G)$ is a parity game, and therefore "determined".

We show that this transduction game characterises the "index" of a "regular tree language".


\thmfeasibilitygame*



For the upward implication, it suffices to observe that the transduction game is captured by a finite state $J$-automaton describing the register contents and counter values (bounded by $n$), with nondeterministic choices corresponding to Eve's choices, and a $J$-parity condition corresponding to the outputs. Then, the $J$-automaton equivalent to $A$ is the composition of $A$ with this $J$-automaton. 
\ificalp
The details, which are as one would expect, are in the full version.
\else
The details, which are as one would expect, are in the appendix.
\fi
\begin{restatable}{lemma}{automataComposition}\label{lem:automata-composition}
	Let $J$ be a priority "index" and let $A$ be a "guidable automaton" such that there exists $n\in \NN$ such that for all $\Sigma$-tree $t$, $t\in \Lang(A)$ if and only if Eve wins $\Reg{J}{n}(\AGame{A}{t})$. Then there exists an "automaton" of "index" $J$ such that $\Lang(B)=\Lang(A)$.
\end{restatable}

The rest of the section focuses on the downward implication of~\cref{thm:feasible-register}. We first show that Eve can only win $\Reg{J}{n}(G)$ for $G$ an "even" "parity graph", which implies that Eve loses $\Reg{J}{n}(\AGame{A}{t})$ for any $t\notin \Lang(A)$.



\begin{restatable}{lemma}{regRejectsRejecting}\label{lem:reg-rejects-rejecting}
	Let $G$ a "parity graph". If $G$ is not "even", then for all $J,n$, Adam wins $\Reg{J}{n}(G)$
\end{restatable}

\begin{proof}\textcolor{red}{TOPROVE 2}\end{proof}



Then, it remains to show that if the language of guidable $A$ is $J$-feasible, then for some $n\in \NN$ Eve wins $\Reg{J}{n}(\G(A,t))$ for all $t\in \Lang(A)$.
To do so, we first analyse the relation between guided and guiding runs, and show that the preservation of global acceptance implies a more local version that resctricts differences in the parity of the dominant priority over long segments of both runs. We will then use this to show that Eve can win the transduction game by using a run of $A$ guided by an accepting run of an equivalent $J$-automaton and choosing registers corresponding to the priorities of the guiding run.

The following lemma, obtained by a simple pumping argument 
\ificalp
(see full version)
\else
(see Appendix)
\fi
 expresses that between all pumpable pairs of states, that is, pairs of states that are not distinguished by either run, if the guiding run is dominated by en even priority, then so is the guided one. 

\begin{restatable}{lemma}{pumping}\label{cl:pump}
	Let $A,B$ be "automata", let $t\in \Tr{\Sigma}$, let $\rho_A, \rho_B$ be "accepting runs" over $t$ of $A$ and $B$, respectively, where $\rho_A$ is "guided by" $\rho_B$. We consider these "runs" as trees in $\Tr{\Delta_A},\Tr{\Delta_B}$ respectively. 
	Given $u,v \in \{0,1\}^*, \{0,1\}^+$ such that $\rho_A(u) = \rho_A(u\concat v)$, and such that $\rho_B(u) = \rho_B(u\concat v)$, if the greatest priority encountered between positions $u$ and $u \concat v$ in $\rho_B$ is even, so is the greatest priority encountered in this segment in $\rho_A$.
\end{restatable}


\AP We now capture this relation with the notion of a labelling being $n$-bounded by the other. Let $L_I: E\rightarrow I$ and $L_J:E\rightarrow J$ be two labellings of a graph $G= (V,E)$ (or tree) and let $n \in \NN$. We say that $L_I$ is ""$n$-bound"" by $L_J$ if there is no finite path $\pi$ in $G$, segmented into consecutive paths $\pi_0,\pi_1,\dots \pi_n$ such that for some odd $i$ and some even $j$, the maximal priority on the $L_I$- and $L_J$-labels of each $\pi_m, m\in [0,n]$ are $i$ and $j$, respectively.

From~\cref{cl:pump} we obtain that the labelling induced by a guided run is $n$-bound by the one induced by its guide, with $n$ the product of the sizes of the two automata:

\begin{restatable}{lemma}{guidableNBound}\label{lem:guidable-n-bound}
	Let $A$ a guidable automaton. If $\Lang(A)$ is $J$-feasible witnessed by an "automaton" $B$, for $n := |A| |B|+1$, for all $\Sigma$-tree $t \in \Lang(A)$, for $\rho_A$ the "run" of $A$ on $t$ "guided by" an "accepting run" $\rho_B$ of $B$ over $t$, the labelling $L_A$ induced by $\rho_A$ is "$n$-bound" by the labelling $L_B$ induced by $\rho_B$.
\end{restatable}



We use "$n$-boundedness" to show that Eve can use a run $\rho_B$ of an equivalent $J$-"automaton" to choose her "registers" to win in $\Reg{J}{n+1}(\rho_A)$ for $\rho_A$ "accepting run" of $A$ guided by $\rho_B$.

\begin{lemma}\label{cl:bounded-to-strategy}
	Let $I,J$ be indices, $n \in \NN^+$, and $\rho_I:E\rightarrow I$ and $\rho_J:E\rightarrow J$ two "even" $I$- and $J$- labelling of the same graph $(E,V)$. If $\rho_I$ is "$n$-bound" by $\rho_J$, Eve wins $\Reg{J}{n+1}(\rho_I)$.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 3}\end{proof}

\cref{lem:reg-rejects-rejecting} implies that Eve loses $\Reg{J}{n+1}(\G(A,t))$ for $t\notin \Lang(A)$. If $\Lang(A)$ is $J$-feasible as witnessed by a $J$-automaton $B$, then for all $t\in \Lang(A)$, from~\cref{lem:guidable-n-bound}, Eve has a run $\rho_A$ that is $n$-bounded by an accepting run of $B$, which, from~\cref{cl:bounded-to-strategy}, implies that Eve wins $\Reg{J}{n+1}(\G(A,t))$, concluding the proof of~\cref{thm:feasible-register}.

\begin{remark}\label{rmk:colcombet-loding}
To obtain Colcombet and L\"oding's result from ours, it suffices to encode the transduction game as a distance-parity automaton that on an input tree $t$ computes a bound $n$ on the counters such that Eve wins  $\Reg{J}{n}(\G(A,t))$. Then, like in~\cite[Lemma 3]{Guidable}, there is a distance-parity automaton that is uniformly universal if and only if $A$ is $J$-feasible.
\end{remark}  


\knowledgenewcommand{\Sn}[2]{\cmdkl{\mathcal{S}_{#1}(#2)}}
\knowledgenewcommand{\Fo}{\cmdkl{\F}}
\knowledgenewcommand{\mapV}[1]{\cmdkl{\psi_{#1}}}
\knowledgenewcommand{\mapE}[1]{\cmdkl{\phi_{#1}}}



\section{Characterisation via attractor decompositions}\label{sec:strahler}

\subsection{Strahler number}

The Strahler number of a tree, given by the height of the largest full binary tree that appears as a minor, measures the arborescence of a tree. We generalise this notion.

\AP Let $n\in \NN$. The ""$n$-Strahler number"" of $T$ a tree of finite depth, denoted $\intro*\Sn{n}T$, is defined by recurrence:
\begin{itemize}
	\item if $T = \langle \rangle$, $\Sn n T=1$.
	\item Else, $T = \langle (T_k)_{k\in K}\rangle$. We consider $m := \max\{\Sn n {T_k}|k \in K\}$. If there are at least $n+1$ $T_k$'s of "$n$-Strahler number" $m$, $\Sn n T = m+1$. Else, $\Sn n T = m$.
\end{itemize}
The "$n$-Strahler number" of $T$ is at most its "depth". Having a "$n$-Strahler number" $k$ is equivalent to having a complete $n$-ary tree of detph $k$ as a minor, for the operations of child deletion and replacing a node by one of its "children".  \cref{fig:example-Strahler} gives an example.

\begin{figure}[!htb]
	\centering
	\begin{tikzcd}[sep=small]
		&&&&&& \bullet \\
		\\
		&& \bullet && \bullet && \bullet && \bullet && \bullet \\
		\\
		& \bullet & \bullet & \bullet & \bullet & \bullet & \bullet & \bullet & \bullet && \bullet && \bullet \\
		\\
		\bullet && \bullet & \bullet & \bullet & \bullet && \bullet & \bullet & \bullet & \bullet & \bullet & \bullet & \bullet
		\arrow[color={rgb,255:red,214;green,92;blue,92}, no head, from=1-7, to=3-3]
		\arrow[color={rgb,255:red,214;green,92;blue,92}, no head, from=1-7, to=3-5]
		\arrow[no head, from=1-7, to=3-7]
		\arrow[color={rgb,255:red,214;green,92;blue,92}, no head, from=1-7, to=3-9]
		\arrow[no head, from=1-7, to=3-11]
		\arrow[color={rgb,255:red,214;green,92;blue,92}, no head, from=3-3, to=5-2]
		\arrow[color={rgb,255:red,214;green,92;blue,92}, no head, from=3-3, to=5-3]
		\arrow[color={rgb,255:red,214;green,92;blue,92}, no head, from=3-3, to=5-4]
		\arrow[color={rgb,255:red,214;green,92;blue,92}, no head, from=3-5, to=5-5]
		\arrow[no head, from=3-7, to=5-6]
		\arrow[no head, from=3-7, to=5-7]
		\arrow[no head, from=3-9, to=5-8]
		\arrow[color={rgb,255:red,214;green,92;blue,92}, no head, from=3-9, to=5-9]
		\arrow[no head, from=3-11, to=5-11]
		\arrow[no head, from=3-11, to=5-13]
		\arrow[no head, from=5-2, to=7-1]
		\arrow[no head, from=5-3, to=7-3]
		\arrow[color={rgb,255:red,214;green,92;blue,92}, no head, from=5-5, to=7-4]
		\arrow[color={rgb,255:red,214;green,92;blue,92}, no head, from=5-5, to=7-5]
		\arrow[color={rgb,255:red,214;green,92;blue,92}, no head, from=5-5, to=7-6]
		\arrow[color={rgb,255:red,214;green,92;blue,92}, no head, from=5-9, to=7-8]
		\arrow[color={rgb,255:red,214;green,92;blue,92}, no head, from=5-9, to=7-9]
		\arrow[color={rgb,255:red,214;green,92;blue,92}, no head, from=5-9, to=7-10]
		\arrow[no head, from=5-11, to=7-11]
		\arrow[no head, from=5-11, to=7-12]
		\arrow[no head, from=5-13, to=7-13]
		\arrow[no head, from=5-13, to=7-14]
	\end{tikzcd}
	\caption{An "ordered tree" of depth 4, of 3-"Strahler number" 3, as exemplified by the red edges.}
	\label{fig:example-Strahler}
\end{figure}

\AP We say that a "parity game" $G$ has ""$n$-Strahler number@@game-Strahler"" $j$ if there exists a strategy $\sigma_G$, winning for Eve, such that the resulting "parity graph" admits an "attractor decomposition" of tree-shape whith "$n$-Strahler number" $j$.

In the next two sections we prove each direction of the following theorem, using~\cref{thm:feasible-register} for the upward implication.

\thmparityattractors*

\begin{remark}Note that this theorem, based on a range $[1,2j]$, is less precise than~\cref{thm:feasible-register}, which handles all ranges $J$. This is because the parity of the minimal and maximal priorities are not reflected in the tree-shape of the attractor decomposition. For example, if there is a uniform bound on the lengths of paths in attractors, then there is no need for a minimal odd priority. The maximal even priority on the other hand is not required if there are no edges that go from $A_i$ to $A_j$ with $j>i$.  While the extremal parities are hard to characterise from the attractor decompositions, they are neatly captured by the transduction game.
	\end{remark}

\subsubsection{From feasibility to attractor decompositions}

Let $A$ be a "guidable automaton" of index $I$. If $\Lang(A)$ is $[1,2j]$ feasible by some automaton $B$, by~\cref{lem:guidable-n-bound}, there exists $n\in \NN$ and a "run" $\rho_B$ "guiding" $A$ such that the resulting "run" $\rho_A$ is "$n$-bound" by $\rho_B$. From this, we exhibit an "attractor decomposition" of $G$ of "$n$-Strahler number" $j$. More precisely these "runs" over $\AGame{A}{t}$ and $\AGame{B}{t}$ are considered as an "$I$-tree" and a "$[1,2j]$-tree", respectively. We will use these two "trees" in order to exhibit an "attractor decomposition" of $\AGame{A}{t}$ of "$n$-Strahler number" $j$.

\begin{restatable}{proposition}{propRegToStrahler}\label{lem:Reg-to-Strahler}
Given a tree-shaped graph $G=(V,E)$, "finitely-branching" and without terminal vertices,
two indices $I=[0,2i]$ and  $J=[1,2j]$ and
labellings $\rho_I:E\rightarrow I$ and $\sigma_J: E\rightarrow J$
such that $(G,\rho_I)$ and $(G,\sigma_J)$ are "even" "parity graphs",
if $\rho_I$ is "$n$-bound" by $\sigma_J$, 
then $(G,\rho_I)$ admits an "attractor decomposition" of "$n$-Strahler number" at most $j$.
\end{restatable}

\begin{proof}\textcolor{red}{TOPROVE 4}\end{proof}


\subsubsection{From attractor decomposition to feasibility}

For the backward direction of~\cref{cl:parity-attractors}, we show that if Eve has a winning strategy in a game with a corresponding attractor decomposition of "$n$-Strahler number" $h$, then she can win the corresponding "priority transduction game" with $h$ registers and counters going up to $n$. Then, using~\cref{thm:feasible-register}, we obtain the required implication.

\begin{restatable}{proposition}{strahlerToReg}\label{lem:Strahler-to-Reg}
Given a game $G$ and $n\in \NN\setminus\{0\}$, if $G$ has "$n$-Strahler number@@game-Strahler" $h$, then Eve wins $\Reg{[1,2h]}{n+1}(G)$.
\end{restatable}

\begin{proof}\textcolor{red}{TOPROVE 5}\end{proof}


\begin{remark}
	 Eve also has a winning strategy in $\Reg{[1,2h]}{n}(G)$, but the proof is more elaborate, as we need to do a case analysis of the behaviour of the last counter incrementation.
\end{remark}

If  Eve has such an attractor decomposition over all the games $\AGame{A}{t}$ for $t\in \Lang(A)$, the corresponding $n$ is a uniform bound such that Eve wins all the $\Reg{[1,2j]}{n}$. From this, we conclude the proof of~\cref{cl:parity-attractors} using the upwards direction of~\cref{thm:feasible-register}.


\section{Characterisation via universal trees}\label{sec:universal}

We now show that the previous characterisations of "$J$-feasibility" of a "guidable automaton" $\A$ can be reformulated in terms of the existence of a "universal tree" for $\A$. Note that in this section we use both "trees", which are binary, infinite and inputs to automata, and "ordered trees", which are of potentially infinite branching but finite height and describe "attractor decompositions".

\AP We say that an "ordered tree" is ""universal for an automaton $\A$"" if it is "universal" for some set of "ordered trees" $T$ such that for all "regular trees" $t\in L(\A)$, Eve has a "strategy" in $\AGame{\A}{t}$ with an "attractor decomposition" of tree-shape in $T$.


\thmuniversaltrees*

To prove this theorem, we show that that for fixed $n,j,d\in \NN^+$, there is an infinite "ordered tree" $\U$ of "$n$-Strahler number" $j$ and "depth" $d$ that is "universal" for the set of finite "ordered trees" of $n$-Strahler number at most $j$ and "depth" at most $d$. Over regular "trees", because of the positionality of "parity games", Eve's strategies can be chosen to be regular, which implies that their "attractor decompositions" can be finite, making $U$ universal for guidable automata recognising a $[1,2j]$-feasible language. For the other direction, we recall that if two tree automata are equivalent over "regular trees", they are equivalent over all "trees"~\cite{RabinRegular}.\\


\AP Let $n,k,d\in \NN^+$. We define recursively the ""universal tree"" $\intro*\Ut{n,k,d}$
of "$n$-Strahler number" $k$ and "depth" $d$ as follows, where $\omega(T)$ denotes the repetition of $\omega$ times the "ordered tree" $T$:

\begin{itemize}
	\item $\Ut{n,1,1} := \langle \rangle$
	\item When $d<k$, $\Ut{n,k,d}$ is undefined.
	\item Else, $d\geq k$, and by denoting $U := \Ut{n,k-1,d-1}$, we have \\$U_{n,k,d} := \langle \omega(U), \Ut{n,k,d-1}, \omega(U), \dots, \Ut{n,k,d-1}, \omega(U)\rangle$, with $n$ repetitions of $\Ut{n,k,d-1}$ (or, if it is not defined, no such repetition). Similarly, if $U = \Ut{\alpha,n,k-1,d-1}$ is undefined due to $k$ being equal to $0$, these children are omitted.
\end{itemize}



\begin{figure}[!htb]
	\includegraphics[width=\textwidth]{universal-strahler.pdf}
	\caption{The recursion step in the construction of $\U_{\alpha,n,k,d}$.}
	\label{fig:univ-strahler}
\end{figure}

An example of such a construction can be found in figure \ref{fig:univ-strahler}.
Observe that $\Ut{n,k,d}$ has "width" greater than $\omega$ as soon as $2\leq k\leq d$.
Furthermore, $\forall n,k,d$, $\Ut{\alpha,n,k,d}$ has "depth" $d$, and we establish that it also has "$n$-Strahler number" exactly $k$:
\begin{lemma}
	For all $n,k,d\in \NN\setminus\{0\}$, if $k\leq d$, then $\Ut{n,k,d}$ is defined, and $\Sn{n} {\Ut{n,k,d}} = k$.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 6}\end{proof}

We can now prove its "universality":

\begin{lemma}\label{lem:Ut-universal}
Let $\T$ be a set of finite "ordered trees", all of "depth" bounded by $d$ and "$n$-Strahler number" at most $k$. Then $\Ut{n,\min(k,d),d}$ is "universal for $\T$".
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 7}\end{proof}

\begin{remark}\label{rem:regular-generalises}
As established by Rabin~\cite[Theorem 20]{RabinRegular}, a non-empty tree automaton accepts a regular tree, therefore, if two "automata" are equivalent in $\RgS_\Sigma$, they are equivalent over all "trees". This notably implies that, for $A$ an automaton and $J$ an index, $\Lang(A)$ is $J$-"feasible" over $\RgS_\Sigma$ if and only if it $J$-"feasible" over all "trees".
\end{remark}

\begin{lemma}
	Let $A$ a "guidable" "$I$-automaton", let $t$ a "regular tree" in $\Lang(A)$. If $\Lang(A)$ is $[1,2j^*]$-feasible, then there exists a finite "attractor decomposition" of $\AGame{A}{t}$ of "$n$-Strahler number" at most $j^*$.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 8}\end{proof}

We finally obtain the direct implication of~\cref{cl:universal-trees} from this lemma and \cref{lem:Ut-universal}.

For the converse direction, by~\cref{lem:Strahler-to-Reg}, Eve wins all the $\Reg{[1,2j]}{n+1}(\AGame{A}{t})$ for $t\in \Lang(A)\cap \RgS_\Sigma$. Conversely, for $t \in \Lang(A)^C \cap \RgS_\Sigma$, by~\cref{lem:reg-rejects-rejecting}, Eve looses. Therefore, by \cref{lem:automata-composition} (restricting ourselves to the "regular trees"), we can construct $B$ a $[1,2j]$-automaton recognizing $\Lang(A)\cap\RgS_\Sigma$ over the "regular trees". Therefore $\Lang(A)$ is $[1,2j]$-feasible over the "regular trees", and by~ \cref{rem:regular-generalises} is thus $[1,2j]$-feasible. 
\section{Conclusion}
We have given three closely related new characterisations of the "$J$-feasibility" of "$\omega$-regular tree languages": one via the "transduction game", one via "attractor decompositions" and one via "universal trees". While we do not solve the decidability of the index problem, our work brings to light the deep relationships between the tools we are used to manipulate in the context of solving "parity games", such as "attractor decompositions", "universal trees" and Lehtinen's register game, and the "$J$-feasibility" of a language.  In particular, the "$n$-Strahler number" turns out to have great explanatory power by relating the "transduction game", the structure of "attractor decompositions" and the "index" of a language. 

The B\"uchi case, which is at the frontier of the state of the art, is particularly appealing because of its simplicity: the language of a "guidable automaton" $\A$ is B\"uchi "feasible" if and only if there is a finite bound $n$ such that Eve can win in the acceptance games with strategies with "attractor decompositions" of width at most $n$, or, equivalently, if $\A$ admits a \textit{finite} "universal tree". We hope that these insights will help unlock the next steps in tackling this long-standing open problem. 
\bibliography{biblio}

\appendix

\section{Appendix}




\subsection{Proofs from~\cref{sec:register-game}}

\automataComposition*
\begin{proof}\textcolor{red}{TOPROVE 9}\end{proof}

\regRejectsRejecting*

\begin{proof}\textcolor{red}{TOPROVE 10}\end{proof}

\pumping*

\begin{proof}\textcolor{red}{TOPROVE 11}\end{proof}

\guidableNBound*

\begin{proof}\textcolor{red}{TOPROVE 12}\end{proof}


\subsection{Proofs from~\cref{sec:strahler}}
\subsubsection*{Proof of \cref{lem:Reg-to-Strahler}}\label{app:Reg-to-Strahler}


We begin with three technical lemmas: \cref{lem:attr-union} on the "attractor" of a union of disjoint sets, and \cref{lem:join-attr-decomp} that builds an "attractor decomposition" once all the subparts $S_k$ have been identified. The last one exhibits an "attractor decomposition" with more structure than usual, in our specific case where the underlying graph is a "tree".

\begin{lemma}\label{lem:attr-union}
	Let $\kappa$ be an ordinal, let $G=(V,E,L)$ a "finitely-branching" "parity graph", and $(S_k)_{k<\kappa}$, $\kappa$ disjoint subsets of $V^*$. Then, Then, by defining iteratively, for $k \leq \kappa$, $V_k:=V\setminus \bigcup_{j< k}A_j$ and $A_k := \attr(S_k,G\restrict V_k)$, we have that $\attr(\bigsqcup_{k<\kappa}S_k,G) = \bigsqcup_{k<\kappa} A_k$.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 13}\end{proof}


\begin{lemma}\label{lem:join-attr-decomp}
	Let $G = (V,E,L)$ a "finitely-branching" "parity game" of maximal even parity $h$. Let $H$ be the set of its transitions labelled by $h$, and $A_0 := \attr(H,G)$. and $(S_k)_{1\leq k\leq\kappa}$ a family of disjoint subsets of $V$. If $(S_k)_{1\leq k \leq \kappa}$ is such that
	\begin{itemize}
		\item $\forall 1 \leq k \leq \kappa$, $S_k$ is closed under successor in $(G\setminus H)\setminus \attr(\bigcup_{k'<k} S_{k'}, G\setminus H)$.
		\item $\forall 1\leq k \leq \kappa, (G\setminus H)\restrict S_i$ is a subgame containing priorities up to $h-2$, with an "attractor decomposition" $D_i$ of level $h-2$
		\item $\attr(\bigcup_{0\leq k\leq\kappa}S_i,G\setminus H) = V$.
	\end{itemize}
	Then, by defining iteratively, for $1\leq k \leq \kappa$, $V_k:=V\setminus \bigcup_{j< k}A_j$ and $A_k := \attr(S_k,(G\setminus H)\restrict V_k)$, $(H,A_0, (S_k,A_k,D_k)_{1\leq k \leq \kappa})$ is an "attractor decomposition" of $G$ (up to neglecting the empty $S_k$, of empty attractors).
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 14}\end{proof}

\AP We say that an "attractor decomposition" $(H,A_0,(S_i,A_i,D_i)_{0<i<\ell})$ is ""tight"" if, for all $i,j < \ell$ with $j<i$, all paths from $S_i$ to $S_j$ in $G\setminus H$ are dominated by $h-1$, and the $(D_i)_{(0<i<\ell)}$ are also "tight".

\begin{lemma}\label{lem:tightAD}
	If $G$ is an "even" "parity game" such that the underlying graph is a "tree", we can build a "tight" "attractor decomposition" $D=(H,A_0,(S_i,A_i,D_i)_{0<i<\ell})$ of $G$.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 15}\end{proof}

We can then proceed with~\cref{lem:Reg-to-Strahler}, in which we build the attractor decomposition.

\propRegToStrahler*


\begin{proof}\textcolor{red}{TOPROVE 16}\end{proof}

\subsubsection{Proof from~\cref{sec:universal}}\label{app:Strahler-to-Reg}

\strahlerToReg*

\begin{proof}\textcolor{red}{TOPROVE 17}\end{proof} 
\end{document}
