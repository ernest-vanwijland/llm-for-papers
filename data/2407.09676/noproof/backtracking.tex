% !TEX root = mfe.tex

\section{Backtracking to find the true MFE}\label{sec:BT}

In this section, we give a backtracking procedure, 
\cref{algo:2} in \cref{app:backalgo}, 
to give our main result (\cref{thm:main}). 
First,  we run our augmentation of the known \symnMFE (\snMFE) algorithm---\cref{algo:1} in \cref{sec:AlgoMFE}, which returns some matrices which are input to the backtracking algorithm, \cref{algo:2}. 
Our multistranded backtracking algorithm builds on the single-stranded backtracking algorithm of Wuchty et al.~\cite{wuchty1999complete},
which in turn follows Waterman and Byers~\cite{waterman1985dynamic}, 
 although we make several technical modifications. 
In particular, distinctions with that previous work~\cite{wuchty1999complete,waterman1985dynamic} include: 
\begin{enumerate}
	\item We generalise backtracking from single-stranded to multistranded, which has a slightly different MFE algorithm, consistent with Dirks et al and Fornace et al~\cite{dirks2007thermodynamic,fornace2020unified} (i.e.~as implemented by the NUPACK software); in particular to ensure  the connectedness of secondary structures (a non-issue for~\cite{wuchty1999complete,waterman1985dynamic}). 
	\item We make major changes to the core of the backtracking algorithm  to ensure generation of all secondary structures, 
	at each of a specified number of energy levels, in energy level order 
	(which is different from the Wuchty et al's~\cite{wuchty1999complete} approach of backtracking all sub-optimal secondary structures that lie between the \snMFE and any arbitrary upper limit above it). 
	\item We extend the refinement cases of  Wuchty et al~\cite{wuchty1999complete} to handle our auxiliary matrices in such a way that yields  a good running time. 
\end{enumerate}

\subsection{Partially and fully specified structures} 


\begin{Definition}[Partially and fully specified structure $\mathcal{S}$]
	A partially specified structure $\mathcal{S} = (\delta,\mathcal{P},E_{L_\mathcal{S}})$, where $\delta$ is a stack of disjoint segments of one or more DNA strands $\{[i,j]^t. [k,l]^{t'} \ldots\}$ where $[i,j]^t$ is the top of the stack, such that $i$ and $j$ are the end bases of the segment $[i,j]$, $t \in \{\square,b,m\}$ is the type of each segment, 
	such that $t = \square$ means the existence of a base pair between $i$ and $j$, is as yet undetermined, 
	$t =b$ means there is a base pair between $i$ and $j$, and 
	$t = m$ means that entire segment $[i,j]$ is part of a multiloop. 
	$\mathcal{P}$ is a set of base pairs formed in $\mathcal{S}$, and $E_{L_\mathcal{S}}$ is the energy of all loops that are 
	`completely formed' in $\mathcal{S}$. If $\delta = \phi$, we call $\mathcal{S}$ a fully specified structure.
\end{Definition}

A fully specified structure is a connected unpseudoknotted secondary structure. For any segment $[i,j]^t$,  label $t$ is assigned according to how a segment is generated through \emph{refinement} from another segment, formalized in \cref{sec:backhigh}, 
label $t$ is needed in switching the backtracking between the appropriate matrices of the \snMFE algorithm.
We will denote the minimum free energy attainable from segment $[i,j]^t$, by $E([i,j]^t)$, which we get directly from the appropriate matrix $M$, $M^b$, $M^m$, $M^\text{b:int}$, $M^\text{b:mul}$, or $M^\text{m:2}$, that are returned  by the \snMFE algorithm (\cref{algo:1}), based on $t$, full details are in \cref{sec:AlgoMFE}. 
The domain of the  function $E$ is extended to include the set of all partially specified structures, in addition to the set of all segments,   
$\mathcal{S} = (\delta,\mathcal{P},E_{L_\mathcal{S}})$ so that 
$E$ gives  the minimum free energy attainable from $\mathcal{S}$, 
respecting the refinement rules formalized in \cref{sec:backhigh}, as follows:
\begin{equation}\label{eq:ES}
	E(\mathcal{S}) = E_{L_{\mathcal{S}}} 
	+ \sum \limits_{[m,n]^t \in \delta} E([m,n]^t)
\end{equation}

Any partially specified structure $\mathcal{S} = (\delta,\mathcal{P},E_{L_\mathcal{S}})$ represents a set of all structures that have the base pairs $\mathcal{P}$ in common:  we can think of $\mathcal{S}$ as the root of the tree of these structures, all intermediate nodes of this tree will be partially specified structures, and its leaves will be fully specified structures, and $E(\mathcal{S})$ is the minimum free energy attainable from this tree where all its nodes, structures, are further \emph{refinements} of $\mathcal{S}$.   

\begin{Definition}[Refinement of a partially specified structure]
	A structure $\mathcal{S}' = (\delta',\mathcal{P}',E_{L_{\mathcal{S}'}})$ is called a refinement of the partially specified structure $\mathcal{S} = (\delta,\mathcal{P},E_{L_\mathcal{S}})$ if $\mathcal{P} \subseteq \mathcal{P}'$, and for each segment $[i',j']^{t'} \in \delta'$ there exist a segment $[i,j]^t \in \delta$ such that $[i',j']^{t'} \subseteq [i,j]^t$.
\end{Definition}

\subsection{Analysis of the backtracking algorithm refinement rules}\label{sec:backhigh}


The backtracking algorithm  starts with $\mathcal{S} = ([1,N]^\square, \phi,0)$, which represents the whole system of strands with a specific strand order, $\pi$, without any base pair formed, $\mathcal{P} = \phi$, hence no loops are formed too, $E_{L_\mathcal{S}} = 0$. $\mathcal{S}$ is the parent node of the tree of any possible structure. 
Now, we will outline the main refinement procedure of the generic partial structure $\mathcal{S} = ([i,j]^t.\delta, \mathcal{P}, E_{L_{\mathcal{S}}})$ that has been chosen, at the beginning of each iteration of the backtracking algorithm ({\cref{algo:2}}), 
from some array $\mathcal{R}_{z}$, the array of partially specified structures associated with each secondary structure $S_{z} \in \{S_1, \ldots, S_\mathcal{U}\}$, which is the secondary structure number $z$, of the worst case $\mathcal{U}$ secondary structures we need to scan (\cref{lem:polyub}), such that $S_z$ is completely scanned during the backtracking. 
The segment $I = [i,j]^t$, the top of the
segments stack of $\mathcal{S}$, will be popped  and  refined based on the type of  label $t$ resulting in a new refined structure $\mathcal{S}'$. Matrices $M$, $M^b$, $M^m$, and the new auxiliary matrices $M^\text{b:int}$, $M^\text{b:mul}$, and $M^\text{m:2}$, returned by  \cref{algo:1}, will be used to compute the minimum free energy $E(\mathcal{S}')$ attainable from  the refined partially specified structure~$\mathcal{S}'$.



Given that the algorithm  scans, or backtracks, all secondary structures in energy level $\mathcal{E}$, and $\mathcal{B}$ is the best candidate for the true MFE at the moment, then the \emph{acceptance criteria} of any refined partially specified structure $\mathcal{S}'$ is: 
\begin{equation}
	E(\mathcal{S}') \leq    \mathcal{B}
\end{equation}

This acceptance criteria is checked after each refinement case, and if it is satisfied, $\mathcal{S}'$ will be added on the array of partially specified structures $\mathcal{R}_u$, for some $u \in \{1, \ldots, \mathcal{U} \}$, for further refinements in future, where $\mathcal{R}_u$ is the secondary structure currently being  scanned. 
Note that, because of the strict sequential scanning of the backtracking algorithm (\cref{remark:newS}), 
the acceptance criteria implicitly implies that $\mathcal{E} \leq E(\mathcal{S}')$. Also, 
the acceptance criteria guarantees the connectedness of at least one potential fully specified structure which is a child of $\mathcal{S}'$  
(in  \cref{algo:2}, setting $E(\mathcal{S}') = +\infty$ implies a disconnected or invalid structure). 

There are $3$ cases based on the type of $t$ of the segment $I = [i,j]^t$ that has been popped (as mentioned above) from the stack $\delta$:



\begin{enumerate}\item
	$t = \square$ (recall, $\square$ means: the existence of a base pair between $i$ and $j$ is undetermined): 
	
	In this case we backtrack in matrix $M$.  
	
	$i$ and $j$ are the end bases of $I$, and the possible refinements, based on Eq.~(1) in \cref{fig:mfe}, are: 
	
	\begin{itemize}
		\item Subcase: If the base $j$, at the $3'$ end of the segment $[i,j]$, is unpaired, that will result in the new partial structure (i.e.~excluding $j$ and moving to $j-1$):
		
		$\mathcal{S}' = ([i,j-1]^\square.\delta, \mathcal{P}, E_{L_{\mathcal{S}}})$ such that $E(\mathcal{S}') = M_{i,j-1} + E_{L_{\mathcal{S}}} 
		+ \sum \limits_{[m,n]^t \in \delta} E([m,n]^t)$.
		
		\item 	Subcase: If the base $j$ forms a base pair with base $d \in [i,j-1]$,  we need to scan all such  $d \in [i,j-1]$, 
		and for each we have the new partial structure:
		
		$\mathcal{S}' = ([i,d-1]^\square.[d,j]^b.\delta, \mathcal{P}, E_{L_{\mathcal{S}}})$ such that $E(\mathcal{S}') = M_{i,d-1} + M^b_{d,j}  +E_{L_{\mathcal{S}}} 
		+ \sum \limits_{[m,n]^t \in \delta} E([m,n]^t)$. 
		
		Note that we did not add the base pair $(d,j)$ to $\mathcal{P}$ at this step, but we shall do when refining the interval
		$[d,j]^b$ enclosed by $(d,j)$~\cite{wuchty1999complete}. 	
	\end{itemize}
	
	Then the acceptance criteria will be checked after each of the two sub-cases above. The backtracking algorithm have to  check up to $\mathcal{O}(N)$ refined structures (because of $d$ spans $\leq N$ bases in subcase 2), and hence save up to  $\mathcal{O}(N)$ refined structures to $\mathcal{R}_u$ in the worst case.   
	
	\item
	Case $t = b$ (recall: a base pair is formed between the end bases $i$ and $j$ of $[i,j]^b$ segment):
	
	In this case we backtrack in matrix $M^b$. 	
	Now, assume the segment $[i,j]^b$ is popped from the stack $\delta$, based on Eq.~(2) in \cref{fig:mfe}, there are four subcases:
	
	\begin{itemize}
		
		\item \textbf{Hairpin loop} formation: If  $(i,j)$ is closing a hairpin loop (\cref{fig:mfe}(b)), this will result in the new partial structure:
		
		$\mathcal{S}' = (\delta, \mathcal{P} \cup \{(i,j)\}, E_{L_{\mathcal{S}}} + \Delta G_{i,j}^\text{hairpin} )$ such that $E(\mathcal{S}') = \Delta G_{i,j}^\text{hairpin} + E_{L_{\mathcal{S}}} 
		+ \sum \limits_{[m,n]^t \in \delta} E([m,n]^t)$. 
		
		
		\item \textbf{Interior loop} formation: We need to scan all possible base pairs $(d,e)$ that bind to form an interior loop along with $(i,j)$ (\cref{fig:mfe}(b)). 
		Scanning all pairs in a straightforward way would lead to checking up to $\mathcal{O}(N^2)$ refined structures, 
		which would end up with a poor final worse-case time complexity of the backtracking algorithm. 
		Instead, we scan these base pairs in a different way, that keeps the number of refined structures that we need to check at each iteration to $\mathcal{O}(N)$. We achieve this by introducing a new auxiliary matrix, called $M^\text{b:int}$, in the \snMFE algorithm,  \cref{algo:1}. 		
		
		Modifying the generic form of segment $I$ is essential, in this case, the new segment generic form will be $I = [i,j]^b_{\text{int}:k}$, such that $k \in [i+1,j-1]$, which means that any base $d \in[k,j-1]$ is unpaired, hence not included in the second base pair formation to complete the interior loop with $(i,j)$.
		When a new segment $[i,j]^b$ is just generated as a refinement from another segment, 
		$[i,j]^b$ will be interpreted inside this case as $ [i,j]^b_{\text{int}:j} $, which means any base $d \in [i+1,j-1]$ can be part of the second base pair closing the current interior loop. 
		Given  $I = [i,j]^b_{\text{int}:k}$, there are two cases:
		
		1) If the base $k-1$ is also unpaired, this will
		result in the new partial structure: 
		
		$\mathcal{S}' = ([i,j]^b_{\text{int}:k-1}.\delta, \mathcal{P}, E_{L_{\mathcal{S}}})$ such that $E(\mathcal{S}') = M_{i,j,k-2}^\text{b:int} + E_{L_{\mathcal{S}}} 
		+ \sum \limits_{[m,n]^t \in \delta} E([m,n]^t)$.
		
		2) If the base $k-1$ is paired with another base $d \in [i+1,k-2]$ closing the interior loop, this will result in the new partial structure: 
		
		$\mathcal{S}' = ([d,k-1]^b.\delta, \mathcal{P} \cup \{(i,j)\}, E_{L_{\mathcal{S}}} + \Delta G_{i,d,k-1,j}^\text{interior})$ such that $E(\mathcal{S}') = M^b_{d,k-1} + \Delta G_{i,d,k-1,j}^\text{interior}   +E_{L_{\mathcal{S}}} 
		+ \sum \limits_{[m,n]^t \in \delta} E([m,n]^t)$. 
		
		\item \textbf{Multiloop} formation: In this case we also need to scan all possible pairs $(d,e)$ that will used to form a multi-loop to the $3'$ end (\cref{fig:mfe}(b)), so we will follow the same strategy as the case of interior loop formation, by introducing another new auxiliary matrix, called $M^\text{b:mul}$, in the symmetry agnostic MFE algorithm,  \cref{algo:1}. 
		The generic form of $I$ in this case will be updated to $I = [i,j]^b_{\text{mul}:k}$ such that $k \in [i+1,j-1]$, which means that any base $d \in[k,j-1]$ is unpaired, hence not included in the forming any base pair inside this multiloop along with $(i,j)$.
		When a new segment $[i,j]^b$ is just generated as a refinement from another segment, 
		$[i,j]^b$ will be interpreted inside this case as $ [i,j]^b_{\text{mul}:j} $, which means any base $d \in [i+1,j-1]$ can be part of base pair formation inside this multiloop. 
		Given  $I = [i,j]^b_{\text{mul}:k}$, there are two cases:
		
		1) If $k-1$ is also unpaired, this will
		result in the new partial structure: 
		
		
		$\mathcal{S}' = ([i,j]^b_{\text{mul}:k-1}.\delta, \mathcal{P}, E_{L_{\mathcal{S}}})$ such that $E(\mathcal{S}') = M_{i,j,k-2}^\text{b:mul} + E_{L_{\mathcal{S}}} + \sum \limits_{[m,n]^t \in \delta} E([m,n]^t)$. 
		
		2) If the base $k-1$ is paired with another base $d \in [i+1,k-2]$, this will result in the new partial structure: 
		
		$\mathcal{S}' = ([i+1,d-1]^m.[d,k-1]^b.\delta, \mathcal{P} \cup \{(i,j)\}, \Delta G_\text{init}^\text{multi} + 2\Delta G_\text{bp}^\text{multi} + (j-k) \Delta G_\text{nt}^\text{multi} + E_{L_{\mathcal{S}}})$ such that $E(\mathcal{S}') =  M^m_{i+1,d-1} + M^b_{d,k-1} + \Delta G_\text{init}^\text{multi} + 2\Delta G_\text{bp}^\text{multi} + (j-k)\Delta G_\text{nt}^\text{multi} +E_{L_{\mathcal{S}}} 
		+ \sum \limits_{[m,n]^t \in \delta} E([m,n]^t)$. 
		
		\item \textbf{Exterior loop} formation: All bases $z \in [i,j]$ such that $[z,z+1]$ is a nick \cref{fig:sec struct}, transition between two strands, are scanned (\cref{fig:mfe}(b)), leading to the new partial structure: 
		
		$\mathcal{S}' = ([i+1,z]^\square.[z+1,j-1]^\square.\delta, \mathcal{P} \cup \{(i,j)\}, E_{L_{\mathcal{S}}})$ such that $E(\mathcal{S}') = M_{i+1,z} +  M_{z+1,j-1} +  E_{L_{\mathcal{S}}} + \sum \limits_{[m,n]^t \in \delta} E([m,n]^t)$.   
		
		
		
	\end{itemize}
	
	Then the acceptance criteria will be checked after each sub-case. Now, with the aid of the introduced new auxiliary matrices $M^\text{b:int}$ and $M^\text{b:mul}$, the backtracking algorithm checks up to $\mathcal{O}(N)$ refined structures, and hence saves up to  $\mathcal{O}(N)$ refined structures to $\mathcal{R}_u$ in the worst case. Without the  new auxiliary matrices (in this case of $t=b$), the backtracking algorithm will check up to $\mathcal{O}(N^2)$ refined structures, and saves up to  $\mathcal{O}(N^2)$ refined structures to $\mathcal{R}_u$.
	
	
	\item
	Case $t = m$ 	(recall: the segment $[i,j]^m$ is a part of a multiloop): 
	
	We backtrack in matrix $M^m$. 
	Now, assume the segment $[i,j]^m$ is popped from the stack, based on Eq.~(3) in \cref{fig:mfe},  there are two subcases:
	
	\begin{itemize}
		\item  If there exists exactly one additional base pair $(d,e)$ defining the multiloop (\cref{fig:mfe}(c)), then we will scan for all possible pairs $(d,e)$ that could be used. Following the same strategy of scanning introduced before (i.e.~in case 2. $t=b$, interior loop or multiloop) to reduce time in interior and multiloop formation cases when $t = b$, there are two cases: 
		
		1) If $j$ is unpaired, this will
		result in the new partial structure: 
		
		$\mathcal{S}' = ([i,j-1]^m.\delta, \mathcal{P}, E_{L_{\mathcal{S}}} + \Delta G_\text{nt}^\text{multi})$ such that $E(\mathcal{S}') = M_{i,j-1}^m + \Delta G_\text{nt}^\text{multi} +E_{L_{\mathcal{S}}} + \sum \limits_{[m,n]^t \in \delta} E([m,n]^t)$. 	 	
		
		2) If the base $j$ is paired with another base $d \in [i,j-1]$ defining the multiloop, this will result in the new partial structure: 
		
		$\mathcal{S}' = ([d,j]^b.\delta, \mathcal{P}, E_{L_{\mathcal{S}}} + \Delta G_\text{bp}^\text{multi} + (d-i) \Delta G_\text{nt}^\text{multi})$ such that $E(\mathcal{S}') = M^b_{d,j} + \Delta G_\text{bp}^\text{multi}+ (d-i) \Delta G_\text{nt}^\text{multi} +E_{L_{\mathcal{S}}} 
		+ \sum \limits_{[m,n]^t \in \delta} E([m,n]^t)$. 
		
		
		\item  If there exist more than one  base pair defining the multiloop, all possible pairs $(d,e)$ are scanned (\cref{fig:mfe}(c)). Following the same strategy of scanning, and using one of the new auxiliary matrices, called $M^\text{m:2}$, in the \snMFE algorithm, \cref{algo:1}. 
		
		
		The generic form of $I$ in this case will be updated to $I = [i,j]^m_{\text{mul}:k}$ 	such that $k \in [i,j]$, which means that any base $d \in[k,j]$ is unpaired, hence not included in the forming of any base pair inside this multiloop.
		When a new segment $[i,j]^m$ is just generated as a refinement from another segment, 
		$[i,j]^m$ will be interpreted inside this case as $ [i,j]^m_{\text{mul}:j-1} $, which means any base $d \in [i,j]$ can be part of base pair formation inside this multiloop. 
		Given  $I = [i,j]^m_{\text{mul}:k}$, there are two cases:
		
		
		
		
		1) If the base $k-1$ is also unpaired, this will
		result in the new partial structure: 
		
		$\mathcal{S}' = ([i,j]^m_{\text{mul}:k-1}.\delta, \mathcal{P}, E_{L_{\mathcal{S}}})$ such that $E(\mathcal{S}') = M_{i,j,k-2}^\text{m:2} + E_{L_{\mathcal{S}}} + \sum \limits_{[m,n]^t \in \delta} E([m,n]^t)$. 
		
		2) If the base $k-1$ is paired with another base $d \in [i,k-2]$,  this will result in the new partial structure: 
		
		$\mathcal{S}' = ([i,d-1]^m.[d,k-1]^b.\delta, \mathcal{P},  \Delta G_\text{bp}^\text{multi} + (j-k + 1) \Delta G_\text{nt}^\text{multi} + E_{L_{\mathcal{S}}})$ such that $E(\mathcal{S}') =   M^m_{i,d-1} +  M^b_{d,k-1} + \Delta G_\text{bp}^\text{multi} + (j-k + 1)\Delta G_\text{nt}^\text{multi} +E_{L_{\mathcal{S}}} 
		+ \sum \limits_{[m,n]^t \in \delta} E([m,n]^t)$. 
		
		
	\end{itemize}
	
	Then the acceptance criteria will be checked after each sub-case. Now, with the aid of the introduced new auxiliary matrices $M^\text{mul:2}$, the backtracking algorithm   checks up to $\mathcal{O}(N)$ refined structures, hence saves up to  $\mathcal{O}(N)$ refined structures to $\mathcal{R}_u$, in the worst case.
	
\end{enumerate}

\begin{remark}
	For any $\mathcal{S}$ and  $\mathcal{S}'$ such that $\mathcal{S}'$ is a refinement of $\mathcal{S}$ based on refinement rules described above, $E(\mathcal{S}) \leq E(\mathcal{S}')$. Also, note that the form of the new refined structure $\mathcal{S}'$ in each case of refinement cases is different, and hence leads to a different fully specified structure which guarantees that each secondary structure $S_u$ encountered during the backtracking is scanned exactly once. 
\end{remark} 

\begin{remark}\label{remark:spaceE}
	For all the cases above where  $\mathcal{S}'$ is refinement of $\mathcal{S}$,  the stack $\delta$ and the base pairs set $\mathcal{P}$ are parts (common) of each refined structure  $\mathcal{S}'$,  hence it is enough to save them once, which  takes $\mathcal{O}(N)$ space, and for each refined structure $\mathcal{S}'$, we need to save only the additional base pairs (one base pair in the worst case, hence $\mathcal{O}(1)$ space), or the new segments (two segments in the worst case, hence $\mathcal{O}(1)$ space) that are pushed on the top of $\delta$ based on the refinement case. In total saving the all $\mathcal{O}(N)$ refined structures that are generated from all cases requires $\mathcal{O}(N)$ space.   
	
	
\end{remark}  

\begin{remark}\label{remark:timeE}
	For all the cases above where  $\mathcal{S}'$ is refinement of $\mathcal{S}$,  $\mathcal{H} = E_{L_{\mathcal{S}}} + \sum_{[m,n]^t \in \delta} E([m,n]^t)$ 
	is repeatedly used to compute $E(\mathcal{S}')$ again and again, hence it is enough to compute it once, which takes only $\mathcal{O}(N)$ time. 
	In total, if $\mathcal{H}$ is pre-computed once in this way, computing $E(\mathcal{S}')$ takes $\mathcal{O}(1)$ time. 
\end{remark} 


After scanning the secondary structure $S_u$ completely, the partially specified structure $\mathcal{S}' \in \mathcal{R}_u$, such that $E(\mathcal{S}') =  \min\limits_{\mathcal{S} \in \mathcal{R}_u}\{ E(\mathcal{S})\}$ will be computed and saved. And a new partially specified structure $\mathcal{S}$ is chosen as follows:

\begin{equation} \label{eq:newS}
	\mathcal{S} = \min\limits_{z \in \left\{1,\ldots,u\right\}}\left\{\min\limits_{\mathcal{S}' \in \mathcal{R}_z}\left\{ E(\mathcal{S}')\right\}\right\} 
\end{equation}

Where $\{S_1,\ldots,S_u\}$ is the set of distinct secondary structures that are completely scanned until the moment, where $u<\mathcal{U}$. Then the minimum ($\min_{\mathcal{S}' \in \mathcal{R}_z}\left\{ E(\mathcal{S}')\right\}$) of the array $\mathcal{R}_{z'}$ where $\mathcal{S}$ is choose from, will be computed again and saved for future iterations. 

\begin{remark}\label{remark:newS}
	\cref{eq:newS} guarantees sequential scanning of the backtracking algorithm through energy levels without skipping any potential structure, due to free energy minimality. Also, note that for all $z \in \{1,\ldots,u\}$, the  $\min_{\mathcal{S}' \in \mathcal{R}_z}\left\{ E(\mathcal{S}')\right\}$ is already computed and saved, as in each iteration we choose only the minimum over the set of all minimum energies of each array, so we lose only one the minimum of some array $\mathcal{R}_{z'}$, so $\mathcal{R}_{z'}$ is the only one we need to compute its minimum again in $\mathcal{O}(N^2)$ time.        
\end{remark} 

The same refinement process starts again with that new selected partially specified structure $\mathcal{S}$. This backtracking procedure continues in this way until one of the three following conditions occurs first: 
\begin{enumerate}
	\item  The algorithm scans an {\em asymmetric} secondary structure $S_u$, then the true MFE $= \Delta G (S_u)$, as a direct consequence of $\Delta G (S_u) \leq \mathcal{B}$, where we recall that $\mathcal{B}$ was the best candidate value for true MFE, or 
	\item  The algorithm exceeds the upper bound $\mathcal{U}$ of the number of symmetric secondary structures to be scanned, then the true MFE $= \mathcal{E}$, the energy of the last scanned energy level which is also the \snMFE of that last completely scanned symmetric secondary structure $S_u$, as a direct consequence of \cref{lem:polyub,lem:sand,lem:sand2} (meaning we have two symmetric structures of  \snMFE equal to $\mathcal{E}$ with the same admissible cut, hence we can make a new pizza: an asymmetric secondary structure of true MFE $\mathcal{E}$), or
	\item  The algorithm starts scanning a new energy level $\mathcal{E}' > \mathcal{B}$, then the true MFE $= \mathcal{B}$, as $\mathcal{B}$ is the best candidate for the true MFE that we got from a previously scanned symmetric secondary structure.   
\end{enumerate}
Whichever of the three cases occurs, the true MFE is returned (and a secondary structure with that true MFE is constructed).

\subsection{Time and space complexity analysis of the backtracking algorithm}\label{sec:backtime}

The backtracking algorithm needs to scan up to $\mathcal{U} = \mathcal{O}(N^2)$ secondary structures in the worst case ({\cref{lem:polyub}}), so the total time complexity of the backtracking algorithms is $\mathcal{O}(\mathcal{U} \mathcal{W})$, where $\mathcal{W}$ is the time complexity of scanning only one secondary structure and setting up the scene for the next iteration by choosing the new partially specified structure required to scan the next secondary structure. 

\paragraph{Analysis for scanning only one secondary structure in the backtracking algorithm.}
To scan (construct) one secondary structure $S_u$, we need in the worst case  $N = \mathcal{O}(N)$ refinement steps, as each step either ignores a base or forms a base pair. We showed in our analysis, in \cref{sec:backhigh}, and based on $t \in \{\square,b,m\}$, that each step checks up to $\mathcal{O}(N)$ refined structures and saves up to $\mathcal{O}(N)$ refined structures to $\mathcal{R}_u$, the array of refined structures associated with $S_u$. In total, by \cref{remark:timeE}, scanning one secondary structure takes $\mathcal{O}(N^2)$, as $\mathcal{R}_u$ contains $\mathcal{O}(N^2)$ structure, hence computing the minimum of $\mathcal{R}_u$ takes $\mathcal{O}(N^2)$ time. 

The last step is to see what is the time complexity of choosing the new partially specified structure $\mathcal{S}$ for the next iteration based on \cref{eq:newS}, from \cref{remark:newS} this step takes $\mathcal{O}(N^2)$ time, as the minimum of all the $\mathcal{U} = \mathcal{O}(N^2)$ arrays is already computed and stored. 

So, in total scanning one secondary structure and setting up the scene for the next iteration by choosing the new partially specified structure $\mathcal{S}$ takes $\mathcal{O}(N^2)$ time.

\cref{remark:spaceE} shows that each array $\mathcal{R}_u$ requires $\mathcal{O}(N^2)$ space, hence in total the backtracking algorithm requires $\mathcal{O}(N^4)$ space to store the all $\mathcal{R}_u$ such that $u \in \{1, \ldots, \mathcal{U}\}$. This analysis leads to the following result.

\begin{lemma}\label{lem:BTtime}
	The running time  of the backtracking algorithm,   \cref{algo:2} and \cref{sec:backhigh},
	for a set of $c = \mathcal{O}(1)$ DNA or RNA strands of total length  $N$ bases, is $\mathcal{O}(N^4(c-1)!)$, and it requires $\mathcal{O}(N^4)$ space.  
\end{lemma}

\begin{remark}\label{remark:newT}
	We should note that, changing the strategy, used in \cref{eq:newS}, for choosing the new partially specified structure $\mathcal{S}$ can help in reducing the space complexity of the backtracking algorithm from $\mathcal{O}(N^4)$ to $\mathcal{O}(N^3)$ (the same space complexity as \snMFE \cref{algo:1}) with the trade off increasing the time complexity to be $\mathcal{O}(N^4 \log N(c-1)!)$ instead of $\mathcal{O}(N^4 (c-1)!)$. As we know that we need to scan only $\mathcal{U} = \mathcal{O}(N^2)$ secondary structures, so we do not need to store all elements of arrays $\mathcal{R}_z$ where $z \in \{1,\ldots,u\}$. 
	Only the minimum $\mathcal{U}$ candidates should be stored. By sorting $\mathcal{R}_u$, the array of partially specified structures that we obtain after constructing the secondary structure $S_u$ (the secondary structure number $u$, of the worst case $\mathcal{U}$). $\mathcal{R}_u$ can be sorted in $\mathcal{O}(N^2 \log N)$ time then merged in $\mathcal{O}(N^2)$ time with the already sorted array, that we obtain cumulatively through time from the previous iterations.        
\end{remark} 

As we noted before in \cref{lem:even}, that the (bad) quadratic upper bound $\mathcal{U}$ in \cref{lem:ub2} is very restricted and rare, and 
for systems of $c$ strands ($k$ strand types) where the repetition number of some strand type is odd, \cref{lem:even} shows that the upper bound $\mathcal{U}$ is linear. Hence, the time complexity of the backtracking algorithm is $\mathcal{O}(N^3(c-1)!)$ and it requires $\mathcal{O}(N^3)$ space.




\section{Time and space analysis of MFE algorithm}\label{sec:analysis}

\main*


\begin{proof}\textcolor{red}{TOPROVE 0}\end{proof}

