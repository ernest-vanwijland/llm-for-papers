\documentclass{amsart}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{xspace}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{floatrow}
\usepackage{enumerate}
\usepackage{hyperref}
\usepackage{algorithm}
\usepackage{algpseudocode}

\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{enumitem}
\newcommand{\BR}[1]{BR$_ #1$}
\newcommand{\KR}[1]{KR$_ #1$}

 \hypersetup{
 pdftitle = {Pushing the frontiers of subexponential FPT time for Feedback Vertex Set},
 pdfauthor=  {Gaétan Berthe, Marin Bougeret, Daniel Gonçalves, Jean-Florent Raymond},
  colorlinks = true,
 linkcolor = black!40!red,
 citecolor = black!40!green
 }

\renewcommand\UrlFont{\color{blue}\rmfamily}

\usepackage[a4paper, margin=2.5cm]{geometry}
\usepackage{amsmath,amssymb}
\usepackage{thmtools}
\usepackage{thm-restate}
\usepackage{todonotes}
\usepackage{comment}
\usepackage{euscript}



 
\declaretheorem[name=Theorem, numberwithin=section]{theorem} 
\declaretheorem[name=Lemma, sibling=theorem]{lemma}
\declaretheorem[name=Proposition, sibling=theorem]{proposition}
\declaretheorem[name=Definition, sibling=theorem]{definition}
\declaretheorem[name=Corollary, sibling=theorem]{corollary}
\declaretheorem[name=Conjecture, sibling=theorem]{conjecture}
\declaretheorem[name=Problem, sibling=theorem]{problem}
\declaretheorem[name=Claim, sibling=theorem]{claim}
\declaretheorem[name=Remark, style=remark, sibling=theorem]{remark}
\declaretheorem[name=Observation, style=remark, sibling=theorem]{observation}
\declaretheorem[name=Question, style=remark, sibling=theorem]{question}
\newtheorem*{main-thm}{Main Theorem}

\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}



\newcommand{\algopart }{\texttt{Partitionning-Algorithm}~ }

\newcommand{\RR}{\mathbb{R}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\HH}{\mathcal{\H}}
\newcommand{\G}{\mathcal{G}}
\newcommand{\D}{\mathcal{D}} \newcommand{\R}{\mathcal{R}} \newcommand{\C}{\mathcal{C}} \newcommand{\E}{\mathcal{E}} 
\newcommand{\T}{\mathcal{T}} 
\newcommand{\I}{\mathcal{I}} 
\newcommand{\NT}{\mathcal{NT}} 
\newcommand{\ICP}{\mathcal{ICP}}
\newcommand{\mC}{\mathcal{MC}} 
\newcommand{\eps}{\varepsilon}
\newcommand{\pD}{\partial\mathcal{D}}
\newcommand{\mS}{\mathcal{S}} 
\newcommand{\GS}{{G_\mathcal{S}}}
\newcommand{\PS}{{\overrightarrow{P}_\mathcal{S}}}
\newcommand{\dPS}{{\overrightarrow{P}^*_\mathcal{S}}}
\newcommand{\RT}{{\mathcal{R}_T}}
\newcommand{\RM}{{\mathcal{R}_M}}
\newcommand{\mR}{{\mathcal{R}}}
\newcommand{\mA}{{\mathcal{A}}}
\newcommand{\Pmax}{\mathcal{P}^{max}}
\newcommand{\Pmaxbig}{\mathcal{P}^{max}_{big}}
\newcommand{\Pmaxsmall}{\mathcal{P}^{max}_{small}}
\newcommand{\Paths}{\mathcal{P}}
\newcommand{\Psmall}{\mathcal{P}_{small}}
\newcommand{\Pbig}{\mathcal{P}_{big}}
\newcommand{\Tmax}{\mathcal{T}^{max}}
\newcommand{\Tmaxbig}{\mathcal{T}^{max}_{big}}
\newcommand{\Tmaxsmall}{\mathcal{T}^{max}_{small}}
\newcommand{\Trees}{\mathcal{T}}
\newcommand{\Tsmall}{\mathcal{T}_{small}}
\newcommand{\Tbig}{\mathcal{T}_{big}}
\newcommand{\NM}{N_M}
\newcommand{\dM}{d_M}
\newcommand{\pom}{\partial_{\overline{M}}}
\newcommand{\bom}{b_{\overline{M}}}
\newcommand{\mT}{\mathcal{T}}
\newcommand{\mH}{\mathcal{H}}
\newcommand{\KttTilde}{\widetilde{K_{t,t}}}

\newcommand{\cUn}{c}
\newcommand{\cDeux}{c'}
\renewcommand{\d}{d}
\newcommand{\f}{f}
\newcommand{\tdp}{T_{DP}}
\newcommand{\CDP}{C_{DP}}

\newcommand{\intv}[2]{\left \{ #1, \dots, #2 \right \}}

\DeclareMathOperator\ply{ply}
\DeclareMathOperator\diam{diam}
\DeclareMathOperator\dd{d_\Delta}
\DeclareMathOperator{\ddB}{d_\Delta^{\mathcal B}}
\DeclareMathOperator{\ND}{N_{\Delta}}
\DeclareMathOperator{\NDB}{N_{\Delta}^{\mathcal B}}
\DeclareMathOperator{\touch}{\sf End}
\DeclareMathOperator\grid{\boxplus}
\DeclareMathOperator\minor{\prec}

\DeclareMathOperator\sn{\textsf{sn}}
\DeclareMathOperator\tw{\textsf{tw}}
\DeclareMathOperator\poly{\textsf{poly}}
\DeclareMathOperator\db{\mu}
\DeclareMathOperator\TO{\Tilde{\O}}

\newcommand{\trh}{\textsc{Triangle Hitting}\xspace}
\newcommand{\wtrh}{\textsc{Weighted Triangle Hitting}\xspace}
\newcommand{\fvs}{\textsc{Feedback Vertex Set}\xspace}
\newcommand{\afvs}{\textsc{$(r,\G)$-Annotated Feedback Vertex Set}\xspace}
\newcommand{\oct}{\textsc{Odd Cycle Transversal}\xspace}
\newcommand{\FVS}{\textsc{FVS}\xspace}

\newcommand{\AFVS}{\textsc{$(r,\G)$-Ann-FVS}\xspace}
\renewcommand{\TH}{TH\xspace}
\newcommand{\OCT}{OCT\xspace}
\newcommand{\THREESAT}{3-SAT\xspace}
\newcommand{\PTHREESAT}{\textsc{Planar-3-SAT}\xspace}

\newcommand{\ruleref}[1]{\hyperref[#1]{\ref*{#1}}}

\renewcommand{\O}{\mathcal{O}}
\renewcommand{\o}{o}
\newcommand{\Ostar}{\O^*}

\newcommand{\NP}{NP\xspace}
\newcommand{\ETH}{ETH\xspace}
\newcommand{\SQGM}{SQGM\xspace}
\newcommand{\ASQGM}{ASQGM\xspace}

\newcommand{\dDIR}{$d$-DIR\xspace}
\newcommand{\TWODIR}{2-DIR\xspace}
\newcommand{\CONTACTSEG}{contact-segment\xspace}
\newcommand{\CONTACTDEUXDIR}{contact-\TWODIR{}}

\def\cqedsymbol{\ifmmode$\lrcorner$\else{\unskip\nobreak\hfil
\penalty50\hskip1em\null\nobreak\hfil$\lrcorner$
\parfillskip=0pt\finalhyphendemerits=0\endgraf}\fi} 
\newcommand{\cqed}{\renewcommand{\qed}{\cqedsymbol}}



\def\sectionautorefname{Section}
\def\subsectionautorefname{Subsection}
\def\subsubsectionautorefname{Subsubsection}
\def\algorithmautorefname{Algorithm}

\usepackage{marvosym}
\newcommand{\apx}[1]{\hyperref[#1]{\LeftScissors}}



\graphicspath{{fig/}}


\title{
Pushing the frontiers of subexponential FPT time for Feedback Vertex Set}
\author[G.~Berthe]{Gaétan Berthe}
\author[M.~Bougeret]{Marin Bougeret}
\author[D.~Gonçalves]{Daniel Gonçalves}
\address[G.~Berthe, M.~Bougeret, D.~Gonçalves]{LIRMM, Université de Montpellier, CNRS, Montpellier, France.}
\email{firstname.lastname@lirmm.fr}

\author[J.-F.~Raymond]{Jean-Florent Raymond}
\address[J.-F.~Raymond]{CNRS, LIP, ENS de Lyon, France.}
\email{jean-florent.raymond@cnrs.fr}

\date{April 2025}

\begin{document}

\begin{abstract}
The paper deals with the \fvs problem parameterized by the solution size. Given a graph $G$ and a parameter $k$, one has to decide if there is a set $S$ of at most $k$ vertices such that $G-S$ is acyclic.
Assuming the Exponential Time Hypothesis, it is known that \FVS cannot be solved in time $2^{o(k)}n^{\O(1)}$ in general graphs. To overcome this, many recent results considered \FVS restricted to particular intersection graph classes and provided such $2^{o(k)}n^{\O(1)}$ algorithms. 


In this paper we provide generic conditions on a graph class for the existence of an algorithm solving \FVS in subexponential FPT time, i.e. time $2^{k^\eps} \mathop{\rm poly}(n)$, for some $\eps<1$, where $n$ denotes the number of vertices of the instance and $k$ the parameter.
On the one hand this result unifies algorithms that have been proposed over the years for several graph classes such as planar graphs, map graphs, unit-disk graphs, pseudo-disk graphs, and string graphs of bounded edge-degree. On the other hand it extends the tractability horizon of \FVS to new classes that are not amenable to previously used techniques, in particular intersection graphs of ``thin'' objects like segment graphs or more generally $s$-string graphs.
\end{abstract} 
\maketitle


\section{Introduction}
\label{sec:intro}

\subsection{Context}


Given an $n$-vertex graph $G$ and a parameter $k\in \mathbb{N}$, the \fvs problem (\FVS for short) asks whether there exists a set $S$ of at most $k$ vertices such that $G-S$ has no cycle. 
This is a fundamental decision problem in graph theory and one of Karp's 21 NP-complete problems. Because of its hardness in a classical setting, the problem has been widely studied within the realm of parameterized complexity.
This line of research aims to investigate the existence of \emph{FPT algorithms}, i.e., algorithms that run in time $f(k)\cdot n^{\O(1)}$, for some computable function $f$. Such algorithms provide a fine-grained understanding on the time complexity of a problem and describe regions of the input space where the problem can be solved in polynomial time. Note that it is crucial here to obtain good bounds on the function $f$ since the (potentially) super-polynomial part of the running time is confined in the $f(k)$ term. In this direction it was proved that under the Exponential Time Hypothesis of Impagliazzo, Paturi and Zane, FVS does not admit an algorithm with running time $2^{o(n)}n^{\O(1)}$ (see \cite{Cygan2015Book}). Nevertheless certain classes of graphs (typically planar graphs) have been shown to admit algorithms with running times of the form $2^{\O(k^{\eps})} n^{\O(1)}$ (for some $\eps<1$), i.e., where the contribution of the parameter $k$ is subexponential. Such algorithms are called \emph{subexponential parameterized algorithms} and they are the topic of this paper.
Given the numerous existing results on this theme, there are two main directions of research: to improve the running times in the classes where an algorithm is already known, or to extend the tractability horizon of \FVS by providing more general settings where subexponential FPT algorithms exist.

We are here interested by the second direction, that can be summarized by the following question.
\begin{question}\label{q:main}
What are the most general graph classes where \FVS admits a subexponential parameterized algorithm ?
\end{question}

Historically, a primary source of graph classes studied to make progress on the above question was geometric intersection graphs.
In an \emph{intersection graph}, each vertex corresponds to a subset of some ambient space, and two vertices are adjacent if and only if the subsets intersect. Taking the Euclidean plane as the ambient space, many graph classes can been defined by setting restrictions on the subsets used to represent the vertices. One can for instance consider intersection graphs of disks in the plane, or segments, or Jordan arcs\footnote{In the following, those are called strings.}. With such subsets, one defines the class of {\em disk graphs}, {\em segment graphs}, and {\em string graphs} respectively. It is also often the case that there are conditions dealing with all the $n$ subsets representing the vertices of a given graph. For example, if we consider disks (resp. segments) one can ask those to have the same diameter (resp. to use at most $d$ different slopes), and this defines the class of {\em unit disk graphs} (resp. {\em $d$-DIR graphs}). When considering strings, one possible property is that any string has at most $d$ points shared with the other considered strings. This defines string graphs with {\em edge degree at most~$d$}. 
A weaker condition is to ask every pair of the considered strings to intersect on at most $s$ points, this defines {\em $s$-string graphs}.
This class generalizes several natural classes such as planar graphs, map graphs, unit-disk graphs, segment graphs, string graphs of bounded edge-degree, and intersection graphs of $\alpha$-convex bodies that exclude a fixed subgraph (see \cite{matouvsek2014string, kratochvil1994intersection, baste2022contraction}). 



For all these graph classes, \FVS is NP-complete, and actually under ETH none of them admits a $2^{o(\sqrt{n})}$-time algorithm. Indeed, this lower bound was given in~\cite{deberg_unit} for induced grid graphs, which form a subclass of unit disk graphs and 2-DIR graphs. On the other hand for each of the aforementioned classes there is an algorithm solving \FVS in subexponential time. More precisely, this algorithm applies to any string graph and runs in time $2^{\TO(n^{2/3})}$~\cite{bonnet2019optimality}.\footnote{The notation $\TO$ ignores polylogarithmic factors, i.e. we write $g(x) = \TO(f(x))$ if for some $c$ we have $g(x) = \O(f(x) \cdot \log^c x)$.}

Regarding subexponential parameterized algorithms, the case of unit disk graphs was settled with an algorithm whose running time matches the ETH lower bound~\cite{an_unit_21}. This result uses the fact that these graphs admit vertex partitions into cliques such that each of these cliques is adjacent to only a constant number of the other cliques. Such a property does not hold for the other graph classes mentioned above. 
However, other techniques have been developed to deal with the other aforementioned classes such as the classes of bounded edge degree string graphs~\cite{baste2022contraction}, contact-segment and square graphs~\cite{berthe24ASQGM}, disk graphs~\cite{lokSODA22,Faster2023Shinwoo}, or the pseudo-disk graphs~\cite{FVS-WG}.
Note that when dealing with classes of intersection graphs, the representation of the input (if known) could be used by the algorithm.
Some of these algorithms are {\em robust}, meaning that the input graph $G$ is provided using one of the classical graph data structures, where there is no indication of the intersection model of $G$. Because the recognition problem is difficult for most of the classes discussed above, robustness is a substantial advantage.



\subsection{Our contribution}
Toward answering \autoref{q:main}, we identify sufficient conditions for a graph class (then said to be \emph{nice}) to admit a subexponential parameterized algorithm for \FVS. 
As we will see later these conditions are satisfied by several natural graph classes, some of which were not known to admit a subexponential parameterized algorithm prior to this work.

Let us now provide some intuition behind the conditions we require for a \emph{nice} graph class. We discuss here the similarities between these conditions and classical studied properties, while the reasons why these conditions help to get a subexponential parameterized algorithm for \FVS are examined in \autoref{sec:techniques}.
A starting point is to review known results about string graphs, which constitute a good candidate to answer the previous question. In particular, the following results are known for string graphs. For a graph $H$, let us say that a graph is \emph{$H$-free} if it does not contain $H$ as subgraph.
\begin{theorem}[\cite{lee2016separators},\cite{DVORAK2019137}]\label{th:tw}
$K_{r,r}$-free string graphs on $n$ vertices have treewidth $\O(\sqrt{nr\log r})$.
\end{theorem}
\begin{theorem}[\cite{lee2016separators}]\label{th:Lee}
    There exists a constant $c$ such that for $r>0$ it holds that every $K_{r,r}$-free string graph on $n$ vertices has at most $cr(\log r) n$ edges.
\end{theorem}

These results\footnote{Note that an error was found in the proof of the above results in~\cite{lee2016separators}, but a claim by the author was made that the proof can be corrected in the case of string graphs (see~\cite{Bonnet2024}). Moreover the earlier bound in~\cite{Matousek14} yields similar results, up to logarithmic factors.
} are interesting in our case, as a simple folklore branching allows us to reduce the problem to the case where the instance $(G,k)$ of \FVS is $K_{r,r}$-free for $r=\lceil k^\eps \rceil$.
Thus, among the conditions required for a graph class to be nice,
two of them correspond to a relaxed version of the above theorems.

Our last main condition is related to neighborhood complexity.
A graph class $\mathcal{G}$ has \emph{linear neighborhood complexity (with ratio $c$)} if for any graph $G\in \mathcal{G}$ and any $X \subseteq V(G)$, $|\{N(v) \cap X, v \in V(G)\}| \le c|X|$. 
It is known that bounded-expansion graph classes have linear neighborhood complexity \cite{reidl2019characterising} as well as bounded twin-width graphs \cite{bonnet2024neighbourhood}.
In previous work on parameterized subexponential algorithms \cite{Lokshtanov23Approx,Faster2023Shinwoo,FVS-WG,berthe24ASQGM}, it appeared useful that the considered graphs have the property that,
if $G$ is $K_{r,r}$-free (or even $K_r$-free), then for any $X \subseteq V(G)$, $|\{N(v) \cap X, v \in V(G)\}| \le r^{\O(1)}|X|$.
Notice that this is slightly stronger than requiring that a class that is $K_{r,r}$-free (or $K_r$-free) for a fixed $r$ has linear neighborhood complexity, as it is important for our purpose that the dependency in $r$ is polynomial. 
We point out that $K_{r,r}$-free string graphs have bounded-expansion, hence linear neighborhood complexity, however this does not imply that the dependency in $r$ is polynomial.
Thus, our last main condition (called \emph{bounded tree neighborhood complexity}) can be seen as a slightly stronger version of this ``polynomially dependent'' neighborhood complexity.
Let us now proceed to the formal definitions.

\begin{definition}\label{def:NCtrees}
We say that a graph class $\mathcal{G}$ has \emph{bounded tree neighborhood complexity} (with parameters  $\alpha,f_1,f_2$) if there exist an integer $\alpha$ and two polynomial functions $f_1,f_2$ such that the following conditions hold.
For every $r$, every $K_{r,r}$-free graph $G \in \mathcal{G}$, every set $A\subseteq V(G)$ and every family $\mT$ of disjoint non-adjacent\footnote{Two vertex subsets are \emph{non-adjacent} in a graph if there is no edge from one to the other, see \autoref{subsec:basic}.} vertex subsets of $G-A$, each inducing a tree:
\begin{enumerate}
    \item $|\{N_A(T),~T\in \mT \}|\leq f_1(r) |A|^{\alpha}$, where $N_A(T)$ denotes the neighbors of the vertices of $T$ in $A$, and\label{def:NCtrees:item1}
    \item $|\{N_A(T),~T\in \mT\}|\leq f_2(r,p,m)|A|$, where $p$ and $m$ denote the maximum  over all $T\in \mT$ of $|N_A(T)|$ and $|T|$ respectively. \label{def:NCtrees:item2}
\end{enumerate}
\end{definition}


\begin{definition}\label{def:prop}
We say that an hereditary graph class $\mathcal{G}$ is \emph{nice} (for parameters $\alpha,\f_1,\f_2, \delta, \f, \d$) if all the following conditions hold: 
\begin{enumerate}
    \item $\mathcal{G}$ is stable by contraction of an edge between degree-two vertices that do not belong to a triangle.\label{def:prop:deg2}
    \item $\mathcal{G}$ has bounded tree neighborhood complexity (for some parameters $\alpha,f_1,f_2$).\label{def:prop:nc}
    \item There exist $\delta < 1$ and a constant $\f_r$ that depends polynomially in $r$ such that for any $K_{r,r}$-free graph $G \in \mathcal{G}$, $\tw(G)=\O(\f_r\cdot n^{\delta})$.\label{def:prop:tw}
    \item There is a constant $\d_r$ that depends polynomially  in $r$ such that for any $K_{r,r}$-free graph $G \in \mathcal{G}$, $|E(G)|\leq \d_r\cdot |V(G)|$. Without loss of generality we will assume $d_r\geq r$.\label{def:prop:sparse}
\end{enumerate}
\end{definition}

Our main result is the following. 
\begin{main-thm}\label{main-thm}
For every nice hereditary graph class $\mathcal{G}$ there is a constant $\eta<1$ such that FVS can be solved in $\mathcal{G}$ in time $2^{k^\eta}\cdot  n^{\O(1)}$.

\end{main-thm}

Actually we provide a single generic algorithm for all nice classes and the parameters of the class (in the definition of nice) appear in the complexity analysis and are used to define $\eta$.
The techniques used to prove the above result are discussed in \autoref{sec:techniques}. For the time being, let us focus on consequences.
As hinted above, being nice is a natural property shared by several well-studied classes of graphs. In particular we show that it is the case for $s$-string graphs and pseudo-disk graphs, hence we have the following applications.

\begin{restatable}{corollary}{maincor}\label{cor:main}
There exists $\eta<1$, such that for all $s$ there is a robust parameterized subexponential algorithm solving \FVS in time $2^{\TO \left (s^{\O(1)}k^{\eta}\right )}n^{\O(1)}$ for $n$-vertex $s$-string graphs.
\end{restatable}


\begin{restatable}{corollary}{maincortwo}\label{cor:main2}
There exists $\eta<1$, such that there is a robust parameterized subexponential algorithm solving \FVS in time $2^{k^{\eta}}n^{\O(1)}$ for $n$-vertex pseudo-disk graphs.
\end{restatable}

Observe that the two corollaries above encompass a wide range of classes of geometric intersection graphs for which subexponential parameterized algorithms have been given in previous work such as planar graphs, map graphs, unit-disk graphs, disk graphs, or more generally pseudo-disk graphs, and string graphs of bounded edge-degree. In this sense our main result unifies the previous algorithms.

Also, it captures new natural classes such as segment graphs, or more generally $s$-string graphs, where previous tools were unsuitable (as discussed in \autoref{sec:techniques}). We point out that before this work, the existence of subexponential parameterized algorithm for \FVS was open even for the very restricted class of $2$-DIR graphs.

Generality has a cost and the running time bound we obtain for pseudo-disk graphs
is worst than the one obtained in \cite{FVS-WG}, which heavily relied on the input pseudo-disk representation. 
On the other hand our algorithm has the extra property of being robust (i.e., it does not require a geometric representation) which is a relevant advantage for those classes of intersection graphs where computing a representation is difficult.


\subsection{Basic notations and organisation of the paper}\label{subsec:basic}
In this paper logarithms are binary and all graphs are non-oriented and simple.
Unless otherwise specified we use standard graph theory terminology, as in \cite{diestel2005graph} for instance. For a graph $G$, and $v\in V(G)$, we denote $N_G(v)$ the neighbors of $v$. We omit the subscript when it is clear from the context. For $A\subseteq V(G)$, we use the notation $N(A)=\left(\cup_{v\in A}N(v)\right)\setminus A$ and denote $G[A]$ the subgraph induced by $G$ on $A$. For $v\in V(G)$ and $B\subseteq V(G)$, we denote $N_B(v)=N(v)\cap B$ and for $A\subseteq V(G)$ we denote $N_B(A)=N(A)\cap B$, with the additional notation $d_B(A)=|N_B(A)|$. For a graph $H$ we say that $G$ is $H$-free if $H$ is not a subgraph of $G$.
Two disjoint vertex subsets or subgraphs $Z,Z'$ of a graph $G$ are said to be \emph{non-adjacent} (in $G$) if there is no edge in $G$ with one endpoint in $Z$ and the other in $Z'$.


\paragraph{Organisation.}
In \autoref{sec:techniques} we explain why the approaches developed for other intersection graph classes in the papers \cite{Faster2023Shinwoo,baste2022contraction,FVS-WG,lokSODA22} do not apply here and present the main ideas behind our algorithm. 
 \autoref{sec:algo} and \autoref{sec:analysis} are devoted to the description and analysis of the algorithm. In \autoref{sec:applications} we provide applications of our main theorem by showing in particular that $s$-string graphs are nice.  Finally, in \autoref{sec:ccl} we discuss open problems and possible extensions of the approach developed here.


\section{Our techniques}
\label{sec:techniques}

\subsection{Why bidimensionality fails and differences with classes of ``fat'' objects}
Even if our goal is to abstract from a specific graph class, let us consider in this section the class of $2$-DIR graphs, corresponding to the intersection graphs of vertical or horizontal segments in the plane. As these objects are non ``fat''\footnote{A regions $R$ of the plane is said to be \emph{$\alpha$-fat} if the radius of smallest disk enclosing $R$ is at most $\alpha$ times larger than the radius of the largest disk enclosed in $S$. A family of regions of the plane is then said to be \emph{fat} if there exists $\alpha$ such that all the elements of the family are $\alpha$-fat.} and can cross (unlike pseudo-disks), this class constitute a good candidate to exemplify the difficulty.

A common approach is as follows.
Given an instance $(G,k)$ of \FVS, we compute first in polynomial time a $2$-approximation, implying that we either detect a no-instance, or define a set $M$ with $|M|\le 2k$ and such that $G-M$ is a forest.
The goal is now to reduce, using kernelization or subexponential branching rules, to an equivalent instance $(G',k')$ with small treewidth $\tw(G')=k^{1-\eps}$. As \FVS can be solved in $\tw(G')^{\tw(G')}n^{\O(1)}$ using a classical dynamic programming approach, we get a subexponential parameterized algorithm.
Thus, one has to find a way to destroy in $G$ the obstructions preventing a small treewidth.
A first type of obstructions is $K_r$ and $K_{r,r}$, which are easy to handle as there are folklore subexponential branchings when $r=k^{\eps}$.
Now, one can see the hard part is destroying $K_{r,r}$
hidden (as a minor for example) (see \autoref{fig:introKrr}). 

\begin{figure}[!ht]
    \centering
    \includegraphics[width=\textwidth]{img/grid_counterexamplev2.pdf}
    \caption{Example of a $K_{r,r}$ contained as a minor for $r=4$ in a disk graph (left) and a $2$-DIR graph (right). In the case of disk graph, $v$ has a matching of size $r-2$ in its neighborhood, forming a triangle bundle, which can be exploited to branch. The set $M$ are depicted in blue. For the $2$-DIR graph, the vertices of the long paths are represented by segments with small variation in their height and not intersecting for better clarity, but are in fact on the same level and intersecting. }
    \label{fig:introKrr}
\end{figure}

A point that seems crucial to us is the following.
In intersection graphs of ``fat objects'' (like disks, squares, or pseudo-disks more generally), 
the ``locally non planar structure'' when an object (vertex $v$ in \autoref{fig:introKrr}) is ``traversed'' (by $v_1$, $v_2$ in \autoref{fig:introKrr})
comes to the price of an edge ($\{v_1,v_2\}$) in the neighborhood of $v$.
Thus, the presence of a large $K_{r,r}$ as a minor implies that a large matching $E_v$ (of size $\Omega(r)$) will appear in the neighborhood of a vertex $v$.
However, as $G[\{v\} \cup E_v]$ (called a triangle bundle in \cite{Lokshtanov23Approx}) contains $r$ triangles identified on vertex $v$, the set $\{v\} \cup E_v$ is a good structure to perform a subexponential branching for \FVS. Indeed, \cite{lokSODA22} proposed a ``virtual branching'' to handle this structure by either taking $v$ in the solution, or absorbing $E_v$ in $M$, implying then that the parameter virtually decreases by $|E_v|$ as a solution which does not contain $v$ has to hit all these edges, even if we cannot branch to determine which are exactly the vertices in the solution.

Once no more virtual branching is possible on large triangle bundles, they obtain by some additional specialized techniques that any vertex in $M$ is such that $N_{V(G)\setminus M}(v)$ is an independent set. Then, it is proved (~\cite{lokSODA22}, Corollary 1.1) that in a disk graph where for any $v \in M$, $N_{V(G)\setminus M}(v)$ is an independent set, and where there does not exist a vertex in $V(G) \setminus M$ whose neighborhood is
contained in $M$, then $\tw(G)=\O\left(\sqrt{|M|}\omega(G)^{2.5}\right)$, where $\omega(G)$ denotes the maximum size of a clique in $G$. This no longer holds for $2$-DIR: the family of pairs $(G,M)$ depicted on the right of \autoref{fig:introKrr} is indeed a counter example as they respect the conditions, have $\omega(G)=2$, but $\tw(G)=\Omega(|M|)$.

More generally, the role of the size of a matching in the neighborhood was studied in~\cite{berthe24ASQGM} which shows how subexponential parameterized algorithms can be obtained for graph classes having the ``almost square grid minor property'' (ASQGM), corresponding informally\footnote{In the correct definition $\mu_N(G)$ is replaced by a slightly more technical parameter.} to $\tw(G) = \O(\omega(G)\mu_N(G)\grid(G))$ where $\mu_N(G)$ is the maximum size of a matching in a neighborhood of a vertex, and $\grid(G)$ is the largest size of a grid contained as a minor in $G$.
The previous counter example shows that $2$-DIR does not have the ASQGM property, implying that we need another approach to handle them.

\subsection{A simpler case study: when trees are only paths}\label{sec:intro:paths}
To simplify the arguments, but still understand why properties in \autoref{def:prop} of a nice graph class are needed, let us assume that the forest $G-M$ only contains paths $(P_i)_i$.
This case remains challenging as a large $K_{r,r}$ can still be hidden as a minor (as in \autoref{fig:introKrr}), and we need to destroy it. 
To keep notations simple, we use the notation $\poly(.)$ to denote a polynomial dependency on the parameter, and thus we do not try to compute tight formulas depending on the polynomial $f_1,f_2,f,d$ given in the definition of a nice class.
We assume that we performed folklore branching and that we are left with a $K_{r,r}$-free graph $G$ for $r=k^{\eps}$.
It is known for string graphs (and thus $2$-DIR) that in this case $\tw(G)=  \poly(k^{\eps})n^{1/2}$ (corresponding to \autoref{def:prop:tw} of the definition of nice). Thus, our goal is to reduce $|V(G)\setminus M|$ to $\O(k^{2-\eps'})$ for some $\eps'$ while keeping $|M|=\poly(k^{\eps})k$ as it implies $\tw(G)=o(k)$.
A first obvious rule is to iteratively contract edges of the $P_i$'s whose endpoints have no neighbors in $M$. This explains the property of \autoref{def:prop:deg2} of the definition of nice. (Actually, we could only require that paths with internal vertices of degree 2 can be replaced with bounded size path without leaving the class, which could be useful for dealing with parity-constrained problems such as OCT.)

Let us now explain how property of \autoref{def:prop:nc} (bounded tree neighborhood complexity, abbreviated bounded T-NC) allows to obtain the following ``degree-related size property'': for any subpath $P$ of a $P_i$, $|P| \le \poly(r)(d_M(P)^{\alpha+1})$. Define an independent set $\mT$ of size $|P|/2$ by picking every second vertex in $P$. According to the definition of bounded T-NC (\autoref{def:NCtrees:item1}) with $A=N_M(P)$, we get
$|\{N_M(v),~v \in \mT \}| \leq f_1(r) (d_M(P))^{\alpha}$. Thus, if $|P| \ge x \cdot f_1(r) (d_M(P))^{\alpha}$, we found $x$ vertices in $P$ having the same neighborhood $M'$ in $M$, and thus a vertex $u \in M'$ adjacent to $x$ vertices in $P$. 
If $x$ is large enough (about $d_M(P)$), it is always better to take any arbitrary vertex $u \in M'$.
This leads to a kernelization rule (corresponding to \ruleref{rl:neighborhood}): if there is a vertex $u \in M$ adjacent to approximately $d_M(P)$ vertices in a subpath $P$, take $u$ and decrease $k$ by one.
To sum it up, after applying this rule, for any subpath $P$ of a $P_i$, if we have $d_M(P)=\poly(r)$, then $|P|=\poly(r)$.

Before the next step we need to apply the following ``large degree rule'' (corresponding to \ruleref{rl:big}): if there is a vertex $v$ in a $P_i$
such that $d_M(v) > t$, then add $v$ to $M$.
One can prove that by taking $t=2d_r$, with $d_r=\poly(r)$ the constant defined in \autoref{def:prop:sparse} of the definition of a nice class, $M$ does not grow too much after applying this rule exhaustively: by denoting $A\subseteq M$ the set of vertices already in $M$ previously added by this rule, we always have $|A|=\poly(r)|M\setminus A|$. This claim will be discussed in \autoref{ssec:path2tree}.

Observe that at this stage we may still have large $K_{r,r}$ as minor, with for example graphs as in \autoref{fig:introKrr} where no rule applies.
It remains to define a crucial rule to destroy these $K_{r,r}$.
Let us now present the analogue of the \algopart of \autoref{sssec:partition-algo} that partitions the $P_i's$ as follows.
For any connected component $P_i$ in $G-M$, we start (see \autoref{fig:introPart}) from an endpoint of $P_i$ and collect greedily vertices until we find a subpath $P_i^1$ such that $d_M(P_i^1) \ge t$, or that there is no more vertices in $P_i$. If $d_M(P_i^1) \ge t$, then restart a new path starting from the next vertex to create $P_i^2$, and so on.
This defines a partition $P_i=\bigcup_{\ell \in [x(P_i)]}(P_i^\ell)$, where $d_M(P_i^\ell) \ge t$ for any $\ell \in [1,x(P_i)-1]$ and no lower bound for $d_M\left(P_i^{x(P_i)}\right)$.
As we applied the large degree rule, we also know that $d_M(P_i^\ell) \le 2t$ for any $\ell \in [1,x(P_i)]$, because collecting at each step a new vertex in the path $P_i^\ell$ can increase $d_M(P_i^\ell)$  by at most $t$.
This implies, using the degree-related size property introduced above, that $|P_i^\ell| \le \poly(r)$ for any $\ell \in [1,x(P_i)]$.
Let us denote $\mT^+$ the set of $P_i^\ell$ such that $d_M(P_i^\ell) \ge t$ the ``large-degree subpaths''. Observe that the last considered subpath $P_i^{x(P_i)}$ of each connected component $P_i$ (on the right of each path of $G-M$ in \autoref{fig:introPart}) may have $d_M\left(P_i^{x(P_i)}\right)<t$ as there was no more vertices to complete it, hence it is not contained in $\mT^+$. We denote  $\mT^-$ those remaining ``small-degree subpaths''.


\begin{figure}[!ht]
    \centering
    \includegraphics[scale=1.2]{img/decompose.pdf}
    \caption{Example of partition where $P_i$ is partitioned into $x(P_i)=3$ subpaths, with $P_i^1$ and $P_i^2$ in $\mT^+$ and $P_i^3 \in \mT^-$.}
    \label{fig:introPart}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=1.2]{img/K44.pdf}
    \caption{Example of $\KttTilde$ for $t=4$. Here we have $X\subseteq N_M(T_i)$ for $1\leq i \leq 4$.}
    \label{fig:introKtttilde}
\end{figure}


Let us now explain how the bounded T-NC property (\autoref{def:NCtrees:item2}) allows to obtain 
the following ``small number of large-degree subpaths'' property. By removing half of the $\mT^+$'s, we can get a set $\mT^{+'}$ of non-adjacent trees (meaning with no edge between the $T_i's$) such that $|\mT^{+'}|\geq \frac 12|\mT^+|$. We can then apply the T-NC property with $A=M$, $\mT=\mT^{+'}$ and $p=m=\poly(r)$ to obtain
$|\{N_M(T),~T \in \mT^{+'} \}| \leq \poly(r)|M|$.
Thus, if $|\mT^{+'}| \ge x \cdot \poly(r)|M|$, we found $x$ large-degree subpaths (denoted $T'_i$) having the same neighborhood $X'$ in $M$ with $|X'|\geq t$.  By choosing $x=t$ and considering $X\subseteq X'$ with $|X|=t$, we found a structure that we call a $\KttTilde$ (see \autoref{fig:introKtttilde}), formally defined as a pair $\left(X, (T_i)_{1\leq i \leq t}\right)$ where
\begin{itemize}
    \item $X\subseteq M$ has size $t$, 
    \item  $(T_i)_i$ a family of $t$ vertex-disjoint non-adjacent subtrees (paths here) of $G - M$ such that for all $1\leq i \leq t$, $X\subseteq N_M(T_i)$, and
    \item for any $T_i$, $|T_i| \le \poly(r)$.
\end{itemize}
Now, inspired by the ``virtual branching rule'' for a triangle bundle, we introduce a branching rule (corresponding to \ruleref{rl:KrrTilde}) that either takes almost all vertices in $X$, or absorbs by adding to $M$ a subset of $t-1$ of the $T_i's$. The complexity behind this rule is fine, as in the second branch, the parameter virtually decreases by $t-1$, and $M$ grows by $(t-1)\max_i\{|T_i|\} = \poly(r)$.
This explains how we deal with $K_{t,t}$ hidden as a minor.

Finally, if this $\KttTilde$ rule cannot be applied, it remains to bound $|V(G) \setminus M|$. 
Recall that any $P \in \mT^+ \cup \mT^-$ is such that $|P| \le \poly(r)$, and thus we only need to bound $|\mT^+ \cup \mT^-|$.
As we cannot apply the previous rule, we know that the number of big paths is small: $|\mT^+| \le \poly(r)|M|$. Now, to bound 
$|\mT^-|$, observe that we can partition $\mT^-=\mT^-_1 \cup \mT^-_2$, where
\begin{itemize}
    \item $\mT^-_1$ is the set of small-degree paths $P_i^\ell$ for some $\ell > 1$ (belonging to the same path $P_i$ than a large-degree path $P_i^{\ell-1}$).
    \item $\mT^-_2$ is the set of small-degree path which is an entire connected component of $G-M$.
\end{itemize}
As $|\mT^-_1| \le |\mT^+|$, it only remains to bound $|\mT^-_2|$.
Now, we can exploit once again the bounded T-NC  property (\autoref{def:NCtrees:item2}) to obtain that, if 
$|\mT^-_2| \ge x\cdot \poly(r)|M|$, then we can find
 $x$ disjoint non-adjacent paths in $\mT^-_2$ having the same neighborhood $X$ in $M$.
 This case is different from the $\KttTilde$ case as $X$ may be arbitrarily small (we only know that $|X|< t$), and thus unlike $\KttTilde$ this does not allow to decrease the parameter by a large amount. However, in this case, paths of $\mT^-_2$
 are just connected components, and this help us to add a last rule (\ruleref{rl:same_neighborhood_prime}) that identifies a ``redundant'' path that can be safely removed. It can be shown that such a redundant path can be found just by taking $x=t+2$. Hence after applying the rule exhaustively we can assume $|\mT^-_2|<x\cdot \poly(r)|M|=\poly(r)|M|$.
 
 This concludes the proof for this restricted setting where the connected components of $G-M$ are paths, as we obtain by taking $\eps$ small enough
 $|V(G)\setminus M| \le \poly(r)|M| \le \poly(k^{\eps})k= \O(k^{2-\eps'})$ as required.
 
 \subsection{Challenges to lift the result from paths to trees}\label{ssec:path2tree}
 We now consider the real setting where given $(G,k)$ where $G$ is $K_{r,r}$-free for $r=k^\eps$, and given $M$ a feedback vertex set of size at most $2k$, we want to reduce the graph to obtain $|V(G)\setminus M|= \O(k^{2-\eps'})$. The approach still consists in partitioning $G-M$ in an appropriate way (called a $t$-uniform partition).
 
 
 A first problem when trying to adapt the approach of \autoref{sec:intro:paths} is the degree-related size property. Indeed, after the first two sections \autoref{sec:propertiesKernelized} and \autoref{sec:bigT}, we are now only able to obtain that for any subtree $T$ of $G-M$,  $|T| \le \poly(r)\mu(T)^{\O(\alpha)}$ where $\mu(T)=\max(d_M(T),\bom(T))$ and $\bom(T)=|\{v\in T,~N(v) \not\subseteq M\cup T \}|$ is the size of the ``border of $T$''.  Observe that $\bom(P)$ is at most $2$ for any subpath $P$ of path $P_i$, whereas $\bom(T)$ can only be bounded by $|T|$ for a subtree $T$.
 Informally, in the path case $|P|$ was only polynomially dependent on $d_M(P)$, and now
 $|T|$ is also polynomially depends on $\bom(T)$.
 
 A second problem is the large degree rule. 
 Suppose that this rule no longer applies (meaning that for every $u\in V(G-M)$, we have $d_M(u)\leq t$), and suppose now that because of another rule a vertex $v \in V(G)\setminus M$ is added to $M$, denoting $M'=M \cup \{v\}$. Then this can create a new large degree vertex 
 $v'$ with $d_{M'}(v')>t$ (and so $d_{M}(v') = t$). Then $v'$ would need to be added and the problem may arise again for another vertex $v''$. This ``cascading'' can easily be prevented if $G-M$ is a forest of paths: it suffices to apply the rule a first time at the start of the algorithm, but with $t'=t-2$. We then have for each $v\in V(G-M)$ the bound $d_M(v)\leq t-2$, and we do not need to applies the rule again after as adding vertices to $M$ may increase $d_M(v)$ by at most $2$ ensuring the wanted bound $d_M(v)\leq t$ for $v\in V(G-M)$.
 However, in the case of a tree, we can have in $G-M$ a vertices of arbitrarily large degree, so we cannot apply the same solution.
 The problem is treated with the help of a technical lemma (that we prove at the end of the proof, see \autoref{lm:sizeM}) which ensures that throughout the execution of the algorithm we keep $|M|=\poly(r)k$.
 
 Finally, a third problem is the definition of the partition. As in the case of paths we want to partition $G-M$ into a ``$t$-uniform partition'' $\mT$, where in particular we have $\mT=\mT^+ \cup \mT^-$, and for any $T \in \mT$, $d_M(T)\le 2t$ and $|T|\leq \poly(r)\mu(T)^{\O(\alpha)}$ (see \autoref{def:unif} for the complete definition).
 The greedy approach presented for the case of paths is now more involved, as we have to cut each tree of $G-M$ into subtrees that have small border $\bom(T)$, as otherwise the previous bound $|T| \le \poly(r)\mu(T)^{\O(\alpha)}$ becomes useless when $\mu(T)$ is too large.
 
 This partitioning procedure is defined in \autoref{sssec:partition-algo}. 
 It can either: 
 \begin{itemize}
     \item Fail and find a subtree $T$ with $|T|>\poly(r)\mu(T)^{C\alpha}$ for some constant $C$, implying that our degree-related size rule can be applied.
     \item Fail and find too many subtrees $T_i \in \mT^+$ with large degree, implying that we found a $\KttTilde$, and that our $\KttTilde$ rule can be applied.
     \item Produce a $t$-uniform partition with $|\mT^+| \le \poly(r)|M|$.
 \end{itemize}
 The third case is treated in \autoref{ssec:step4}, where we either find another way to apply one more time a reduction rule, or prove that $|V(G)\setminus M|= \O(k^{2-\eps'})$.
 

\section{FVS in subexponential FPT time in nice graph classes}\label{sec:algo}




\subsection{Preliminary branching to remove \texorpdfstring{$K_{r,r}$}{Krr}}\label{ssec:Krr_branch}
To avoid confusion, we refer to the initial instance with $(G_0,k_0)$. In this section we use a folklore branching for \FVS to remove the large bicliques $K_{r,r}$, where $r=k_0^{\eps}$ with $\eps$ to be set later depending on the considered graph class $\G$.
Before performing any branching, we compute a 2-approximation of a minimum feedback vertex set of $G_0$ using the following result, and denote it by~$M_0$.
\begin{theorem}[\cite{2approx-fvs-1,2approx-fvs-2}]\label{th:fvsapprox}
    A $2$-approximation of a minimum feedback vertex set can be constructed in polynomial time.
\end{theorem}
If $|M_0|\le k_0$ or if $|M_0|> 2k_0$ we can conclude that the instance is positive or negative. We thus are left with the case where $k_0 < |M_0| \le 2k_0$.




Let us now describe a branching algorithm starting with $(G_0, k_0, M_0)$ (with  $M_0$ is a feedback vertex set of $G_0$ with $|M_0|\le 2k_0$) and leading to a set of instances $\I$, whose properties are discussed below.
The algorithm initializes $\I$ to $\{(G_0, k_0, M_0)\}$ and applies the following branching rule to the elements of $\I$ as long as possible.

\begin{enumerate}[label=(\BR{{\arabic*}})]
\setcounter{enumi}{0}
\item \label{rl:Krr} Given an instance $(G, k, M)\in \I$, if $G$ contains a $K_{r,r}$-subgraph with parts $A$ and $B$, we replace this instance by $2r$ instances $(G -  X, k-(r-1), M\setminus X)$, for any set $X$ of size $r-1$ that is either contained in $A$, or contained in $B$.
\end{enumerate}
\begin{remark}
  If the parameter $k-(r-1)$ is negative, then this instance is negative and we remove it from $\I$.
\end{remark}
\begin{lemma}\label{lem:findkrr}
   There is a  $2^{\O\left (r\log |M| \right )}|V(G)|^{\O(1)}$-time algorithm that, given an instance $(G, k, M)\in \I$, applies rule~\ruleref{rl:Krr} or correctly concludes that $G$ is $K_{r,r}$-free.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 0}\end{proof}

We summary the properties obtained after this series of branchings with the following lemma:
\begin{lemma}\label{lem:step2}
    At the end of the preliminary branching, the set $\I$ satisfies the properties:
    \begin{enumerate}
        \item The instance $(G_0, k_0)$ is a YES-instance if and only if $\I$ contains a $YES$-instance.
        \item For any $(G,k,M)\in \I$ the graph $G$ is $K_{r,r}$-free induced subgraph of $G_0$.
        \item For any $(G,k,M)\in \I$, $M$ is a feedback vertex set of $G$ with $|M|\leq 2k_0$.
        \item The total time to generate $\I$ is in $2^{\O\left (r\log k_0 \right )}|V(G_0)|^{\O(1)}(2r)^{\frac{k_0}{r-1}}$
        and $|\I|=\O\left((2r)^{\frac{k_0}{r-1}}\right)$.
    \end{enumerate}
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 1}\end{proof}







\subsection{The main recursive algorithm}\label{ssec:step3}
We now consider each element $(G_i,k_i,M_i)$ of  $\I$ as an instance $(G_i,k_i,M_i,\emptyset)$ of the following problem \AFVS, and our goal now is to solve these instances of \AFVS using our main recursive \autoref{algo:A}.
\begin{definition}\label{def:afvs}
    Given a nice graph class $\G$ and $r>3$, the \afvs problem (\AFVS{} for short) is the decision problem 
    where given $(G, k, M, \mH)$ where $G$ is a $K_{r,r}$-free graph of $\G$, $k$ an integer, $M\subseteq V(G)$ a feedback vertex set of $G$, and $\mH$ a family of connected disjoint subsets of $M$ (meaning that for any $H \in \mH$, $G[H]$ is connected) such that $|\mH| \le k$,
    and where the question is whether there exists a feedback vertex set $S$ of $G$ of size at most $k$ that additionally intersects every set of $\mH$.
\end{definition}

For the sake of completeness we provide here the complete pseudo-code of \autoref{algo:A}, even if it uses rules and subroutine which will be defined later. At this stage, we recommend the reader to only read the following sketch, as the following sections will cover in detail the properties we obtain after each step.
The sketch of \autoref{algo:A} is as follows. We first try to apply (line \ref{A:firstIf}) rules~\ruleref{rl:deg1}, \ruleref{rl:deg2}, \ruleref{rl:big}, and \ruleref{rl:same_neighborhood_prime},  which are like kernelization rules: given the instance $(G,k,M,\mH)$ we perform a single recursive call on a slightly simpler instance $(G',k',M',\mH')$. 
 If none of these first rules apply, the algorithm tries to build a special partition of $G-M$ using the \algopart{}.
 If \algopart fails (line \ref{A:case1} or \ref{A:case2}) and fall into what we call Case 1 or Case 2, then we apply a kernelization or branching rule.
 Otherwise we either apply \ruleref{rl:same_neighborhood_prime} or \ruleref{rl:neighborhood} (line \ref{A:KR4} or line \ref{A:KR5}), or reach our final point (line \ref{A:DP}) where we can prove that $|V(G)|$ is small, implying that $\tw(G)=o(k)$, and solve the instance using a classical DP algorithm.
 

\begin{algorithm}
\caption{$A(G,k,M,\mH)$}
\begin{algorithmic}[1]
    \Require $(G,k,M,\mH)$ an instance of \AFVS.
    \If{(one of Rule \ruleref{rl:deg1}, Rule \ruleref{rl:deg2}, Rule \ruleref{rl:big}, or Rule \ruleref{rl:same_neighborhood_prime} applies on $(G,k,M,\mH)$)} \label{A:firstIf}
         \State Apply the first possible Rule to obtain $(G', k', M',\mH')$ 
        and \Return $A(G',k',M',\mH')$
    \EndIf
    \State Apply \algopart (with $t=2d_r$) of \autoref{lem:construct-red-trees} that tries to build $\mT$: a $t$-uniform partition of $G-M$ with $|\mT^+| \le p_3(r,t)|M|$ (where $p_3$ is defined in \autoref{lm:bigreduce}) \label{A:partition}
    \If{(procedure fails and falls into Case 1 (output a large subtree $T$))} \label{A:case1}
        \State Apply Rule \ruleref{rl:neighborhood} on $T$ to obtain $(G', k', M',\mH')$
        and \Return $A(G',k',M',\mH')$
    \EndIf
    \If{(procedure fails and falls into Case 2 (output a $\KttTilde$))} \label{A:case2}
        \State Apply the branching Rule \ruleref{rl:KrrTilde} on this $\KttTilde$, generating a set $\mathcal C$ of instances
        \State \Return $\bigvee_{(G',k',M',\mH') \in \mathcal C}A(G',k',M',\mH')$
    \EndIf
    \State // $\mT$ is as required  \label{A:partOK}
    \State Let $Z_1(\mT)$ and $Z_2(\mT)$ as defined in \autoref{def:Z}, and $\tilde{M}=M \cup Z_1(\mT) \cup Z_2(\mT)$
    \State // By \autoref{lm:special}, Rule \ruleref{rl:deg1} and Rule \ruleref{rl:deg2} do not apply on $(G,k,\tilde{M},\mH)$
    \If{(Rule \ruleref{rl:same_neighborhood_prime} applies on $(G,k,\tilde{M},\mH)$, and finds a subtree $T$ that can be removed)}\label{A:KR4}
    \State\Return $A(G-T,k,M,\mH)$
    \EndIf
    \If{(Rule \ruleref{rl:neighborhood} applies on $(G,k,\tilde{M},\mH)$ and a connected component $T$ of $G-\tilde{M}$, and finds a vertex $u \in \tilde{M}$ that can be taken)}\label{A:KR5}
    \State\Return $A(G-T,k-1,M\setminus \{u\},\mH-\{u\})$ 
    \EndIf

    
    \State // $|V(G)|=p_4(r,t)|M|$ by \autoref{lm:finalR4R5} implying $\tw(G)=o(|M|)$ by \autoref{th:tw}
    \State \Return $DP(G,k,M,\mH)$ \label{A:DP} // Solves the instance using \autoref{th:solveAFVS}
\end{algorithmic}
\label{algo:A}
\end{algorithm}
\newpage






\subsection{Kernelization rules}
\label{sssec:kernelization}


Here we provide the four kernelization rules  \ruleref{rl:deg1}, \ruleref{rl:deg2}, \ruleref{rl:big}, and \ruleref{rl:same_neighborhood_prime} that \autoref{algo:A} tries to apply Line \ref{A:firstIf}.
Each of these rules takes as input an instance $(G,k,M,\mH)$ of \AFVS and outputs a single instance $(G',k',M',\mH')$. Such a rule is said to be {\em safe} if:
\begin{itemize}
    \item On input an instance of \AFVS it returns an instance of \AFVS (in particular the graph of the output instance is a $K_{r,r}$-free graph in $\G$), and
    \item the input instance is a YES-instance if and only if the output instance is a YES-instance.
\end{itemize}

\paragraph{Notation}
Given any instance $(G, k, M, \mH)$, recall that every connected component of $G-M$ is a tree. We root each of them at an arbitrary vertex. We define a {\em subforest} of $G-M$ as a subset $T\subseteq V(G)\setminus M$ and say the set is a {\em subtree} of $G-M$ if $G[T]$ is a tree. Given a vertex $v$ of a connected component $T$ in $G-M$, we define the subtree $T_v$ of $G-M$ as the connected component of $v$ in $G-M-u$, where $u$ is the parent of $v$, if any. If $v$ is the root of $T$, then $T_v=T$. In any case $T_v$ is rooted at $v$.
Given $X \subseteq V(G)$, we denote 
$\mH-X = \{H \in \mH \mid H \cap X = \emptyset\}$. 
 Given a subtree $T$ of $G-M$, $\pom (T)$ denotes the set $\{v\in T,~N(v) \not\subseteq M\cup T \}$, and $\bom (T)$ denotes the size of this set.
 We also denote $\db(T)=\max(d_M(T), \bom(T))$.

We start with two basic reduction rules often used to deal with \FVS and that allow to get rid of vertices of degree 1 and arbitrarily long paths of vertices of degree 2. Notice that we only apply here the reduction to vertices in $G-M$.
\begin{enumerate}[label=(\KR{{\arabic*}})]
\item \label{rl:deg1} Given an instance $(G, k, M, \mH)$, if there exists a vertex $v\in V(G)\setminus M$ of degree $d(v)\leq 1$, output $(G-\{v\}, k, M, \mH)$.

\item \label{rl:deg2} Given an instance $(G, k, M, \mH)$, if there exists a path $quvw$ in $V(G)\setminus M$ such that the four vertices have degree $2$ in $G$ and $\dM(u)=\dM(v)=0$, output $(G', k, M, \mH)$, where $G'$ is the graph obtained from $G$ by contracting the edge $uv$.
\end{enumerate}
\begin{lemma}
    The rules \ruleref{rl:deg1} and \ruleref{rl:deg2} are safe and can be applied in polynomial time.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 2}\end{proof}
\begin{remark}
Observe that we did not use the condition in \ruleref{rl:deg2} that the endpoints of the considered path have degree at most $2$ in $G$. However it will later be used in \autoref{lm:sizeM} to bound the size of $M$ during the execution of the algorithm.
\end{remark}

The next rule ensures that the vertices outside $M$ have a small neighborhood in $M$. It increases the size of $M$, but in a controlled manner as we will see later in \autoref{lm:sizeM}. 

\begin{enumerate}[label=(\KR{{\arabic*}})]
\setcounter{enumi}{2}
\item \label{rl:big} Given an instance $(G, k, M, \mH)$, if there is a vertex $v\in V(G)\setminus M$ such that $d_M(v)\ge t=2d_r$, with $d_r$ the value defined in \autoref{def:prop}, output $(G, k, M\cup\{v\}, \mH)$.
\end{enumerate}
It is immediate that rule \ruleref{rl:big} is safe and can be applied in polynomial time.


The fourth kernelization rule will ensure that the number of neighbors outside $M$ of a vertex $v\in V(G-M)$ is strongly correlated with the size of the neighborhood of its descendants in $M$. 
Consider an instance $(G,k,M,\mH)$ where none of the previous rules applies. 
Given a family $\T$ of disjoint subtrees of $G-M$, a tree $T\in \T$ is {\em redundant} (for $\T$) if for all $v\in M$ such that $d_T(v)\geq 2$, there exists $T'\in \T$ with $T'\neq T$ such that $d_{T'}(v)\geq 2$.


\begin{lemma}\label{lm:redundant}
    Consider a set $X\subseteq M$ and a set $\T$ of subtrees of $G-M$ with $|\T|\geq|X|+1$, and such that $N_M(T)=X$ for every $T\in \T$. Then, there exists a redundant tree for $\T$, and it can be found in polynomial time.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 3}\end{proof}

Recall that we consider a fixed child-parent orientation in the forest $G-M$. In what follows, we say that a subset $F \subseteq V(G-M)$ is a \emph{downward-closed subtree} (or \emph{subforest} when the set is not necessarily connected) of $G-M$ when for any $v \in F$ and any children $u$ of $v$, $u \in F$.
The fourth kernelization rule is as follow:

\begin{enumerate}[label=(\KR{{\arabic*}})]
\setcounter{enumi}{3}
\item \label{rl:same_neighborhood_prime} Given an instance $(G, k, M, \mH)$, a set $X\subseteq M$ with $|X|\geq 1$ and a set $\T$ of at least $|X|+2$ disjoint downward-closed subtrees of $G-M$ such that:
\begin{itemize}
    \item for all $T\in \T$, we have $N_M(T)=X$, and
    \item either all the roots of the trees in $\T$ have a common parent $r$, or $\T$ consists only in connected components of $G-M$,
\end{itemize}
arbitrarily pick one 
redundant $T\in \T$ (which exists as shown in \autoref{lm:redundant}) and output $(G - V(T), k, M, \mH)$.
\end{enumerate}

\begin{lemma}
    Rule~\ruleref{rl:same_neighborhood_prime} is safe and can be applied in polynomial time.
\end{lemma}

\begin{proof}\textcolor{red}{TOPROVE 4}\end{proof}


\begin{definition}
    Given an instance $(G,k, M, \mH)$, we say that  \ruleref{rl:same_neighborhood_prime} \emph{applies on $(G,k,M,\mH)$}
    if there exists $X$ and $\mT$ such that Rule \ruleref{rl:same_neighborhood_prime} can be applied on $(G,k,M,\mH)$, $X$ and $\mT$.
\end{definition}

Observe that in \ruleref{rl:same_neighborhood_prime}, we consider that the sets $X$ and $\mT$ are given, whereas in \autoref{algo:A} line \ref{A:firstIf}, we have to find these sets. Thus, we need the following lemma.

\begin{lemma}\label{lemma:KR4poly}
Given an instance $(G,k,M,\mH)$, deciding if Rule \ruleref{rl:same_neighborhood_prime} can applies on $(G,k,M,\mH)$ (and finding $X$ and $\mT$ if it is the case) can be done in polynomial time.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 5}\end{proof}

\subsection{Properties of the kernelized instances}\label{sec:propertiesKernelized}
The goal of this section is to prove that for an instance $(G,k,M,\mH)$ for which the kernelization rules do not apply anymore (meaning that we reach Line \ref{A:partition} in \autoref{algo:A}), the size of a subtree $T$ of $G-M$ is strongly related to $\db(T)$.  (Recall that $\db(T)=\max(d_M(T), \bom(T))$.)

Remember that because the considered graph class $\G$ is nice, it has bounded tree neighborhood complexity for some parameters $\alpha,f_1,f_2$. This implies the easy following lemma.
\begin{lemma}\label{cor:neightrivial}
For every $K_{r,r}$-free $G\in \G$, every set $A\subseteq V(G)$, and every family $\mT$ of disjoint non-adjacent subtrees of $G-A$, and every $x\in \RR$, if $|\mT|\geq xf_1(r)|A|^\alpha$ then there exists $X\subseteq A$ such that at least $x$ subtrees $T\in \mT$ satisfy $N_A(T)=X$. Moreover suppose that for every $T\in \mT$ we have $d_A(T)\leq p$ and $|T|\leq m$, then if $|\mT|\geq xf_2(r,p,m)|A|$, there exists $X\subseteq A$ such that at least $x$ subtrees $T\in \mT$ satisfy $N_A(T)=X$.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 6}\end{proof}


Recall that given a subtree $T$ of $G-M$, $\pom (T)$ denotes the set $\{v\in V(T),~N(v) \not\subseteq M\cup V(T) \}$, and $\bom (T)$ denotes the size of this set.

We are now ready to bound the degree of the subtrees of $G-M$:

\begin{lemma}\label{lem:degree-T}
Consider an instance $(G,k,M,\mH)$ of \AFVS such that neither the rule \ruleref{rl:deg1} nor \ruleref{rl:same_neighborhood_prime} applies.
For any subtree $T$ of $G- M$ and any vertex $v$ of $T$,  we have
\[
d_{T}(v)\le \O(\max(\bom(T),f_1(r)d_M(T)^{\alpha+1})).
\]
\end{lemma}


\begin{proof}\textcolor{red}{TOPROVE 7}\end{proof}


We now show that the previous rules allow to bound the size of certain types of trees that we define now.

\begin{definition}
A subtree $T$ of $G-M$ is \emph{weakly connected} to $M$ if $G[T\cup \{u\}]$ is acyclic for every $u$ in $M$ (i.e. $d_T(u)\leq 1$ for all $u\in M$).
A subtree $T$ of $G- M$, rooted at a vertex $v$, is \emph{sharp w.r.t. $M$} if $T$ is not weakly connected to $M$ but for every children $u$ of $v$, $T_u$ is weakly connected to $M$.
\end{definition}

\begin{lemma}\label{lem:weak-trees}
Consider an instance $(G,k,M,\mH)$ where none of Rules \ruleref{rl:deg1} and \ruleref{rl:deg2} applies. For any subtree $T$ in $G- M$ that is weakly connected to $M$, we have that $|T|\le \db(T)$.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 8}\end{proof}

We now consider sharp subtrees. Notice that in such a tree, $v$ has bounded degree (by \autoref{lem:degree-T}), and the subtrees below $v$ have bounded size (by \autoref{lem:weak-trees}). This leads to the following corollary.

\begin{corollary}\label{cor:sharpsize}
Consider an instance $(G,k,M,\mH)$ where none of Rules \ruleref{rl:deg1}, \ruleref{rl:deg2} and \ruleref{rl:same_neighborhood_prime} applies. Given a sharp subtree $T$ of $G-M$, we have $|T| = O\left(f_1(r)d_M(T)^\alpha\db(T)^2\right)$. 
\end{corollary}
\begin{proof}\textcolor{red}{TOPROVE 9}\end{proof}




\subsection{Kernelizing when a big tree is found.}\label{sec:bigT}
When reaching line \ref{A:partition} of \autoref{algo:A}, we call the method \algopart which tries to build a special partition of $G-M$. As we will see later, one output of this procedure is a failure (called case 1) where a ``big'' (whose size is too large with respect to $d_M(T)$ and $\bom(T)$) tree $T$ is found in $G-M$. 
In this section, we explain how we can get rid of such a big tree.


\begin{enumerate}[label=(\KR{{\arabic*}})]
\setcounter{enumi}{4}
\item \label{rl:neighborhood} Consider an instance $(G, k, M, \mH)$, with a subtree $T$ of $G-M$ which contains $d_M(T)+\bom(T)$ vertex disjoint paths of length at least $1$ and whose endpoints are all adjacent to some vertex $u\in N_M(T)$. Then output $\left(G-u, k-1, M\setminus\{u\}, \mH-\{u\}\right)$ if $k \ge 1$ (or a trivial no instance otherwise).
\end{enumerate}

\begin{lemma}
    The rule \ruleref{rl:neighborhood} is safe.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 10}\end{proof}



\begin{lemma}\label{lem:subtree-size}
There is a multivariate polynomial $p_1$ with $p_1(x,y) = \O(f_1(x) y^{6+\alpha})$ such that for every instance $(G,k,M,\mH)$ of \AFVS where none of the rules \ruleref{rl:deg1}, \ruleref{rl:deg2}, and \ruleref{rl:same_neighborhood_prime} applies, and for every subtree $T$ of $G-M$ such that the Rule \ruleref{rl:neighborhood} does not apply, we have $|T| \le p_1(r,\db(T))$.
\end{lemma}

\begin{proof}\textcolor{red}{TOPROVE 11}\end{proof}

\begin{corollary}\label{lm:boundSzT}
    Given an instance $(G,k, M, \mH)$ where none of Rules \ruleref{rl:deg1}, \ruleref{rl:deg2}, and \ruleref{rl:same_neighborhood_prime} applies, and a subtree $T$ of $G-M$ with $|T|> p_1(r,\db(T))$, Rule \ruleref{rl:neighborhood} can be applied in polynomial time on this tree.
\end{corollary}
\begin{proof}\textcolor{red}{TOPROVE 12}\end{proof}

\subsection{Branching when there is a \texorpdfstring{$\KttTilde$}{K~tt}} \label{sec:ktttilde}


When reaching line \ref{A:partition} of \autoref{algo:A}, we call the method \algopart which tries to build a special partition of $G-M$. As we will see later, one output of this procedure is a failure (called case 2) where a certain dense structure (denoted $\KttTilde$, with $t=2d_r$) is found.
In this section, we explain how we branch on such a $\KttTilde$.

This new branching rule is a variation of Rule \ruleref{rl:Krr} that was presented in \autoref{ssec:Krr_branch}: instead of dealing with $K_{r,r}$ subgraphs, we will now consider a set $A$ of $t$ vertices and a set $B$ of small trees such that contracting those trees would result in a $K_{t,t}$-subgraph. More formally:
\begin{definition}
Given an instance $(G,k,M,\mH)$ of \AFVS and an integer $t$, a $\KttTilde$ (of $(G,k,M,\mH)$) is a pair $\left(X, (T_i)_{1\leq i \leq t}\right)$ where
\begin{itemize}
    \item $X\subseteq M$ has size $t$, 
    \item  $(T_i)_i$ a family of $t$ disjoint non-adjacent subtrees of $G - M$ such that for all $1\leq i \leq t$, $X\subseteq N_M(T_i)$, and
    \item for any $T_i$, $|T_i| \le p_2(r,t)$ with $p_2(r,t)=p_1(r,2t)$.
\end{itemize}
\end{definition}



\begin{remark}\label{rmk:Ktttilde}
  Similarly to a $K_{t,t}$ subgraph, given a $\KttTilde$ with parts $(X, (T_i)_{1\leq i \leq t})$, the subgraph of $G$ induced by two vertices of $X$ and two trees of $(T_i)_i$ always contains a cycle. So a feedback vertex set of $G$ must either contain at least $t-1$ vertices of $X$, or intersects each tree of $(T_i)_i$ except at most one. 
\end{remark}
  
  
The difference between the treatment of $K_{t,t}$ and $\KttTilde$ is that, when we are in the branch where a solution must intersect each tree of $(T_i)_i$, we cannot branch in subexponential time to guess which vertex of each $T_i$ is picked, and rather perform the following ``virtual branching'' trick (introduced in \cite{lokSODA22} for the special case where $T_i$ are edges). In this branch, we add all these $T_i$ in $M$, and maintain a packing $\mH$ of such sets $T_i$. The size of the packing (and thus the growth of $M$) will be bounded by observing that $|\mH|$ is a lower bound on the solution size. 

We are now ready to define the last branching rule:

\begin{enumerate}[label=(\BR{{\arabic*}})]
\setcounter{enumi}{1}
\item \label{rl:KrrTilde} Given an instance $(G, k, M, \mH)$ and a $\KttTilde$ with parts $(X, (T_i)_i)$, we generate the following instances:
\begin{itemize}
    \item if $k \ge t-1$, then for each $v\in X$, denoting $X_{\overline{v}}=X\setminus \{v\}$, output the instance $((G-X_{\overline{v}}), k-(t-1), M\setminus X_{\overline{v}}, \mH-X_{\overline{v}})$.
    \item if $|\mH|+(t-1) \le k$, then for each $1\leq i \leq t$, denoting $R_i=\bigcup_{j\neq i}T_j$ and $\mT_{R_i}=\{T_j,~j\neq i\}$, output the instance $\left(G, k, M\cup R_i, \mH\cup \mT_{R_i}\right)$.
\end{itemize}
\end{enumerate}

\begin{lemma}
    The Rule \ruleref{rl:KrrTilde} is safe, and can be applied in polynomial time (assuming a $\KttTilde$ is provided).
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 13}\end{proof}


\subsection{Attempting to build a \texorpdfstring{$t$}{t}-uniform partition of  \texorpdfstring{$G-M$}{G-M}}
\label{sssec:partition-algo}
In this section we define the method \algopart that is called line \ref{A:partition} when \ruleref{rl:deg1}, \ruleref{rl:deg2}, \ruleref{rl:big}, and \ruleref{rl:same_neighborhood_prime} do not apply.
The algorithm will either fail (case 1) and find a ``big'' subtree $T$ that allows to apply \ruleref{rl:big} of \autoref{sec:bigT}, fail (case 2) and find a $\KttTilde$ that allows to apply \ruleref{rl:KrrTilde} of \autoref{sec:ktttilde}, or find a special partition of $G-M$ that we define now.



\begin{definition}\label{def:unif}
Let $(G,k,M,\mT)$ be an instance of \AFVS and $t$ be a positive integer.  Let $F \subseteq V(G)\setminus M$ be a downward-closed subforest of $G-M$. A family of trees $\mT$ of $G-M$ with vertices in $F$ is a \emph{$t$-uniform partition of $F$} if:
    \begin{enumerate}
    \item \label{item:unif1} Each vertex of $F$ is in exactly one tree of $\mT$.
    \item \label{item:unif2}Every $T\in \mT$ have $d_M(T)\le 2t$, $|T|\leq p_1(r,\db(T))$ (where $p_1$ is the polynomial function defined in \autoref{lem:subtree-size}) and $\mT$ is partitioned into two subsets, $\mT^-$ and $\mT^+$ such that a tree $T\in \mT$ belongs to $\mT^-$ if $d_M(T)<t$, and to $\mT^+$ otherwise.
    \item \label{item:unif3} If a root $r$ of a tree $\mT^-$ has a parent $v$ in $G-M$, then $v$ is the root of a tree in $\mT^+$.
\end{enumerate}
\end{definition}
\begin{remark}
The definition implies that there is no edges between trees of $\mT^-$.
\end{remark}
\begin{figure}
    \centering
    \includegraphics{img/uniform.eps}
    \caption{Representation of a $t$-uniform partition of a subtree $T$ of $G-M$. Here are represented only vertices of $F$ (and not vertices of $M$). Vertices of the trees in $\mT^+$ (respectively $\mT^-$) are represented in red (respectively blue), so as the edges between two vertices in the same tree of $\mT^+$ (respectively $\mT^-$). Edges between distinct trees of $\mT$ are represented in black. }
    \label{fig:uniform}
\end{figure}


Our goal is to apply the branching rule each time the procedure of \autoref{lem:construct-red-trees} end up in the \autoref{part:case2}, giving a large number of saturated trees. We prove that it can always be done, and even in polynomial time:


When \algopart tries to build a $t$-uniform partition, one case (case 2) of failure will be when $\mT^+$ becomes to large, 
and thus we show in the next lemma that in this case we can find a $\KttTilde$.
\begin{lemma}\label{lm:bigreduce}
   Consider an instance $(G, k, M, \mH)$ where none of Rules \ruleref{rl:deg1}, \ruleref{rl:deg2}, and \ruleref{rl:same_neighborhood_prime} applies,
 a downward-closed subforest $F \subseteq V(G-M)$ and a $t$-uniform partition $\mT$ of $F$ with $|\mT^+|=p_3(r,t)|M|$ for $p_3(r,t)=4tf_2(r,2t,p_2(r,t))$. 
 Then, we can find a $\KttTilde$ in polynomial time.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 14}\end{proof}
\begin{lemma}\label{lem:construct-red-trees}
Let $t$ be an integer. Consider an instance $(G, k, M, \mH)$ where none of Rules \ruleref{rl:deg1}, \ruleref{rl:deg2}, \ruleref{rl:same_neighborhood_prime} applies, and such that $d_M(v)< t$ for every $v\in V(G-M)$.
There exists a polynomial time algorithm that given $(G, k, M,\mH)$ either returns:
\begin{enumerate}
    \item \label{part:case1} a subtree $T$ of the forest $G-M$ such that Rule~\ruleref{rl:neighborhood} applies,
\item \label{part:case2} a $\KttTilde$ such that Rule~\ruleref{rl:KrrTilde} applies, or
    \item \label{part:case3} a $t$-uniform partition $\mT$ of the whole forest $G-M$ with $|\mT^+|<p_3(r,s,t)|M|$ ($p_3$ being defined in \autoref{lm:bigreduce}).
\end{enumerate}

\end{lemma}

\begin{proof}\textcolor{red}{TOPROVE 15}\end{proof}

\begin{remark}
Observe that in Line \ref{A:partition}, all required conditions listed in \autoref{lem:construct-red-trees} to use the method \algopart are fulfilled, as in particular as \ruleref{rl:big} does not apply, we get $d_M(v) \le 2d_r \le t$ for any $v \in V(G)-M$.
\end{remark}


\subsection{Final step when \texorpdfstring{$G-M$}{G-M} admits a \texorpdfstring{$t$}{t}-uniform partition with a small number of large-degree parts}\label{ssec:step4}


In this section, we consider Line \ref{A:partOK} of \autoref{algo:A} where we found a $t$-uniform partition $\mT$ as required. To bound $|V(G)|$ the algorithm moves some sets $Z_1(\mT)$ and $Z_2(\mT)$ (as defined below) to $M$ (to get a slightly larger set $\tilde{M}$ and tries to apply Rule \ruleref{rl:same_neighborhood_prime} or Rule \ruleref{rl:neighborhood} on $(G,k,\tilde{M},\mH)$.
If it not possible, we can prove that $|V(G)-M|$ is small.


\begin{definition}\label{def:Z}
    Given a $t$-uniform partition $\mT$ of $G-M$, we define the set $Z_1(\mT)$ as the roots of the trees in $\mT^+$, and $Z_2(\mT)$ as the set of vertices $v$ of $G - M$ having three edge disjoint paths $P_1,P_2,P_3$ in $G- M$ linking them to vertices of $Z_1(\mT)$.
\end{definition}

\begin{lemma}\label{lm:special}
    Given an instance $(G, k, M, \mH)$, an integer $t$, and $\mT$ a $t$-uniform partition of $G-M$, we have $|Z_1(\mT)|+|Z_2(\mT)|\leq 2|\mT^+|$, and by denoting $\tilde{M}=M\cup Z_1(\mT)\cup Z_2(\mT)$, we have the following properties:
    \begin{itemize}
        \item Rule \ruleref{rl:deg1} and Rule \ruleref{rl:deg2} do not apply on $(G,k,\tilde{M},\mH)$.
        \item A connected component $T$ of $G-\tilde{M}$ satisfies $d_{\tilde{M}}(T)\leq 2t+2$.
    \end{itemize}
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 16}\end{proof}

\begin{lemma}\label{lm:finalR4R5}
    Given an instance $(G, k, \tilde{M}, \mH)$ such that Rules \ruleref{rl:deg1}, \ruleref{rl:deg2}, and \ruleref{rl:same_neighborhood_prime} do not apply, and such that for any $T$ connected component of $G-\tilde{M}$, Rule \ruleref{rl:neighborhood} does not apply on $T$ and $d_{\tilde{M}}(T)\leq 2t+2$. Then, $|G-\tilde{M}| \le p_4(r,t)|\tilde{M}|$ with $p_4(r,t)=(2t+4)f_2(r,2t+2,p_1(r,2t+2))$.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 17}\end{proof}

\begin{lemma}\label{lm:sizeGMinusM}
Let $(G,k,M,\mH)$ be an input of \AFVS.
If $A(G,k,M,\mH)$ reaches Line \ref{A:DP}, 
then $|G-M|=\O(p_3(r,t)p_4(r,t)|M|)$.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 18}\end{proof}

Let us now bound the size of $M$ in any call to $A(G,k,M,\mH)$ by providing invariants on the input of \autoref{algo:A}.
Informally, $|M|$ can be bounded as follows.
Recall that we perform our first call with $A(G_i,k_i,M_i,\emptyset)$ where $(G_i,k_i,M_i) \in \I$ and $M_i \subseteq M_0$, with $|M_0| \le 2k_0$.
Then, if we follow any path in the tree of calls whose root is $A(G_i,k_i,M_i,\emptyset)$, we may add some vertices to $M$ because of \ruleref{rl:big}, let denote $A_1$ those vertices, or because of \ruleref{rl:KrrTilde}, we denote $A_2$ those vertices. On a given branch the rule \ruleref{rl:KrrTilde} add at most $k_0$ trees of size at most $p_2(r,t)$ so $|A_2|\leq k_0p_2(r,t)$. Remains to bound the vertices of $A_1$. Observe that when a vertex $v$ is added to the set $M$ because of \ruleref{rl:big} (and so to $A_2$) we have $d_M(v)\geq 2d_r$, and so the number of edges in the graph $G[M]$ increases by at least $2d_r$. We may think that as we have at most $d_r|M|$ edges in $G[M]$, we obtain $2d_r|A_2|\leq d_r|M| \leq d_r(|M_0|+|A_1|+|A_2|)$ which gives a bound on the size of $A_1$. However this reasoning is flawed as we needed to consider all the vertices added to $M$, even the one deleted because of \ruleref{rl:neighborhood}. But then in the supergraph of $G'$ containing those vertices they may be some vertices obtained after contraction of edges by \ruleref{rl:deg2}, which were not of degree $2$ in their current supergraph considering deleted vertices. So this supergraph may not be in $\G$, and in fact may even contains a $K_{r,r}$ as subgraph. So a more technical analysis is needed to bound the size of $M$.

\begin{lemma}\label{lm:sizeM}
For any input $(G,k,M,\mH)$ of \autoref{algo:A}, we have $|M|=\O(k_0p_5(r,t))$ with $p_5(r,t)=4+2p_2(r,t)$.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 19}\end{proof}

Using \autoref{lm:sizeGMinusM} and \autoref{lm:sizeM}, the following corollary is now immediate.

\begin{corollary}\label{lm:sizeG-end}
Let $(G,k,M,\mH)$ be an input of \AFVS.
If $A(G,k,M,\mH)$ reaches Line \ref{A:DP},
then $|V(G)|=\O(k_0p_6(r,t))$ where $p_6(r,t)=p_3(r,t)p_4(r,t)p_5(r,t)$.
\end{corollary}

\section{Complexity analysis}\label{sec:analysis}

\subsection{Complexity of the DP in the base case of \autoref{algo:A}}
Let us first describe how \autoref{algo:A} solves an instance  $(G, k, M, \mH)$ using dynamic programming when no rule applies (DP in the Line \ref{A:DP}). Recall that by definition of \AFVS, $G$ is a $K_{r,r}$-free graph from a nice graph class $\G$, and $\mH$ a family of disjoint subsets of $M$, with each $H\in \mH$ inducing a connected graph in $G$. 



\begin{theorem}[\cite{Cygan2015Book}]\label{th:solveAFVS}
    An \AFVS instance $(G, k, M, \mH)$ with $G$ an $n$-vertex graph can be solved in time $\tw(G)^{\O(\tw (G))}n^{\O(1)}$.
\end{theorem}
\begin{proof}\textcolor{red}{TOPROVE 20}\end{proof}

\begin{corollary}\label{cor:DP}
Let $(G,k,M,\mH)$ be an input of \AFVS.
If $A(G,k,M,\mH)$ reaches Line \ref{A:DP} and calls
$DP(G,k,M,\mH)$, then the worst case running time of $DP(G,k,M,\mH)$ is  $\tdp(k_0,r,t)=2^{\O\left(k_0^{\delta}p_7(r,t)\right)}$ with $p_7(r,t)=f_r\log (f_rk_0p_6(r,t))(p_6(r,t))^{\delta}$.
\end{corollary}
\begin{proof}\textcolor{red}{TOPROVE 21}\end{proof}

\subsection{Complexity of \autoref{algo:A}}
Informally, the complexity of \autoref{algo:A} is dominated by the only branching rule (\ruleref{rl:KrrTilde}). The appropriate parameter $\alpha$ associated to an instance $(G,k,M,\mH)$ is $\alpha=k+(k-|\mH|)$, as informally $\mH$ is a packing of hyperedges that we have to hit, and thus $|\mH|$ is a lower bound of the cost of any solution. Thus, if $p(n)$ is the (polynomial) complexity of all operations performed in one call of \autoref{algo:A}, and $f(n,\alpha)$ is the worst complexity of \autoref{algo:A} when $|V(G)|=n$ and $\alpha=k+(k-|\mH|)$, \ruleref{rl:KrrTilde} leads to $f(n,\alpha) \le p(n)+(2t)f(n,\alpha-(t-1))$, leading to $f(n,\alpha) \le p(n)(2t)^{\frac{2k-h}{t-1}}$.


\begin{lemma}\label{lm:complexityA}
Given an input $(G,k,M,\mH)\in \I$ with $G$ a $n$-vertex graph, $A(G,k,M,\mH)$ runs in time
$$\tdp\left(k_0,r,t\right)(2t)^{\frac{2k}{t-1}}n^{\O(1)}$$ where $\tdp$ is defined in \autoref{cor:DP}.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 22}\end{proof}

Let us now bound the running time of the main algorithm (that branches to create the family of instances $\I$ and runs \autoref{algo:A} on each instance).
\begin{main-thm}
For every nice hereditary graph class $\mathcal{G}$ there is a constant $\eta<1$ such that FVS can be solved in $\mathcal{G}$ in time $2^{k^\eta}\cdot  n^{\O(1)}$.

\end{main-thm}
\begin{proof}\textcolor{red}{TOPROVE 23}\end{proof}



\section{Applications}\label{sec:applications}
In this section, we prove that $s$-string graphs and pseudo-disk graphs are nice graph classes for some parameters. We recall that a system of pseudo-disks is a collection of regions in the plane homeomorphic to a disk such that any two of them share at most 2 points of their boundary.
Similar arguments are used for both considered classes, but in the case of pseudo-disks the arguments are a bit simpler, we then consider this class in first.

 In order to give bounds on tree neighborhood complexity we will use the following theorem.
 
 \begin{theorem}[\cite{pseudodisjoint}]\label{hyperpseudo}
    Given $\EuScript{F}$ a family of pseudo-disks and $\EuScript B$ a finite family of pseudo-disks, consider the hypergraph $H(\EuScript B,\EuScript F)$ whose vertices are the pseudo-disks in $\EuScript B$ and the edges are all subsets of~$\EuScript B$ of the form $\{D \in \EuScript B,~D \cap S \neq \emptyset\}$, with $S\in \EuScript F$.
  Then the number of edges of cardinality at most $k\geq 1$ in $H(\EuScript B,\EuScript F)$ is $\O(|\EuScript B|k^3)$.
\end{theorem}
A very important aspect in this result is that it is not required that $\EuScript{F} \cup \EuScript{B}$ is a family of pseudo-disks, and thus pseudo-disks of $\EuScript B$ may ``cross'' pseudo disks of $\EuScript F$.
This is indeed the case in our applications where in particular we associate to each tree in $G-M$ a pseudo-disk in $\EuScript{B}$, and this pseudo disk may cross pseudo-disks associated to vertices of  $\EuScript{M}$ (see proof of \autoref{lm:sstringtreeneigh}).

 


\subsection{Application to pseudo-disk graphs}
In this section, we prove that the class of pseudo-disk graphs is nice, and so by our main theorem it admits a robust subexponential FPT algorithm for \FVS. Note that for this graph class, the existence of such algorithm was revy recently given in~\cite{FVS-WG}.
\begin{lemma}\label{lm:pseudotreeneigh}
    There exists a constant $c$ such that the class of pseudo-disk graphs has bounded tree neighborhood complexity with parameters $\alpha=4,~f_1(r)=c$ and $f_2(r,p,m)=cp^3$.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 24}\end{proof}

\begin{lemma}
    There exist constants $c_1,c_2,c_3,c_4$ such that the class of pseudo-disk graphs is a nice class with parameters $\alpha=4,~f_1(r)=c_1,~f_2(r,p,m)=c_2p^3$, $\delta=\frac 12$, $f_r=c_3\sqrt{r\log r}$ and $d_r=c_4r\log r$.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 25}\end{proof}
And so applying our main theorem we obtain:
\maincortwo*
Note that our main theorem gives that it suffices to take $\eta>\frac{44}{45}$ for the result to hold. Sharper results already exist in the literature for pseudo-disk graphs, by generalizing the robust algorithm of \cite{lokSODA22} dealing with disk graphs to pseudo-disk graphs, or by using the representation as pseudo-disks for obtaining an even better running time. See \cite{preprintFVSpseudo}, the full version of \cite{FVS-WG}, for both methods.
\subsection{Application to \texorpdfstring{$s$}{s}-string graphs}\label{ssec:sstring}
We now show how to adapt the arguments from the previous section to the case of $s$-strings.

\begin{lemma}\label{lm:sstringtreeneigh}
 There exist constants $c_1,c_2$ such that the class of $s$-string graphs has bounded tree neighborhood complexity with parameter $\alpha=4, \f_1(r)=c_1s^4r\log r$ and $f_2(r,p,m)=c_2(sr\log r)^4(p+m)^3$.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 26}\end{proof}

\begin{lemma}\label{lm:sstringnice}
    There exist constants $c_1,c_2,c_3,c_4$ such that for every $s\geq 1$ the class of $s$-string graphs is a nice class with parameters $\alpha=4,~f_1(r)=c_1s^4r\log r,~f_2(r,p,m)=c_2(sr\log r)^4(p+m)^3$, $\delta=\frac 12$, $f_r=c_3\sqrt{r\log r}$ and $d_r=c_4r\log r$.
\end{lemma}
\begin{proof}\textcolor{red}{TOPROVE 27}\end{proof}
\begin{figure}
    \centering
    \includegraphics[scale=.6]{img/fusion.eps}
    \caption{Illustration of the construction used in the proof of \autoref{lm:sstringnice} for contracting an edge between adjacent degree-two vertices without a common neighbor.}
    \label{fig:rule2}
\end{figure}

And so applying our main theorem we obtain:
\maincor*
More precisely, we can take $\eta=\frac{52}{53}$.



\section{Conclusion}\label{sec:ccl}

In this paper we gave general sufficient conditions for the existence of subexponential parameterized algorithms for the \fvs problem. Our main theorem unifies the previously known results on several classes of graphs such as planar graphs, map graphs, unit-disk graphs, disk graphs, or more generally pseudo-disk graphs, and string graphs of bounded edge-degree.
It also applies to classes where such algorithms were not known to exist, notably intersection graphs of thin objects such as segment graphs and more generally $s$-string graphs.

However, we have so far no evidence that our concept of nice class could be an answer to \autoref{q:main}. So a natural direction for future research would be to investigate more general graph classes than those listed above or to discover new classes that fit in our framework.
There are two natural candidates:
\begin{itemize}
    \item Intersection graphs of objects in higher dimensions.  However, as proved in \cite{fomin2018excluded}, intersection graphs of unit balls in $\RR^3$ do not admit a subexponential parameterized algorithm for \FVS, unless $P=NP$.
    \item Graph classes excluding an induced minor.\footnote{A graph $H$ is said to be an \emph{induced minor} of a graph $G$ if it can be obtained from $G$ by deleting vertices and contracting edges. Otherwise, $G$ is said to \emph{exclude} $H$ as induced minor or to be \emph{$H$-induced minor free}.} This is more general than string graphs (which exclude a subdivided $K_5$ as an induced minor). In such classes, Korhonen and Lokshtanov \cite{korhonen2023induced} recently provided an algorithm solving \FVS in time $2^{\O_H(n^{2/3}\log n)}$, that is, subexponential in the input size~$n$.
    \end{itemize}
    
    Less general than the previous item is the class of string graphs, which is nevertheless the most general class of intersection graphs of (arc-connected) objects in the Euclidean plane.  At the time of the writing, it is not excluded that it could be a nice class. So far, we are still missing the property about the bounded tree neighborhood complexity. Note that in our proof for $s$-strings, the bound on the number $s$ of crossing is only used to prove that the class satisfies this property of bounded tree neighborhood complexity. Obtaining a similar result without using the bound on the number of crossings would thus yield the desired generalization. But an even simpler way could be to prove that the general case of string graphs can be reduced to the case of $s$-strings graphs for some ``small'' $s$ function of the problem parameter $k$. A first idea would be to prove that $K_{t,t}$-free string graphs are $t^c$-string graphs for some constant $c$, however this fails as there are string graphs with $n$ vertices, and so which are $K_{n,n}$-free, that require $2^{cn}$ crossings for some constant $c$ \cite{stringexpo}.


\bigskip
\bibliography{biblio} \bibliographystyle{alpha}


\end{document}